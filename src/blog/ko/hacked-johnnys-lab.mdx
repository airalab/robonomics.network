---
title: 해킹된 니의 연구소
date: 2024-06-25
published: true
locale: 'ko'
tags: ['Events', 'Online school', 'Web3', ]
cover_image: /blog/images/hacked-johnnys-lab/cover.png
description: 최근 Robonomics가 주최한 이벤트 '해킹된 쟈니의 연구소'가 있었고, 제가 어떤 방식으로 해킹했다고 믿습니다! 규칙 오해로 첫 번째 시도에서 실패한 것을 제외하고, 참가한 모든 라운드에서 이겼고 여기에 간단한 '어떻게' 이야기가 있습니다.
abstract: "여보세요! PaTara입니다. 최근 Robonomics가 주최한 이벤트 '해킹된 쟈니의 연구소'가 있었고, 제가 어떤 방식으로 해킹했다고 믿습니다! 규칙 오해로 첫 번째 시도에서 실패한 것을 제외하고, 참가한 모든 라운드에서 이겼고 여기에 간단한 '어떻게' 이야기가 있습니다. "
---

그럼, 빠르고 필요한 규칙 요약: 혼합된 순서로 된 12개 단어, 실험실을 돌아다니는 TurtleBot 4의 5분 분량의 비디오
그리고 기억술어구 단어 순서를 망가뜨리고, 이기고자 하는 5~20명의 참가자, 그리고 전략을 생각해낼 수 있는 무료 일요일.

<RbImage zoom src="/blog/images/hacked-johnnys-lab/0.png" alt="Game Interface" />

프로그래밍에 어느 정도 익숙하고 괜찮은 노트북이 있지만 이미지 인식 기술은 거의 없습니다. 그 이상으로 
나는 공정하게 게임을 하기로 결정했다. 즉, 비디오 다운로드 없이, 재생 속도 남용 없이, 플레이바 네비게이션 없이. 
그래서 선택한 전략은 오래된 브루트포스였다. 무언가를 해킹하는 것보다 더 그럴싸하게 들린다.
여기에 무엇이 있는가: 섞인 순서의 12개의 단어 세트. 이것은 우리에게 12! (계승) 옵션의 구문을 제공한다. 
(정확히 479,001,600). 처리해야 할 양이 상당하다!


## 전략 1: 어석고 직접적인 것.

음, 무엇이 더 필요한가, 그냥 가서 정리하면 된다! 그러나 여기 첫 번째 속임수가 있다: 12! 기억구문은 내 64GB RAM에 맞지 않았다! IDE 콘솔에서 SIGTERM 오류가 발생했다. 
평가용 실행. 그러나 문제는: 내 노트북은 심지어 최대 속도로 팬을 돌리지 않았다! 단일 코어만 로드되었다. 
그래서 저는 [반복자](https://docs.python.org/3/library/itertools.html#itertools.permutations)를 생성하고 프로세스를 시작했습니다.
정확히 얼마나 걸렸는지는 모르겠지만, 조합 수를 계산하는 데 30초 안에 걸렸습니다.
나는 내 CPU의 모든 논리 코어(20개)를 병렬로 계산하기 위해 Python [multiprocessing](https://docs.python.org/3/library/multiprocessing.html) 패키지를 구글링했다. 

그렇지 않으면 영원한 여행이었을 것이다. 
그러나 그것으로 인해 내 이터레이터를 12개의 부분으로 나눠야 했다. itertools multiprocessing 패키지는 함께 작동하지만, 
전체 옵션이 RAM에 있는 경우. 그것은 내 경우가 아니었으므로 다음이 수행되었다: 
그 순간부터 항상 이 전략을 사용하여 내 CPU 로드 모니터가 다음과 같이 보이도록 만들었다:

<RbImage zoom src="/blog/images/hacked-johnnys-lab/1.png" alt="Parallelizing"/>


나는 실행 시간을 약 5초로 단축했다고 믿는다. 조합을 반복하는 가장 좋은 방법을 얻었지만 그것들이 너무 많았다! 첫 번째 단계는 대략 480만 개의

<RbImage zoom src="/blog/images/hacked-johnnys-lab/1_1.png" alt="CPU Load"/>


네트워크에서 extrinsics를 수행하는 것이었다. 노드는 단순히 DDOS로 나를 금지시킬 이고 그렇지 않아도 영원히 걸릴 것이다! 
디버깅 목적으로 스크립트를 시작했고 (노드 통신에는 
[py-substrate-interface](https://pypi.org/project/substrate-interface/1.0.3/) 패키지를 사용했음) 호출 전에

<RbImage zoom src="/blog/images/hacked-johnnys-lab/2.png" alt="1st Attempt"/>


_유효하지 않은 기억구문_과 같은 오류가 발생했다. 단서! 사전에 조합을 유효성 검사할 수 있다면, 
시간을 많이 절약할 수 있을 것이다! GitHub 파싱을 통해 나는 
[이](https://github.com/polkascan/py-substrate-interface/blob/master/substrateinterface/keypair.py#L170) 
코드 라인을 찾았고 내 스크립트에 조합 유효성 검사를 추가했다. 이로써 잠재적인 extrinsics의 수를 대략 39,000,000으로 줄였다! 
그러나 여전히 39백만 개의 호출은 나를 영원히 금지시킬 것이므로 더 많은 탐구가 필요했다. 어떻게 하면 
계산량을 크게 줄일 수 있을까? 음, 초기 전략을 조금 배신하는 것으로. 보시다시피, 비디오 시청을 피하려고 했지만,
수학이 나의 생각을 바꾸게 만들었다. 132배 빠른 전략으로 바꾸었다.

<RbImage zoom src="/blog/images/hacked-johnnys-lab/3.png" alt="2nd Attempt"/>


아래는 설명이다: 
그렇게 하면 구문의 두 올바른 위치만 알면 된다 (하나는 너무 오래 걸릴 것이라 실험으로 검증됨). 
10! 조합을 반복하고 올바른 위치에 두 단어를 삽입하고 구문을 유효성 검사하여 
옵션을 대략 300,000으로 줄였다! 더불어, 10! 조합 세트가 내 RAM에 맞았다, 훌륭하다!

<RbImage zoom src="/blog/images/hacked-johnnys-lab/4.png" alt="2 Words Insertion"/>


또한 300k번씩 모든 토큰을 전송하려고 하지 않고 공개 노드를 호출하기 위해 
로보노믹스 노드를 설정하고 동기화된 결과 계정 주소 잔액을 요청하기로 결정했다! 
쿼리는 extrinsic보다 '쉽다'. 전체 밤을 동기화하는 동안 (내가 설정한 캐시 한도로)

<RbImage zoom src="/blog/images/hacked-johnnys-lab/5.png" alt="3rd Attempt"/>


또한, 모든 토큰을 300k번 전송하고 이를 위해 퍼블릭 노드를 호출하는 것보다, 저는 체인과 동기화된 제 로컬 Robonomics 노드를 설정하고 결과 계정 주소 잔액을 요청하기로 했습니다!
쿼리는 외부 쿼리보다 훨씬 "쉬웠습니다". 밤새도록 동기화한 후(저는 캐시 한도를 설정하여 ROM에 체인 데이터가 있는 노트북이 폭발하지 않도록 했습니다) 시도해 보았는데.. 재앙이었습니다. 네트워크 거래
(심지어 로컬호스트 내에서도) 너무 많은 시간이 걸렸어요. 끝까지 기다리지도 않았어요, 분명히 영상보는 것보다 훨씬 느렸어요 
계정의 정확한 주소를 알 수만 있다면 좋을텐데! 하지만 그걸 위해서는 니모닉 구절이 필요하죠... **정말 그럴까요?**

보세요. 규칙에 따르면 원하는 계정은 **정확히** 42 XRT를 가지고 있어야 합니다. 왜 나는 네트워크의 모든 활성 주소를 가져오지 않을까요,
정확히 42 XRT를 가진 주소들을 필터링하고 생성된 각 주소를 가능한 대상 목록과 비교합니다 
(약 20개, 마지막에는 1개로 줄어듭니다). 말하기 쉽고 할 수도 있죠. 

이제, 스크립트를 다시 수정한 후에 마침내 원하는 쿼리와 트랜잭션 하나만으로 
원하는 상품을 얻을 수 있을 거예요.

<RbImage zoom src="/blog/images/hacked-johnnys-lab/6.png" alt="4th Attempt"/>


이제, 비디오를 25초 보고 (그 사이에 니모닉의 단어를 채워넣으며), 
보상을 훔치기 위해 최대 30초만 더 필요할 거예요. 해킹했어요.

<RbImage zoom src="/blog/images/hacked-johnnys-lab/7.png" alt="Discord Bot Notification"/>



