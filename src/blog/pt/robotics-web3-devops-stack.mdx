---
title: Pilha de Desenvolvimento Web3 DevOps de Robótica
date: 2024-06-12
published: true
locale: 'pt'
tags: ['DevOps', 'Web3']
cover_image: /blog/images/web3-devops-stack/web3-devops-stack-Cover.png
description: "O movimento DevOps revolucionou o mundo da TI e reformulou nossa compreensão da melhoria contínua e eficaz do sistema. O campo da robótica está apenas começando a explorar essa abordagem. Neste artigo, imaginamos o futuro potencial do DevOps para a robótica usando tecnologias Web3. Também destacamos alguns projetos que poderiam lançar as bases para esse futuro."
abstract: "O movimento DevOps revolucionou o mundo da TI e reformulou nossa compreensão da melhoria contínua e eficaz do sistema. O campo da robótica está apenas começando a explorar essa abordagem. Neste artigo, imaginamos o futuro potencial do DevOps para a robótica usando tecnologias Web3. Também destacamos alguns projetos que poderiam lançar as bases para esse futuro."
---

## Origens do Desenvolvimento e Operações

Os robôs, como dispositivos que se movem e percebem o mundo externo, são um caso específico de computadores. Como os engenheiros costumam dizer, um avião é um computador voador, enfatizando a importância do dispositivo de computação embarcado para manter a viabilidade desse sistema ciberfísico. Portanto, podemos analisar como o mundo dos sistemas de informação se desenvolveu no século XXI e identificar certas tendências que serão inerentes à robótica em um futuro muito próximo.

O software e as práticas usadas para seu desenvolvimento mudaram significativamente as abordagens de trabalho tanto na engenharia quanto em qualquer outra atividade. Em primeiro lugar, as mudanças afetaram a chamada abordagem em cascata, quando qualquer projeto era visto como uma série de longas etapas alternadas: Requisitos - Desenvolvimento - Verificação - Validação - Operação. Com o tempo, ficou claro que a divisão em etapas é conveniente para os gerentes, mas não corresponde exatamente ao que acontece na vida e complica a adaptação rápida de produtos às condições de um mundo externo em constante mudança. Metodologias ágeis, que implicam trabalho síncrono no projeto com pequenos intervalos de planejamento, vieram substituir o modelo em cascata de atividade (e gestão). Em vez de grandes etapas com marcos, houve pequenos sprints com incrementos - mudanças pequenas, mas frequentes, nos sistemas desenvolvidos com um lançamento rápido. Esse ritmo de trabalho é inatingível se o lançamento for acompanhado por procedimentos administrativos complexos com verificações manuais. Assim, o movimento de Desenvolvimento e Operações surgiu para implementar práticas de transferência de valor dos desenvolvedores para os consumidores sem perdas e uma nova profissão de um DevOps.Engenheiro de operações, automatizando o processo de colocar rapidamente o sistema em funcionamento.

![origens do DevOps](/blog/images/web3-devops-stack/devops-evolution.png)

Essas práticas incluem testes automatizados, integração contínua, entrega, implantação e monitoramento de software. Os testes automatizados verificam bugs, enquanto a integração contínua integra mudanças de código com frequência para detectar problemas precocemente. A entrega e implantação envolvem disponibilizar o software para os usuários e instalá-lo em seu ambiente.

Inicialmente, essas práticas ganharam impulso na área de grandes serviços web, que atendem milhões de usuários ao redor do mundo. Nesse contexto, essas práticas são cruciais para manter o alto desempenho e confiabilidade esperados desses serviços. No entanto, à medida que o tempo avançou e as ferramentas de automação se tornaram mais acessíveis (em parte devido às contribuições de código aberto), o DevOps começou a ser utilizado em atividades de engenharia mais tradicionais. Portanto, essas práticas transcenderam seu domínio inicial e agora são empregadas em diversos setores para melhorar a eficiência, confiabilidade e qualidade dos produtos de software.

## Principais Características dos Robôs no Contexto do DevOps

Os robôs, ao contrário de servidores estacionários e data centers, movem-se no espaço e percebem o ambiente externo. Cada vez mais desses dispositivos estão surgindo. Vemos seu poder computacional crescendo ao longo do tempo - muitas soluções técnicas simplesmente seriam impossíveis sem um processador embarcado poderoso.

Com o aumento da computação de borda, que se refere à computação nos próprios dispositivos móveis, o uso do DevOps está se tornando mais popular. Essa abordagem permite a entrega rápida de novas funcionalidades desenvolvidas para os consumidores. Os robôs podem estar continuamente conectados à rede e atualizar prontamente seu software usando Docker e outras ferramentas comprovadas na prática.

No entanto, capacidades adicionais criam riscos adicionais - ao capacitar computadores com a capacidade de interagir intensivamente com o ambiente externo e a internet simultaneamente, criamos condições para possíveis danos que esses dispositivos podem causar se caírem sob o controle de malfeitores. Dispositivos inteligentes, que gradualmente preenchem nossas casas, podem de repente enlouquecer! A questão da segurança aqui é de extrema importância em um mundo em constante mudança, pois todos esses dispositivos estão em proximidade com nossos corpos. Erros podem custar muito caro.

O que torna a robótica especial e a diferencia de outros computadores? Essas características especiais incluem:

1. Uma variedade de plataformas de hardware (em comparação com um número relativamente pequeno de tipos de arquitetura de processador central)
2. Trabalhar em ambientes imprevisíveis, o que implica a presença de situações de emergência - por exemplo,indisponibilidade em canais de comunicação
3. Recursos limitados de dispositivos de computação embarcados - processador fraco, quantidade relativamente pequena de memória e baixa largura de banda de rede4. Requisitos de segurança aumentados
5. Um grande número de dispositivos que requerem atualizações e novos recursos

Considerando essas restrições, tentaremos formular uma base conceitual para DevOps para robôs baseada em tecnologias Web3, pelo menos, para escrever código, construir e implantar. Tentaremos apresentar os projetos Web3 mais interessantes capazes de garantir o funcionamento de um transportador de DevOps descentralizado e mostrar como a Robonomics pode se tornar uma parte integrante dele na fase final do ciclo de vida - ao implementar programas no mundo externo.

## Web3 e Blockchain

Quando falamos sobre Web3, estamos nos referindo principalmente à tecnologia Blockchain. Estes são conceitos intimamente relacionados, mas não exatamente idênticos. Frequentemente, sob este conceito, um conjunto inteiro de tecnologias é implicado - criptografia de curva elíptica, redes P2P, algoritmo de consenso. Os dois primeiros pontos não são algo único e são amplamente utilizados na indústria de TI, enquanto o último realmente dota o blockchain de uma característica especial, tornando essa solução uma ferramenta tão poderosa. Mas será que precisamos de consenso para todas as situações da vida (e partes do transportador DevOps)? Vamos tentar entender.

O consenso tem significados diferentes em contextos diferentes, mas sua essência é sempre a mesma - sistemas, atores ou agentes autônomos que compõem uma rede descentralizada chegam a um acordo sobre qual protocolo usar no trabalho e o estado dos dados comuns. Se as partes não chegarem a um acordo, isso leva ao chamado Fork. Historicamente, um fork implicava uma divisão do blockchain, o que levava à divisão dos nós da rede em duas partes - alguns nós permaneciam "fiéis" à versão antiga do protocolo, enquanto o restante mudava para a nova versão. Esse evento sempre teve um contexto negativo - a comunidade estava diminuindo em vez de se consolidar, o que tornava o projeto de alguma forma mais fraco. Ao mesmo tempo, como na evolução biológica, assim como em sua versão tecnológica observada por nós agora na forma de economia, o ramificação ocorre constantemente e, além disso, leva ao surgimento de novas formas de vida. Olhe para a árvore da vida. Cada ramo nela é um Fork que ocorreu em tempos antigos - uma mutação deu origem a uma nova espécie que se tornou incompatível com seus companheiros de tribo. Sem esse mecanismo, a vida em seu entendimento moderno seria impossível. É a capacidade dos organismos de mutar que lhes permite se adaptar às condições ambientais em mudança.

Assim, chegamos à conclusão de que o consenso é bom, pois permite a coordenação de muitos atores.e escalabilidade, mas ao mesmo tempo é ruim, porque dificulta o surgimento do novo, já que aqueles que se desviam do consenso são sempre considerados excluídos e o sistema meio que os "empurra" para fora.

Ao contrário da evolução biológica, nós humanos realizamos a tecno-evolução, e depende de nós como essa evolução ocorre. A fonte de mutações na tecnologia são os engenheiros, aplicando o método científico e o pensamento criativo para produzir novas versões de tecnologia mais promissoras e viáveis. Nós nos beneficiamos de mutações mais frequentes, nos beneficiamos da descentralização na esfera de geração de novas soluções eficazes tanto em relação à tecnologia quanto às organizações. Por outro lado, uma situação em que um ponto de vista "vence" e um consenso pleno e incondicional é alcançado, está sujeita ao risco de colapso sob certas circunstâncias. É por isso que a natureza não seguiu o caminho de criar superorganismos do tamanho de um planeta, mas seguiu o caminho da descentralização - quando todos os seres vivos estão dispersos em nichos e ecossistemas e isso torna a vida como um todo estável e até estabiliza o planeta Terra de acordo com o [modelo Daisyworld](https://en.wikipedia.org/wiki/Daisyworld) (em resumo, graças à biosfera e sua diversidade, o planeta se torna mais estável).

Então, por que essa digressão? Principalmente, quero enfatizar que nem todos os dados exigem consenso obrigatório, tornando o blockchain inadequado para todos os cenários. O consenso se torna necessário quando ações não coordenadas podem resultar em consequências irreversíveis. Por exemplo, é crucial em cruzamentos de estradas. Se não houver acordo sobre as regras de trânsito quanto a quando avançar e quando parar, você pode imaginar o caos potencial!

Voltando ao tema principal do artigo, pode-se presumir que o consenso é apropriado onde os riscos são altos e, inversamente, nos casos em que os riscos são pequenos, é mais apropriado escolher um sistema completamente descentralizado sem consenso. O desenvolvimento de código em si é uma atividade relativamente segura, desde que permaneça no estado de arquivos de origem ou mesmo arquivos executáveis no servidor de compilação. No entanto, quando se trata de implantar esses arquivos na infraestrutura física do mundo real, é muito importante ser consistente. É por isso que para os dois primeiros pontos de nossa pilha DevOps (desenvolvimento e compilação) escolhemos projetos com mentalidades semelhantes sem consenso.

## Primeira Fase - Desenvolvimento - Radicle

![](/blog/images/web3-devops-stack/1st-phase-development.png)

Portanto, no desenvolvimento de código, é necessária total liberdade e descentralização para estimular ogeração das melhores soluções diretamente dos autores. Felizmente para nós, na indústria de desenvolvimento de código, o padrão de facto tornou-se um sistema de controle de versão descentralizado por design. Estou falando, é claro, sobre o git. O git a priori não implica a presença de uma única "fonte da verdade" - qualquer usuário, antes de usar o código, precisa clonar o repositório para o seu computador e trabalhar com sua cópia local. Além disso, o método de armazenamento de dados no git não é nada mais do que uma cadeia de blocos (fatos fixos de alterações de código - commits), que garantem a imutabilidade da história. Ou seja, o git em si é uma espécie de blockchain, cujo consenso é alcançado manualmente pelos próprios autores através de ramificações e solicitações de mesclagem.

No entanto, apesar da natureza descentralizada do git, as plataformas da web2 tomaram o seu lugar. Agora, o desenvolvimento de código está quase inteiramente centralizado em torno de um número relativamente pequeno de plataformas como Github, Bitbucket, Gitlab. E isso aconteceu precisamente por causa da introdução de ferramentas adicionais: DevOps (pipelines CI/CD, funções integradas para detectar vulnerabilidades em dependências de código-fonte e muito mais) e Redes Sociais (sistemas de recompensa para desenvolvedores, rastreamento de problemas, gerenciamento de projetos). Essas ferramentas não fazem parte do protocolo git original e complicam a migração de projetos de uma plataforma para outra.

O projeto [Radicle](https://radicle.xyz/) foi fundado especificamente com o objetivo de libertar os desenvolvedores de código da necessidade de depender de grandes plataformas, que consideramos como o primeiro componente de nossa pilha Web3-DevOps. O projeto tem uma [longa história](https://docs.radworks.org/community/our-story) e uma série de transformações significativas em seu caminho até o momento atual. Inicialmente, o Radicle foi construído em cima do então ganhando popularidade Inter Planetary File System (IPFS), mas em algum momento os desenvolvedores perceberam que as formas de armazenar e fazer hash dos dados do repositório de código no IPFS eram incompatíveis com as formas de armazenamento no git, levando à duplicação de informações e ao consumo excessivo de tráfego mesmo no caso de pequenas atualizações. Gradualmente, foi tomada a decisão de mudar para uma solução mais minimalista - trocar patches do git diretamente, usando o protocolo nativo [pack protocol](https://git-scm.com/docs/pack-protocol/en), para tornar este o principal modo de transmissão de dados na rede "codekeeper". Essa decisão serviu como o início de uma grande refatoração e reescrita do projeto de Go para Rust. A nova versão do protocolo, chamada Heartwood,retira inspiração de projetos como o Secure Scuttlebutt (SSB) e a [Rede Lightning](https://pt.wikipedia.org/wiki/Rede_Lightning) do Bitcoin.

Posteriormente, em 2021, a Organização Autônoma Descentralizada (ou simplesmente DAO) Radworks foi fundada na blockchain do Ethereum, o token de governança RAD foi emitido e os fundos necessários foram arrecadados para o desenvolvimento contínuo do projeto. Aparentemente, a equipe do projeto não nega a importância dos componentes sociais e econômicos no desenvolvimento de código, mas ao mesmo tempo não tenta integrar todas as ferramentas de suporte em sua implementação. Uma dessas iniciativas é o projeto e contrato inteligente homônimo [Drips](https://www.drips.network/), que tem como objetivo a distribuição automática de doações entre desenvolvedores de código aberto sob o slogan "Financie suas dependências". Dentro deste contrato inteligente, cada projeto de desenvolvimento pode configurar a redistribuição automática das doações recebidas para seu conjunto de dependências (pacotes, bibliotecas).

Recentemente, em março de 2024, foi lançada a versão 1.0.0 da implementação do protocolo Heartwood, o que significa que já pode ser considerado para cenários de produção de pipelines de desenvolvimento descentralizados.

## Segunda Fase - Construir, Testar, Integração Contínua - Fluence

![construção de software web3](/blog/images/web3-devops-stack/2nd-phase-build.png)

O próximo passo em nosso pipeline simplificado de DevOps é a etapa de construção, que inclui mais do que apenas a compilação de código. Envolve uma série de processos com diferentes intensidades de recursos computacionais. No entanto, esses cálculos nem sempre resultam em mudanças tangíveis. Em outras palavras, nem toda alteração de código ou início de construção resulta em um lançamento. Muitas vezes, os pipelines de Integração Contínua (CI) são executados em um cronograma. Os artefatos que produzem são tipicamente de curta duração e são excluídos se não forem incluídos em um lançamento. Portanto, não consideramos esta etapa no ciclo de vida de desenvolvimento como necessitando de consenso, semelhante a inúmeros projetos de computação em nuvem que usam blockchain para verificação de resultados.

Os desenvolvedores do [Fluence](https://fluence.dev/) mantêm uma posição semelhante. Este é um projeto muito próximo do Robonomics, que também usa intensivamente o libP2P como camada de transporte e o ipfs como camada de armazenamento em seus casos de uso, enquanto se concentra na orquestração de pares e cálculos neles sem a necessidade de plataformas centralizadas. Vamos dar uma olhada mais de perto neles.

Fluence é composto por dois componentes principais - Aqua e Marine. O primeiro é uma linguagem específica de domínio (DSL) e é usado para gerenciar a sequência de tarefas.em dispositivos de computação, ou seja, para orquestrar pares. Por um lado, dominar outro idioma pode desencorajar muitos usuários, por outro lado, é um passo honesto que imediatamente o prepara para o futuro inevitável. O fato é que a maioria das plataformas de CI geralmente oferece arquivos de configuração em alguns formatos comuns como YAML ou JSON para gerenciar e configurar pipelines. Inicialmente, isso é realmente conveniente e permite que qualquer usuário sem habilidades de programação comece a trabalhar, mas com o tempo, à medida que as necessidades e, consequentemente, o número de configurações crescem, a falta de ferramentas tão familiares para programadores leva ao crescimento do código boilerplate e à incapacidade de gerenciar a complexidade. As tentativas de tornar o YAML uma linguagem de configuração usando modelos também não resolvem o problema, o que contribui para o surgimento de linguagens de descrição de configuração Ad-hoc como HCL (HashiCorp Configuration Language). Aqua oferece uma solução imediata na forma de uma linguagem de programação de aplicativos para o fluxo de computações, que tem uma base teórica confiável na forma de Pi-cálculo, no qual o código Aqua é compilado para execução posterior em pares. Isso torna o limiar de entrada na tecnologia um pouco mais alto, mas idealmente deve fornecer um trabalho mais estável e sustentável no futuro. Atualmente, Aqua é uma linguagem bastante de baixo nível, mas com o tempo podem surgir bibliotecas que implementam as melhores práticas para projetar fluxos computacionais usando abstrações matemáticas convenientes, o que acelerará o desenvolvimento de computações distribuídas.

Aqua estabelece a ordem das computações, mas as próprias computações são preparadas e realizadas usando o Marine - um componente também desenvolvido pela Fluence. Marine é um SDK (Software Developers Kit) - um conjunto de ferramentas para montar módulos Webassembly mutuamente compatíveis, bem como um Runtime - um ambiente de propósito geral para sua execução. Os módulos são componentes de software relativamente independentes, cada um dos quais armazena seu próprio estado, mas pode interagir entre si por meio de importação/exportação de funções. Um conjunto de módulos interagindo forma um serviço, que implementa comportamentos complexos e atua como um ator na rede de pares da Fluence.

Juntos, Aqua e Marine fornecem totalmente o que pode ser chamado de pensamento de um sistema ciberfísico - ou seja, toda a variedade de computações que ajudam a tomar decisões sobre quais ações tomar no mundo exterior para aumentar as chances de sucesso na corrida evolutiva.

O desenvolvimento de robótica baseado em modelos requer computações intensivas em recursos. Uma parte significativa dos testes do software desenvolvido para robôs é realizada em simuladores, e algoritmos baseados em aprendizado por reforço lançam esses ambientes virtuais centenas de milharesde vezes antes de alcançarem o comportamento desejado do agente. Vários motores de física e renderização, bem como motores de jogo baseados neles, podem servir como ambientes virtuais. Recentemente, o padrão de design Entity Component System tornou-se generalizado nesses ambientes. A propósito, a versão moderna do conhecido simulador robótico Gazebo/ex-Ignition de círculos restritos da Open Robotics (eles também desenvolvem o ROS) também [utiliza ECS](https://gazebosim.org/docs/harmonic/architecture) para aumentar o desempenho e a flexibilidade. Na verdade, de acordo com os desenvolvedores da Fluence, seu modelo de execução é adequado para a implementação de arquiteturas distribuídas construídas com base nesse princípio.

É claro que, para que o software compilado e testado traga valor, ele deve ser implantado em plataformas de hardware. Hipoteticamente, também é possível implantar software usando a Fluence. Na verdade, os próprios desenvolvedores afirmam que sua pilha também permite implantação em pares, e isso é de fato verdade. No entanto, acreditamos que o consenso é necessário e importante na área de interação com o ambiente externo e equipamentos físicos.

## Terceira Fase - Implantação - Robonomics

![arte de implantação de robótica](/blog/images/web3-devops-stack/3rd-phase-deploy.png)

Uma característica importante do software é o fato de que ele não altera o mundo exterior por si só, mas serve como um modelo da realidade circundante e ajuda a fazer algum raciocínio sobre ela - construir hipóteses, propor um plano de ação, iniciar processos no mundo exterior usando equipamentos ou pessoas. Por exemplo, um rastreador de problemas em si não é um sistema que muda o mundo exterior, pode ser chamado de um gêmeo digital da equipe de desenvolvimento, que por sua vez traz mudanças para a vida. Graças ao rastreador de problemas, a equipe pode coordenar ações entre si, se ajudar. Em outras palavras, o rastreador de problemas permite manter um consenso dentro da equipe de desenvolvimento - quem faz quais tarefas e quando - mas a mudança em si é feita pelas pessoas.

Ao discutir sistemas que mudam o mundo, nos referimos a entidades físicas que operam no mundo real, como dispositivos inteligentes, robôs e fábricas autônomas. Essencialmente, o Robonomics serve como uma ponte entre sistemas de informação e pessoas para o mundo externo por meio de sistemas robóticos. A importância da segurança não pode ser subestimada, pois negligenciá-la poderia levar não apenas a perdas de capital, mas também a verdadeiros desastres.

Apesar da natureza crítica desses sistemas, os primeiros sistemas de armazenamento descentralizado seguros não apareceram no setor industrial, mas no setor financeiro. Contas bancárias provaram ser umUm alvo mais atraente para criminosos cibernéticos do que eletrodomésticos, a maioria dos quais não possuía conectividade de rede. A tecnologia usada para proteger os sistemas de informação bancária evoluiu significativamente, do SWIFT para o Ethereum, e agora está sendo gradualmente implementada em outros setores econômicos.

A Robonomics está na vanguarda dessas redes seguras e descentralizadas, assumindo a responsabilidade pela fase final do transportador de DevOps da Web3 - implantação.

Em termos gerais, uma implantação é colocar um sistema em operação. Um sinônimo mais familiar para esse termo é instalação (instalar) - um evento após o qual o sistema produzido e entregue (uma instância de um certo tipo de equipamento, um arquivo executável de software) começa a funcionar dentro de um sistema de nível superior. O que é bom sobre blockchain neste caso? Em primeiro lugar, ao lançar qualquer versão do programa para o mundo exterior, é sempre importante para nós entender o que exatamente foi lançado. Durante o desenvolvimento, as versões podem mudar com muita frequência e isso é normal, portanto, não é aconselhável colocar todas as informações sobre elas no blockchain. No entanto, o evento de lançamento ou início requer fixação, para que, ao receber feedback, possamos entender claramente com qual versão exata de códigos-fonte ou desenhos precisamos comparar esse feedback. O blockchain pode servir como um repositório confiável de informações sobre todas as atualizações de software de dispositivos conectados a ele.

Além disso, o processo de instalação deve ser consistente, pois discrepâncias podem levar a colisões de configuração. Essas colisões podem surgir de versões de módulos de software incompatíveis, implantação de sistemas diferentes no mesmo espaço e outros problemas relacionados. Por exemplo, a colisão de carros mencionada anteriormente em um cruzamento não regulamentado é um exemplo de tal colisão. No contexto da implantação de software, as colisões podem se manifestar como violações de API, capacidades de hardware insuficientes ou gravação em locais de memória proibidos ou inseguros. A Robonomics pode armazenar as configurações dos equipamentos conectados e, no nível do algoritmo de consenso, evitar tais estados.

Você pode usar uma chamada de [lançamento](https://wiki.robonomics.network/docs/launch/) especial para implantar software na paracadeia da Robonomics, o que permite iniciar um nó conectado ao blockchain com parâmetros adicionais. O parâmetro pode ser um identificador exclusivo na rede de distribuição de conteúdo IPFS, de onde você pode obter uma imagem de software, um arquivo binário, código-fonte para a configuração do sistema operacional ou até mesmo um script bash! Como cada transação na rede é assinada com uma chave criptográfica, essencialmente tal chamada na paracadeia é equivalente a uma assinatura de lançamento público.

Para cenários mais complexos, você pode usar um [gêmeo digital](https://wiki.robonomics.network/docs/digital-twins/), que permite estabelecer uma tabela de correspondência entre dados arbitrários de 256 bits de comprimento e uma conta na rede Robonomics. Assim, é possível manter um registro das alterações de versão de configuração para contas de dispositivos na rede Robonomics. Nos sistemas tradicionais de configuração e implantação, os hosts geralmente são especificados como nós - esses são computadores com um nome DNS ou endereço IP. No caso do Web3, os hosts são identificados graças às suas chaves criptográficas públicas, às quais as contas estão anexadas. Para alterar a configuração, é possível adicionar um novo identificador de conteúdo, a partir do qual o dispositivo receberá uma nova versão do software e se atualizará.

## Juntando tudo

![web3 devops stack](/blog/images/web3-devops-stack/devop-stack-full-art.png)

Então, vamos tentar olhar para isso de cima. As pessoas compõem o núcleo do nosso grande sistema ciberfísico. As pessoas são caóticas, imprevisíveis... e isso é bom! Elas geram novos significados, ideias, produtos. Elas atualizam sua vontade de mudar o mundo. Agora, no século XXI, não é mais necessário mudar o mundo com as próprias mãos. Existem tarefas diante da humanidade para as quais as mãos humanas não são a ferramenta mais adequada. Em vez disso, existem máquinas, que agora servem como condutoras de nossa vontade. As máquinas, por outro lado, são estritamente determinísticas e previsíveis. E as pessoas adoram isso, sim. Elas adoram quando o trem chega à estação na hora certa, e a qualidade dos produtos que consomem é sempre previsivelmente excelente. Para isso, as pessoas usam redes. Muitas redes! Elas geram ideias na rede Radicle, as máquinas as reúnem e testam em módulos executáveis na rede Fluence e, em seguida, as implantam em robôs na rede Robonomics. Os robôs, por sua vez, transformam o ambiente, e seus sensores, também por meio de Robonomics, fornecem feedback às pessoas para tomar uma decisão - o ciclo se fecha. Este é um ciclo de melhorias contínuas, onde todos têm seu lugar. Não há contradição entre a máquina e o humano - ambos em harmonia criam uma nova ordem da humanidade - a humanidade interplanetária.