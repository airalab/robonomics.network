---
title: Стек розробки Robotics Web3 DevOps
date: 2024-06-12
published: true
locale: 'uk'
tags: ['DevOps', 'Web3']
cover_image: /blog/images/web3-devops-stack/web3-devops-stack-Cover.png
description: "Рух DevOps революціонізував світ ІТ та перетворив наше розуміння ефективного, постійного вдосконалення систем. Галузь робототехніки тільки починає досліджувати цей підхід. У цій статті ми уявляємо потенційне майбутнє DevOps для робототехніки з використанням технологій Web3. Ми також висвітлюємо кілька проектів, які можуть закласти фундамент для цього майбутнього."
abstract: "Рух DevOps революціонізував світ ІТ та перетворив наше розуміння ефективного, постійного вдосконалення систем. Галузь робототехніки тільки починає досліджувати цей підхід. У цій статті ми уявляємо потенційне майбутнє DevOps для робототехніки з використанням технологій Web3. Ми також висвітлюємо кілька проектів, які можуть закласти фундамент для цього майбутнього."
---

## Походження розробки та операцій

Роботи, як пристрої, що рухаються та відчувають зовнішній світ, є конкретним випадком комп'ютерів. Як часто кажуть інженери, літак - це літаючий комп'ютер, підкреслюючи важливість обчислювального пристрою на борту для забезпечення життєздатності цієї кібер-фізичної системи. Тому ми можемо розглянути, як світ інформаційних систем розвивався у 21 столітті та визначити певні тенденції, які будуть властиві робототехніці в найближчому майбутньому.

Програмне забезпечення та практики, використовувані для його розробки, значно змінили підходи до роботи як в інженерії, так і в будь-якій іншій діяльності. Перш за все, зміни вплинули на так званий водоспадний підхід, коли будь-який проект розглядався як послідовність тривалих чергуючих етапів: Вимоги - Розробка - Перевірка - Підтвердження - Експлуатація. З часом виявилося, що поділ на етапи зручний для менеджерів, але не зовсім відповідає тому, як це відбувається в житті та ускладнює швидке адаптування продуктів в умовах постійно змінного зовнішнього світу. Методології Agile, що передбачають синхронну роботу над проектом з невеликими інтервалами планування, прийшли на заміну водоспадній моделі діяльності (та управління). Замість великих етапів з віхами, були невеликі спринти з інкрементами - невеликі, але часті зміни в розроблених системах з швидким випуском. Такий темп роботи недосяжний, якщо випуск супроводжується складними адміністративними процедурами з ручними перевірками. Таким чином, рух розробки та операцій виник, щоб реалізувати практики передачі вартості від розробників споживачам без втрат та нову професію розробника (DevOps).Інженер з операційних робіт, який автоматизує процес швидкого введення системи в експлуатацію.

![походження DevOps](/blog/images/web3-devops-stack/devops-evolution.png)

Ці практики включають автоматизоване тестування, постійну інтеграцію, доставку, розгортання та моніторинг програмного забезпечення. Автоматизоване тестування перевіряє помилки, тоді як постійна інтеграція часто інтегрує зміни в коді для виявлення проблем на ранніх етапах. Доставка та розгортання передбачають надання програмного забезпечення користувачам та його встановлення в їхньому середовищі.

Спочатку ці практики набули популярності в галузі великих веб-сервісів, які обслуговують мільйони користувачів по всьому світу. У такому контексті ці практики є важливими для підтримки високої продуктивності та надійності, які очікуються від таких сервісів. Однак з часом, із поширенням засобів автоматизації (частково завдяки внеску у відкрите програмне забезпечення), DevOps почав використовуватися в більш традиційних видів інженерної діяльності. Таким чином, ці практики вийшли за межі своєї початкової сфери застосування і зараз використовуються в різних секторах для покращення ефективності, надійності та якості програмних продуктів.

## Основні особливості роботів в контексті DevOps

Роботи, на відміну від стаціонарних серверів та дата-центрів, рухаються в просторі та відчувають зовнішнє середовище. Їх стає все більше. Ми бачимо, як їх обчислювальна потужність зростає з часом - багато технічних рішень просто були б неможливі без потужного вбудованого процесора.

Зі зростанням розподіленого обчислення, яке відноситься до обчислень на мобільних пристроях самій, використання DevOps стає все популярнішим. Цей підхід дозволяє швидко постачати нові розроблені функції споживачам. Роботи можуть постійно бути підключені до мережі та швидко оновлювати своє програмне забезпечення за допомогою Docker та інших інструментів, які вже зарекомендували себе на практиці.

Однак додаткові можливості створюють додаткові ризики - надаючи комп'ютерам можливість інтенсивно взаємодіяти з зовнішнім середовищем та Інтернетом одночасно, ми створюємо передумови для потенційної шкоди, яку ці пристрої можуть завдати, якщо вони потраплять під контроль зловмисників. Розумні пристрої, поступово заповнюючи наші домівки, можуть раптово вибухнути! Питання безпеки тут має вирішальне значення в постійно змінному світі, оскільки всі ці пристрої знаходяться у непосредній близькості до наших тіл. Помилки можуть коштувати занадто дорого.

Що робить роботи особливими та відрізняє їх від інших комп'ютерів? Ці особливості включають:

1. Різноманітні апаратні платформи (у порівнянні з відносно невеликою кількістю типів архітектури центрального процесора)
2. Робота в непередбачуваних середовищах, що передбачає наявність надзвичайних ситуацій - наприклад, недоступність через комунікаційні канали
3. Обмежені ресурси вбудованих обчислювальних пристроїв - слабкий процесор, відносно невелика кількість пам'яті та низька пропускна здатність мережі4. Збільшені вимоги до безпеки
5. Велика кількість пристроїв, які потребують оновлень та нових функцій

Враховуючи ці обмеження, ми спробуємо сформулювати концептуальну основу DevOps для роботів на основі технологій Web3, принаймні, для написання коду, збирання та розгортання. Ми спробуємо представити найцікавіші проекти Web3, здатні забезпечити функціонування децентралізованого конвеєра DevOps та показати, як Robonomics може стати його невід'ємною частиною на завершальній фазі життєвого циклу - під час впровадження програм у зовнішній світ.

## Web3 та Блокчейн

Коли ми говоримо про Web3, ми перш за все маємо на увазі технологію блокчейну. Це, звичайно, тісно пов'язані концепції, але не зовсім ідентичні. Часто під цим поняттям мається на увазі цілий набір технологій - еліптична крива криптографія, P2P мережі, алгоритм консенсусу. Перші два пункти - це не щось унікальне і широко використовується в галузі ІТ-індустрії, тоді як останнє дійсно надає блокчейну особливу властивість, роблячи це рішення таким потужним інструментом. Але чи потрібен консенсус для всіх життєвих ситуацій (та частини конвеєра DevOps)? Давайте спробуємо розібратися в цьому.

Консенсус має різні значення в різних контекстах, але його суть завжди залишається незмінною - системи, актори або автономні агенти, що складають децентралізовану мережу, приходять до згоди щодо того, який протокол вони використовують у роботі та стану загальних даних. Якщо сторони не приходять до згоди, це призводить до так званого Fork. Історично fork передбачав розгалуження блокчейну, що призводило до розділення вузлів мережі на дві частини - деякі вузли залишалися "вірними" старій версії протоколу, тоді як інші переходили на нову версію. Ця подія завжди мала негативний контекст - спільнота скорочувалася замість консолідації, що робило проект якось слабкішим. У той же час, як у біологічній еволюції, так і в її техно-версії, яку ми спостерігаємо зараз у формі економіки, розгалуження відбувається постійно і, більше того, воно призводить до появи нових форм життя. Подивіться на дерево життя. Кожна гілка на ньому - це Fork, який відбувся в давні часи - мутація породила новий вид, який став несумісним зі своїми племінниками. Без цього механізму життя в його сучасному розумінні було б неможливим. Саме здатність організмів до мутацій дозволяє їм адаптуватися до змінних умов навколишнього середовища.

Отже, ми приходимо до висновку, що консенсус є як позитивним, оскільки він дозволяє координацію багатьох акторіві масштабованість, але водночас це погано, оскільки заважає появі нового, оскільки ті, хто відхиляються від консенсусу, завжди вважаються вигнанцями, і система як би "відштовхує" їх.

На відміну від біологічної еволюції, ми, люди, здійснюємо техно-еволюцію, і від нас залежить, як ця еволюція відбувається. Джерелом мутацій у технологіях є інженери, які застосовують науковий метод та творче мислення для створення нових, більш перспективних та життєздатних версій технологій. Ми користуємося більш частими мутаціями, ми користуємося децентралізацією у сфері створення нових ефективних рішень як у технологіях, так і в організаціях. Навпаки - ситуація, коли одна точка зору "перемагає" і досягається повний і беззастережний консенсус, несе ризик руйнування в певних обставинах. Тому природа не пішла шляхом створення суперорганізмів розміром з планету, а пішла шляхом децентралізації - коли всі живі істоти розкидані по екологічних нішах та екосистемах, що робить життя в цілому стабільним і навіть стабілізує планету Земля згідно з [моделлю Daisyworld](https://en.wikipedia.org/wiki/Daisyworld) (коротко кажучи, завдяки біосфері та її різноманітності планета стає більш стабільною).

Тож, чому цей відхід? Перш за все, я хочу підкреслити, що не для всіх даних потрібен обов'язковий консенсус, тому блокчейн не підходить для кожного сценарію. Консенсус стає необхідним, коли незгодні дії можуть призвести до необоротних наслідків. Наприклад, це критично на перехрестях доріг. Якщо немає узгодженості щодо правил дорожнього руху щодо того, коли рухатися і коли зупинятися, можна уявити потенційний хаос!

Повертаючись до основної теми статті, можна припустити, що консенсус відповідний там, де ризики великі, і, навпаки, у випадках, коли ризики невеликі, більш доцільно обрати повністю децентралізовану систему без консенсусу. Сам процес розробки коду є відносно безпечною діяльністю, поки він залишається у вигляді вихідних або навіть виконуваних файлів на сервері збірки. Однак, коли мова йде про розгортання цих файлів у фізичній інфраструктурі реального світу, дуже важливо дотримуватися послідовності. Тому для перших двох пунктів нашого стеку DevOps (розробка та збірка) ми обрали проекти з однодумцями без консенсусу.

## Перша фаза - Розробка - Radicle

![](/blog/images/web3-devops-stack/1st-phase-development.png)

Отже, у розробці коду потрібна повна свобода та децентралізація для стимуляціїгенерація найкращих рішень безпосередньо від авторів. На щастя для нас, в індустрії розробки коду стандартом став децентралізований система контролю версій за дизайном. Я, звичайно, говорю про git. git апріорі не передбачає наявність єдиного "джерела правди" - будь-який користувач, перш ніж використовувати код, повинен клонувати репозиторій на свій комп'ютер і працювати зі своєю локальною копією. Крім того, метод зберігання даних в git - це ніщо інше, як ланцюжок блоків (фіксовані факти змін коду - коміти), які гарантують незмінність історії. Тобто git сам по собі є свого роду блокчейном, консенсус між яким досягається вручну авторами через розгалуження та запити на злиття.

Тим не менш, незважаючи на децентралізований характер git, платформи web2 зайняли своє місце. Тепер розробка коду майже повністю централізована навколо відносно невеликої кількості платформ, таких як Github, Bitbucket, Gitlab. І це сталося саме через впровадження додаткових інструментів: DevOps (CI/CD конвеїри, вбудовані функції для виявлення вразливостей у залежностях вихідного коду та багато іншого) та соціальні мережі (системи винагород для розробників, відстеження проблем, управління проектами). Ці інструменти не є частиною оригінального протоколу git і ускладнюють міграцію проектів з платформи на платформу.

Проект [Radicle](https://radicle.xyz/) був заснований саме з метою звільнити розробників коду від необхідності залежати від великих платформ, які ми вважаємо першою складовою нашого стеку Web3-DevOps. Проект має досить [довгу історію](https://docs.radworks.org/community/our-story) та ряд значних трансформацій на шляху до поточного моменту. Спочатку Radicle був побудований на популярній тоді мережі Inter Planetary File System (IPFS), але на певному етапі розробники усвідомили, що способи зберігання та хешування даних репозиторію коду в IPFS були несумісні зі способами зберігання в git, що призводило до дублювання інформації та зайвого споживання трафіку навіть у випадку невеликих оновлень. Поступово було прийнято рішення перейти до більш мінімалістичного рішення - обмінюватися git патчами безпосередньо, використовуючи вбудований [протокол упаковки](https://git-scm.com/docs/pack-protocol/en), щоб зробити це основним способом передачі даних в мережі "codekeeper". Це рішення послужило початком значного рефакторингу та переписування проекту з Go на Rust. Нова версія протоколу, під назвою Heartwood,надихується проектами, такими як Secure Scuttlebutt (SSB) та [Мережа Lightning](https://en.wikipedia.org/wiki/Lightning_Network) Bitcoin.

Пізніше, у 2021 році, на блокчейні Ethereum було засновано Децентралізовану Автономну Організацію (або просто DAO) Radworks, випущено токен управління RAD та зібрано необхідні кошти для подальшого розвитку проекту. Здається, команда проекту не відкидає важливості соціальних та економічних компонентів у розробці коду, але водночас не намагається інтегрувати всі підтримуючі інструменти у свою реалізацію. Однією з таких ініціатив є їх проект та однойменний смарт-контракт [Drips](https://www.drips.network/), спрямований на автоматичний розподіл пожертв серед розробників відкритого коду під гаслом "Фінансуйте свої залежності". У межах цього смарт-контракту кожен розробницький проект може налаштувати автоматичне перерозподілення отриманих пожертв для свого набору залежностей (пакетів, бібліотек).

Зовсім недавно, у березні 2024 року, було випущено реліз 1.0.0 реалізації протоколу Heartwood, що означає, що його вже можна розглядати для виробничих сценаріїв децентралізованих розробницьких конвеєрів.

## Друга фаза - Будівництво, Тестування, Постійна інтеграція - Fluence

![web3 build software](/blog/images/web3-devops-stack/2nd-phase-build.png)

Наступним кроком у нашому спрощеному конвеєрі DevOps є етап будівництва, який включає в себе не лише компіляцію коду. Це охоплює ряд процесів з різними обчислювальними ресурсами. Однак ці обчислення не завжди призводять до конкретних змін. Іншими словами, не кожна зміна коду або запуск будівництва призводить до релізу. Часто конвеєри постійної інтеграції (CI) працюють за розкладом. Артефакти, які вони створюють, зазвичай мають короткий термін життя і видаляються, якщо не включені до релізу. Тому ми не вважаємо цей етап у життєвому циклі розробки потребуючим консенсусу, схоже на численні проекти хмарних обчислень, які використовують блокчейн для підтвердження результатів.

Розробники [Fluence](https://fluence.dev/) тримають схожу позицію. Це проект, дуже близький до Robonomics, який також інтенсивно використовує libP2P як транспортний рівень та ipfs як рівень зберігання у своїх випадках використання, зосереджуючись на оркестрації пірів та обчисленнях на них без необхідності централізованих платформ. Давайте розглянемо їх докладніше.

Fluence складається з двох ключових компонентів - Aqua та Marine. Перший є мовою, специфічною для домену (DSL) і використовується для управління послідовністю завданьна обчислювальних пристроях, тобто для оркестрування рівних. З одного боку, володіння іншою мовою може відлякати багатьох користувачів, з іншого боку, це чесний крок, який одразу готує вас до необхідного майбутнього. Факт полягає в тому, що більшість платформ CI зазвичай пропонують файли конфігурації у деяких загальних форматах, таких як YAML або JSON для управління та налаштування конвеєрів. Спочатку це дійсно зручно і дозволяє будь-якому користувачеві без навичок програмування почати працювати, але з часом, коли зростають потреби і, відповідно, кількість конфігурацій, відсутність таких звичних інструментів для програмістів призводить до зростання шаблонного коду та неможливості управління складністю. Спроби зробити YAML мовою конфігурації за допомогою шаблонів також не вирішують проблему, що сприяє появі мов опису конфігурації Ad-hoc, таких як HCL (HashiCorp Configuration Language). Aqua пропонує миттєве рішення у вигляді мови програмування для потоку обчислень, яка має надійну теоретичну базу у вигляді Pi-калькулю, в який Aqua-код компілюється для подальшого виконання на рівних. Це робить поріг входу в технологію трохи вищим, але в ідеалі повинно забезпечити більш стабільну та підтримувану роботу в майбутньому. Зараз Aqua є досить низькорівневою мовою, але з часом можуть з'явитися бібліотеки, які реалізують найкращі практики для проектування обчислювальних потоків за допомогою зручних математичних абстракцій, що прискорить розробку розподілених обчислень.

Aqua встановлює порядок обчислень, але самі обчислення підготовлені та виконуються за допомогою Marine - компонента, також розробленого Fluence. Marine - це SDK (Набір інструментів для розробників програмного забезпечення) - набір інструментів для збирання взаємно сумісних модулів Webassembly, а також Runtime - загальнопризначене середовище для їх виконання. Модулі є відносно незалежними програмними компонентами, кожен з яких зберігає свій власний стан, але може взаємодіяти один з одним через імпорт/експорт функцій. Набір взаємодіючих модулів формує сервіс, який реалізує складну поведінку та виступає як актор в мережі рівних Fluence.

Разом Aqua та Marine повністю забезпечують те, що можна назвати мисленням кібер-фізичної системи - тобто всім різноманітними обчисленнями, які допомагають приймати рішення про те, які дії вжити у зовнішньому світі для збільшення шансів на успіх у еволюційній гонці.

[Модельно-орієнтоване](https://en.wikipedia.org/wiki/Model-based_systems_engineering) розроблення робототехніки вимагає великих обчислень. Значна частина тестів розробленого програмного забезпечення для роботів проводиться в симуляторах, а алгоритми на основі навчання з підсиленням запускають такі віртуальні середовища сотні тисяччисло раз, перш ніж досягти бажаної поведінки агента. Різні фізичні та рендерингові двигуни, а також гральні двигуни, що ґрунтуються на них, можуть служити віртуальними середовищами. Нещодавно шаблон проектування Сутність-Компонент-Система став широко поширеним у цих середовищах. До речі, сучасна версія відомого в узких колах робототехнічного симулятора Gazebo/ex-Ignition від Open Robotics (вони також розробляють ROS) також [використовує ECS](https://gazebosim.org/docs/harmonic/architecture) для підвищення продуктивності та гнучкості. Фактично, за словами розробників Fluence, їх модель виконання добре підходить для реалізації розподілених архітектур, побудованих на цьому принципі.

Звичайно, щоб скомпільоване та протестоване програмне забезпечення приносило користь, його потрібно розгорнути на апаратних платформах. Гіпотетично, також можливо розгорнути програмне забезпечення за допомогою Fluence. Фактично, самі розробники кажуть, що їх стек також дозволяє розгортання на рівних, і це дійсно так. Однак ми вважаємо, що для взаємодії зовнішнього середовища та фізичного обладнання потрібен консенсус.

## Третій етап - Розгортання - Робономіка

![мистецтво розгортання робототехніки](/blog/images/web3-devops-stack/3rd-phase-deploy.png)

Важливою особливістю програмного забезпечення є те, що воно само по собі не змінює зовнішній світ, а служить моделлю навколишньої реальності та допомагає робити деякі висновки про неї - формулювати гіпотези, пропонувати план дій, запускати процеси у зовнішньому світі за допомогою обладнання або людей. Наприклад, система відстеження проблем сама по собі не є системою, що змінює зовнішній світ, її можна назвати цифровим відображенням команди розробників, яке, в свою чергу, вносить зміни в життя. Завдяки системі відстеження проблем команда може координувати дії один з одним, допомагати один одному. Іншими словами, система відстеження проблем дозволяє підтримувати консенсус у команді розробників - хто робить які завдання і коли - але сама зміна вноситься людьми.

Під час обговорення систем, що змінюють світ, ми маємо на увазі фізичні об'єкти, які працюють у реальному світі, такі як розумні пристрої, роботи та автономні фабрики. Фактично, Робономіка служить мостом від інформаційних систем та людей до зовнішнього світу через робототехнічні системи. Важливість безпеки не може бути переоцінена, оскільки її ігнорування може призвести не лише до втрат капіталу, але й до реальних катастроф.

Незважаючи на критичний характер цих систем, перші безпечні децентралізовані системи зберігання з'явилися не в промисловому секторі, а в фінансовому секторі. Банківські рахунки виявилисяцікавіша мета для комп'ютерних злочинців, ніж побутові пристрої, більшість з яких не мають мережевого підключення. Технологія, яка використовується для захисту банківських інформаційних систем, значно еволюціонувала, від SWIFT до Ethereum, і зараз поступово впроваджується в інші економічні сектори.

Robonomics перебуває на передньому краї цих безпечних, децентралізованих мереж, беручи на себе останню фазу конвеєра Web3 DevOps - розгортання.

У загальних термінах, розгортання - це введення системи в роботу. Більш знайомий синонім для цього терміну - встановлення (install) - подія, після якої вироблена та доставлена система (екземпляр певного типу обладнання, виконуваний файл програмного забезпечення) починає свою роботу всередині системи вищого рівня. Що добре в цьому випадку з блокчейном? По-перше, при випуску будь-якої версії програми на зовнішній світ завжди важливо зрозуміти, що саме було випущено. Під час розробки версії можуть змінюватися дуже часто, і це нормально, тому не рекомендується зберігати всю інформацію про них в блокчейні. Однак подія випуску або запуску потребує фіксації, щоб при отриманні відгуку ми могли чітко зрозуміти, з якою саме версією вихідних кодів або малюнків нам потрібно порівняти цей відгук. Блокчейн може служити надійним сховищем інформації про всі оновлення програмного забезпечення пристроїв, підключених до нього.

Крім того, процес встановлення повинен бути послідовним, оскільки розбіжності можуть призвести до конфліктів конфігурації. Ці конфлікти можуть виникати внаслідок несумісності версій програмних модулів, розгортання різних систем в одному просторі та інших пов'язаних проблем. Наприклад, раніше згадане зіткнення автомобілів на нерегульованому перехресті є прикладом такого зіткнення. У контексті розгортання програмного забезпечення конфлікти можуть проявлятися як порушення API, недостатні можливості апаратного забезпечення або запис на заборонені або небезпечні місця пам'яті. Robonomics може зберігати конфігурації підключеного обладнання та, на рівні алгоритму консенсусу, запобігати таким станам.

Ви можете використовувати спеціальний [launch](https://wiki.robonomics.network/docs/launch/) виклик для розгортання програмного забезпечення в паралельному ланцюжку Robonomics, що дозволяє запустити вузол, підключений до блокчейну з додатковими параметрами. Параметр може бути унікальним ідентифікатором в мережі розподілу вмісту IPFS, з якого можна отримати зображення програмного забезпечення, бінарний файл, вихідний код для конфігурації операційної системи або навіть сценарій bash! Оскільки кожна транзакція в мережі підписується криптографічним ключем, по суті такий виклик в паралельному ланцюжку еквівалентний публічному підпису випуску.

Для більш складних сценаріїв ви можете використовувати [цифровий двійник](https://wiki.robonomics.network/docs/digital-twins/), що дозволяє встановити таблицю відповідності між довільними даними довжиною 256 біт та обліковим записом в мережі Robonomics. Таким чином, можна вести журнал змін версій конфігурації для облікових записів пристроїв в мережі Robonomics. У традиційних системах конфігурації та розгортання, хости зазвичай вказуються як вузли - це комп'ютери з іменем DNS або IP-адресою. У випадку Web3 хости ідентифікуються завдяки їхнім публічним криптографічним ключам, до яких приєднані облікові записи. Для зміни конфігурації можна додати новий ідентифікатор вмісту, з якого пристрій отримає нову версію програмного забезпечення та оновиться.

## Зведення всього разом

![web3 devops stack](/blog/images/web3-devops-stack/devop-stack-full-art.png)

Тож, давайте спробуємо подивитися на це з пташиного польоту. Люди складають основу нашої великої кібер-фізичної системи. Люди хаотичні, непередбачувані... і це добре! Вони генерують нові значення, ідеї, продукти. Вони актуалізують свою волю змінювати світ. Тепер, у 21 столітті, не обов'язково змінювати світ своїми власними руками. Є завдання перед людством, для вирішення яких людські руки не є найбільш підходящим інструментом. Замість цього є машини, які зараз служать провідником нашої волі. Машини, навпаки, строго детерміновані та передбачувані. І люди це люблять, так. Вони люблять, коли поїзд прибуває на станцію вчасно, і якість продуктів, які вони споживають, завжди передбачувано відмінна. Для цього люди використовують мережі. Багато мереж! Вони генерують ідеї на мережі Radicle, машини збирають та перевіряють їх у виконавчі модулі на мережі Fluence, а потім розгортають їх на роботах в мережі Robonomics. Роботи, з свого боку, трансформують середовище, а їхні сенсори, також через Robonomics, надають зворотний зв'язок людям для прийняття рішення - цикл закритий. Це цикл постійних вдосконалень, де кожен має своє місце. Немає протиріч між машиною та людиною - обидва вони у гармонії створюють новий порядок людства - міжпланетне людство.