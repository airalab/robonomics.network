{"hash":"fca83db4e11496b87659dd79c727581ed8e6a838","data":{"TagPosts":{"title":"Collaborations","belongsTo":{"totalCount":16,"pageInfo":{"totalPages":1,"currentPage":1},"edges":[{"node":{"title":"Testing Neon EVM with Robonomics Smart Contracts","path":"/blog/testing-neon-with-robonomics/","date":"October 3, 2022","description":"The purpose of these tests were to validate the readiness of the Neon platform to move to the production stage using Robonomics smart contracts, which allow cyber-physical systems (robots) to make technical-economic transactions.","content":"\n## TL;DR\n\nThe purpose of these tests were to validate the readiness of the [Neon](https://neon-labs.org/) platform to move to the production stage using Robonomics smart contracts, which allow cyber-physical systems (robots) to make technical-economic transactions.\n\nIn the Robonomics network, interaction is established between two parties: Promisee - the one who orders the service, sends a description of technical task and transfers funds for its execution; Promisor - one who performs a service. A typical scenario was tested, whereby a liability contract is concluded between a Promisee and a Promisor - this was followed by validation of the resulting work by a third party, and a commission payment to the node that accompanied the contract between the parties.\n\nFor this example, a simulation of a robotic arm was used, which was asked to perform a sequence of actions. The tests were successful.\n\n## Scope and Goals of Testing\n\nEngineers of [Multi-Agent Systems](https://multi-agent.io/) have been working with [Robonomics Network](https://robonomics.network/) for several years. The first implementation of the Robonomics Network was created for the Ethereum network. It is a set of smart contracts for machine-to-machine communication.\n\nThe core of the Robonomics Network is the [Liability](https://github.com/airalab/robonomics_contracts/blob/master/contracts/robonomics/Liability.sol) contract, a smart contract that reproduces the typical relationship between the customer of a service (Promisee) and the service provider (Promisor), and includes the technical and economic parameters of the transaction between them. The parties can be either an autonomous agent and a person (human-to-machine interaction), or purely two autonomous agents (machine-to-machine interaction). The Promisee and Promisor broadcast messages with the parameters of their technical-economic transaction, and then the conclusion of the transaction is provided by a special node - the Provider - which looks for matches of these parameters. Providers are controlled by [Lighthouse](https://github.com/airalab/robonomics_contracts/blob/master/contracts/robonomics/Lighthouse.sol), which is a special smart contract that executes a transaction when the provider establishes a market match between the parties.\n\nThere are three scenarios in which the fulfillment of an obligation can take place:\n\n1. A simple commitment (with no verification of the final result, and no commission paid to Provider nodes)\n2. Obligation with a commission paid to the Provider\n3. Commitment with a commission to the Provider and validation of the results with the help of a third party - observing network.\n\nThe purpose of this test is to test the most complex, third Robonomics scenario on the Neon EVM platform.\n\n## Testing Scenarios Description\n\nAs we develop the industrial zones and the infrastructure of modern cities, the emergence of fully automated enterprises and services that are controlled by cyber-physical systems (CPS) and which provide their services as autonomous agents is highly likely. In this regard, we can also expect the formation of networks of autonomous CPS in order to increase the speed and quality of communication in the process of production and provision of services.\n\nIn order to take full advantage of the possibilities of smart contracts, a scenario of interaction between two autonomous economic agents was chosen. Consider the liability life cycle in the Robonomics network:\n\n![Liability Life Cycle](./images/testing-neon-with-robonomics/step-by-step-3.jpg)\n\nThe figure above shows that the Robonomics network provider calls the Lighthouse contract, which in turn calls the [contract factory](https://github.com/airalab/robonomics_contracts/blob/master/contracts/robonomics/Factory.sol) to create the Liability contract. The Liability contract contains data about the transaction, such as the terms of reference, payment for the service, validator address and the deadline.\n\nTo learn more about the possible use cases for Robonomics, check out the Robonomics [R&D](https://wiki.robonomics.network/docs/en/r-and-d-based-on-robonomics-network/#launching-a-drone-under-the-control-of-a-decentralized-computer) page!\n\nTo replicate the entire Robonomics infrastructure on the Neon network, we will implement a robot launch scenario through a Liability contract similar to this [example](https://wiki.robonomics.network/docs/en/kuka/). If the script can be repeated, then all functions will work.\n\n## Deliverables\n\nThe source code for the Robonomics contracts is available [here](https://github.com/airalab/robonomics_contracts).\nThe contracts use many features of the Ethereum VM which includes:\n\n- ERC20 [XRT](https://github.com/airalab/robonomics_contracts/blob/master/contracts/robonomics/XRT.sol) Token\n- [Factory](https://github.com/airalab/robonomics_contracts/blob/master/contracts/robonomics/Factory.sol)\n- Own contract for [ENS](https://github.com/airalab/robonomics_contracts/blob/master/contracts/ens/ENS.sol)\n- [Proxy](https://github.com/airalab/robonomics_contracts/blob/master/contracts/misc/SharedCode.sol) for contracts\n- Various modifiers and roles in contracts\n\nAddresses of contracts in the Neon devnet network https://devnet.neonevm.org\n\n| Contract Name  | Address                                    |\n|----------------|--------------------------------------------|\n| Migrations     | 0x1DC538bE2C8572509a571B150f11aB55E52EF12E |\n| ENS            | 0xa7AEa12F60D0278F01e14DBC7cc459d04d051406 |\n| DutchAuction   | 0xF44F8803548D72Dbc3E28340EFD7b5328aa4F058 |\n| Liability      | 0xA694196351dc1488e3884eCc6b650F0d8D55346a |\n| Lighthouse     | 0x80FB5CC4c396E272b56700E6ffF5DBf4661013A8 |\n| XRT            | 0x3322d7D99cF65Cab5A92073c928b5E9674af3c29 |\n| PublicAmbix    | 0x85c03bE5ccFf11E79a0A776D183eF067590549d1 |\n| Factory        | 0xCFa833bF0D46369D9024f95c9C8dFa1E4a07806C |\n| PublicResolver | 0xAC9E9AA8A4cB524FE87f2b14489F1D6bE68dc46e |\n\n[Source code](https://github.com/Multi-Agent-io/neon-kuka-demo) for the scenario\n\n## Changes Made to Original Contracts\n\nThe contracts are written for Solidity 0.5.0. As such, no changes were required when deploying and using the contracts.\n\n## Testing Workflow\n\nIn general, the test consists of sending corresponding messages from one agent to another.\n\nNext, the Promisor finds a new liability contract in the network and begins to execute it. Upon completion of the work, a message is sent with the result, which is then recorded in the contract.\n\nStep-by-step instructions for launching are in [README.md](https://github.com/Multi-Agent-io/neon-kuka-demo/blob/main/README.md)\n\n## Testing Results in Detail\n\nScreencast of the process\n\nhttps://youtu.be/fYJVF7KrNnI\n\n![Liability](./images/testing-neon-with-robonomics/liability.jpg)\n\nWhen the simulation starts, an offer message is created, and a demand message comes from the Promisee, after which a Liability contract is created using the createLiability function of the Lighthouse contract. With the help of the XRT contract, tokens are transferred from the Promisee’s address to the address of the Liability contract.\n\nAfter a new Liability contract has been discovered on the Neon devnet, the agent starts working. The result of the work (telemetry) is written to a file and sent to IPFS, the hash from the file is saved as a result.\n\nAfter the work is completed, the Liability contract is finalized using the finalizeLiability() function of the Lighthouse contract and the tokens are transferred from the Liability address to the addresses of the Promisor and Validator.\n\nThe successful execution of the simulation showed that all contracts worked correctly and the Neon platform works.\n\n## Neon Platform Drawbacks\n\n### Truffle fails if it doesn't get a response from the network\n\nDuring the process of deploying contracts, it turned out that the proxy does not always return a response on time, which is why Truffle ends with an error:\n\n```\nTypeError: Cannot read properties of null (reading 'from')                                    \n    at Web3InterfaceAdapter.<anonymous> (/usr/lib/node_modules/truffle/build/webpack:/packages\n/interface-adapter/dist/adapter/web3/index.js:71:1)                                           \n    at Generator.next (<anonymous>)                                                           \n    at fulfilled (/usr/lib/node_modules/truffle/build/webpack:/packages/interface-adapter/dist\n/adapter/web3/index.js:5:43)                                                                  \n    at runMicrotasks (<anonymous>)\n    at processTicksAndRejections (node:internal/process/task_queues:96:5)\nTruffle v5.5.23 (core: 5.5.23)\nNode v16.14.0\n```\n\nIt was not possible to find a relationship between the test conditions and the occurrence of an error, but most likely Neon EVM cannot send a transaction receipt, and Truffle cannot process a Null response.\n\nIf we add timeout and retry here [index.ts#L75](https://github.com/trufflesuite/truffle/blob/develop/packages/interface-adapter/lib/adapter/web3/index.ts#L75), then the deployment should proceed without errors.\n\n### No WS/WSS Endpoint\n\nNeon EVM does not have a WS/WSS endpoint unlike Ethereum, which makes it impossible to subscribe to events from the network. Therefore, during testing, we monitored the events manually.\n\n### No Event Names\n\nNeon EVM returns rather poor descriptions of events after a transaction, for example:\n\n```\n events: {\n    '0': {\n      address: '0xCFa833bF0D46369D9024f95c9C8dFa1E4a07806C',\n      transactionHash: '0x9894a984e6b3f6ce469c8837e11739f6e50d00216cf7c5bc3d32da106a58d50a',\n      transactionLogIndex: '0x1',\n      blockHash: '0x72040f317d3a469d30327d4e1def903790b70dbede46b4f0ea4f28f30a679a80',\n      blockNumber: 156073183,\n      transactionIndex: 0,\n      logIndex: 1,\n      id: 'log_e51e2f9f',\n      returnValues: Result {},\n      event: undefined,\n      signature: null,\n      raw: [Object]\n    },\n...\n```\n\nInstead of 0, 1, etc. we expected to see named events.\n\n## Conclusion\n\nUsing the Neon EVM platform, a scenario was successfully tested whereby a liability contract between a Promisee and a Promisor is concluded with subsequent validation of the result of the work done by a third party. Additionally, a Provider participated, who checked the coincidence of supply and demand between the parties, and received a commission for this work.\n\nThe demonstration used a simulation of a robotic arm that was hired to perform a sequence of actions. As a result of the work, the robot sent a file with telemetry received during the task.\n\nDespite some peculiarities in the operation of the network, in the end, all participating contracts showed their operability in the Neon environment.\n\n\n\n","cover_image":{"type":"image","mimeType":"image/jpeg","src":"/assets/static/blog_cover_neon_multi-agent.62c183a.6231caf624da0ea84dd55d0582533702.jpg","size":{"width":1500,"height":675},"sizes":"(max-width: 1500px) 100vw, 1500px","srcset":["/assets/static/blog_cover_neon_multi-agent.9ea8d39.6231caf624da0ea84dd55d0582533702.jpg 480w","/assets/static/blog_cover_neon_multi-agent.6b2ed88.6231caf624da0ea84dd55d0582533702.jpg 1024w","/assets/static/blog_cover_neon_multi-agent.62c183a.6231caf624da0ea84dd55d0582533702.jpg 1500w"],"dataUri":"data:image/svg+xml,%3csvg fill='none' viewBox='0 0 1500 675' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'%3e%3cdefs%3e%3cfilter id='__svg-blur-6955165ddd4a470810755efcfe6cef5d'%3e%3cfeGaussianBlur in='SourceGraphic' stdDeviation='40'/%3e%3c/filter%3e%3c/defs%3e%3cimage x='0' y='0' filter='url(%23__svg-blur-6955165ddd4a470810755efcfe6cef5d)' width='1500' height='675' xlink:href='data:image/jpeg%3bbase64%2c/9j/2wBDAAYEBQYFBAYGBQYHBwYIChAKCgkJChQODwwQFxQYGBcUFhYaHSUfGhsjHBYWICwgIyYnKSopGR8tMC0oMCUoKSj/2wBDAQcHBwoIChMKChMoGhYaKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCj/wAARCAAdAEADASIAAhEBAxEB/8QAHAAAAQQDAQAAAAAAAAAAAAAABQIDBAYAAQcI/8QAJxAAAgIBAwQCAgMBAAAAAAAAAQIDEQQABTESEyFBBiJRsTJxgfD/xAAYAQADAQEAAAAAAAAAAAAAAAABAgMABP/EAB0RAAIDAAMBAQAAAAAAAAAAAAECAAMREiExQXH/2gAMAwEAAhEDEQA/APL6xdUDSdX8TVUf3/mmtb62CFQfqfWr/wDKvgMOxxZDR7gJ6EUkRJC0kjKv3HqiSLHjj%2btddVD2glB4NMtVRZaGZRoHc5/p7DiWadY26z1EABF6mJPAA1dF%2bARSQ96L5FtckZkKKik9xqu6W%2bbBoX5Au/WgW%2b7OuyZMKQbhiZ7Pas0B%2bqsKuieR9hTe/P41EEbItpHUCyhVkIQkr6sUdZ2ZfrUbnqXqFC7H51JxExp5HOVM0THwqqtgn%2b/Wuhr8Y7ewyjGDGWAMsUwnKO63bMAFocGlJPHIsWDMPJzF0aM06sp/DCtOTRdtEbqvqF8Ef9xolv8AtuVgSMNwmeTJ7hWyxYFfPmzzehTyM4AY2BxoiY7E6l5ORlZMQlycuabx26kkZiBzXn17rUTSu43b6L%2bvNaIOdQ63gMT/AINWX4JtsGZuGXl56scDb8WTImK0DYWlAv2T%2btVrVr2N0HwbfAYlMgdemSyCtgA%2b64/Oo2ozoVT0ytLIjhn8EGb1LsuRDDNtkOVjZMtmeFyGjiI9IeSDz5quPOimF8rnkx5cWeFCsg6mAmkRZGAFkgMALCiwKBrVT1mmROAzd/YjtzPIybumTkZ8pzcuVXllJJparzZ/eoWltIzIqE/UcDSNPEG/Z//Z' /%3e%3c/svg%3e"},"locale":"en"}},{"node":{"title":"Testing Neon EVM with Robonomics Smart Contracts","path":"/blog/az/testing-neon-with-robonomics/","date":"October 3, 2022","description":"The purpose of these tests were to validate the readiness of the Neon platform to move to the production stage using Robonomics smart contracts, which allow cyber-physical systems (robots) to make technical-economic transactions.","content":"\n## TL;DR\n\nThe purpose of these tests were to validate the readiness of the [Neon](https://neon-labs.org/) platform to move to the production stage using Robonomics smart contracts, which allow cyber-physical systems (robots) to make technical-economic transactions.\n\nIn the Robonomics network, interaction is established between two parties: Promisee - the one who orders the service, sends a description of technical task and transfers funds for its execution; Promisor - one who performs a service. A typical scenario was tested, whereby a liability contract is concluded between a Promisee and a Promisor - this was followed by validation of the resulting work by a third party, and a commission payment to the node that accompanied the contract between the parties.\n\nFor this example, a simulation of a robotic arm was used, which was asked to perform a sequence of actions. The tests were successful.\n\n## Scope and Goals of Testing\n\nEngineers of [Multi-Agent Systems](https://multi-agent.io/) have been working with [Robonomics Network](https://robonomics.network/) for several years. The first implementation of the Robonomics Network was created for the Ethereum network. It is a set of smart contracts for machine-to-machine communication.\n\nThe core of the Robonomics Network is the [Liability](https://github.com/airalab/robonomics_contracts/blob/master/contracts/robonomics/Liability.sol) contract, a smart contract that reproduces the typical relationship between the customer of a service (Promisee) and the service provider (Promisor), and includes the technical and economic parameters of the transaction between them. The parties can be either an autonomous agent and a person (human-to-machine interaction), or purely two autonomous agents (machine-to-machine interaction). The Promisee and Promisor broadcast messages with the parameters of their technical-economic transaction, and then the conclusion of the transaction is provided by a special node - the Provider - which looks for matches of these parameters. Providers are controlled by [Lighthouse](https://github.com/airalab/robonomics_contracts/blob/master/contracts/robonomics/Lighthouse.sol), which is a special smart contract that executes a transaction when the provider establishes a market match between the parties.\n\nThere are three scenarios in which the fulfillment of an obligation can take place:\n\n1. A simple commitment (with no verification of the final result, and no commission paid to Provider nodes)\n2. Obligation with a commission paid to the Provider\n3. Commitment with a commission to the Provider and validation of the results with the help of a third party - observing network.\n\nThe purpose of this test is to test the most complex, third Robonomics scenario on the Neon EVM platform.\n\n## Testing Scenarios Description\n\nAs we develop the industrial zones and the infrastructure of modern cities, the emergence of fully automated enterprises and services that are controlled by cyber-physical systems (CPS) and which provide their services as autonomous agents is highly likely. In this regard, we can also expect the formation of networks of autonomous CPS in order to increase the speed and quality of communication in the process of production and provision of services.\n\nIn order to take full advantage of the possibilities of smart contracts, a scenario of interaction between two autonomous economic agents was chosen. Consider the liability life cycle in the Robonomics network:\n\n![Liability Life Cycle](./images/testing-neon-with-robonomics/step-by-step-3.jpg)\n\nThe figure above shows that the Robonomics network provider calls the Lighthouse contract, which in turn calls the [contract factory](https://github.com/airalab/robonomics_contracts/blob/master/contracts/robonomics/Factory.sol) to create the Liability contract. The Liability contract contains data about the transaction, such as the terms of reference, payment for the service, validator address and the deadline.\n\nTo learn more about the possible use cases for Robonomics, check out the Robonomics [R&D](https://wiki.robonomics.network/docs/en/r-and-d-based-on-robonomics-network/#launching-a-drone-under-the-control-of-a-decentralized-computer) page!\n\nTo replicate the entire Robonomics infrastructure on the Neon network, we will implement a robot launch scenario through a Liability contract similar to this [example](https://wiki.robonomics.network/docs/en/kuka/). If the script can be repeated, then all functions will work.\n\n## Deliverables\n\nThe source code for the Robonomics contracts is available [here](https://github.com/airalab/robonomics_contracts).\nThe contracts use many features of the Ethereum VM which includes:\n\n- ERC20 [XRT](https://github.com/airalab/robonomics_contracts/blob/master/contracts/robonomics/XRT.sol) Token\n- [Factory](https://github.com/airalab/robonomics_contracts/blob/master/contracts/robonomics/Factory.sol)\n- Own contract for [ENS](https://github.com/airalab/robonomics_contracts/blob/master/contracts/ens/ENS.sol)\n- [Proxy](https://github.com/airalab/robonomics_contracts/blob/master/contracts/misc/SharedCode.sol) for contracts\n- Various modifiers and roles in contracts\n\nAddresses of contracts in the Neon devnet network https://devnet.neonevm.org\n\n| Contract Name  | Address                                    |\n|----------------|--------------------------------------------|\n| Migrations     | 0x1DC538bE2C8572509a571B150f11aB55E52EF12E |\n| ENS            | 0xa7AEa12F60D0278F01e14DBC7cc459d04d051406 |\n| DutchAuction   | 0xF44F8803548D72Dbc3E28340EFD7b5328aa4F058 |\n| Liability      | 0xA694196351dc1488e3884eCc6b650F0d8D55346a |\n| Lighthouse     | 0x80FB5CC4c396E272b56700E6ffF5DBf4661013A8 |\n| XRT            | 0x3322d7D99cF65Cab5A92073c928b5E9674af3c29 |\n| PublicAmbix    | 0x85c03bE5ccFf11E79a0A776D183eF067590549d1 |\n| Factory        | 0xCFa833bF0D46369D9024f95c9C8dFa1E4a07806C |\n| PublicResolver | 0xAC9E9AA8A4cB524FE87f2b14489F1D6bE68dc46e |\n\n[Source code](https://github.com/Multi-Agent-io/neon-kuka-demo) for the scenario\n\n## Changes Made to Original Contracts\n\nThe contracts are written for Solidity 0.5.0. As such, no changes were required when deploying and using the contracts.\n\n## Testing Workflow\n\nIn general, the test consists of sending corresponding messages from one agent to another.\n\nNext, the Promisor finds a new liability contract in the network and begins to execute it. Upon completion of the work, a message is sent with the result, which is then recorded in the contract.\n\nStep-by-step instructions for launching are in [README.md](https://github.com/Multi-Agent-io/neon-kuka-demo/blob/main/README.md)\n\n## Testing Results in Detail\n\nScreencast of the process\n\nhttps://youtu.be/fYJVF7KrNnI\n\n![Liability](./images/testing-neon-with-robonomics/liability.jpg)\n\nWhen the simulation starts, an offer message is created, and a demand message comes from the Promisee, after which a Liability contract is created using the createLiability function of the Lighthouse contract. With the help of the XRT contract, tokens are transferred from the Promisee’s address to the address of the Liability contract.\n\nAfter a new Liability contract has been discovered on the Neon devnet, the agent starts working. The result of the work (telemetry) is written to a file and sent to IPFS, the hash from the file is saved as a result.\n\nAfter the work is completed, the Liability contract is finalized using the finalizeLiability() function of the Lighthouse contract and the tokens are transferred from the Liability address to the addresses of the Promisor and Validator.\n\nThe successful execution of the simulation showed that all contracts worked correctly and the Neon platform works.\n\n## Neon Platform Drawbacks\n\n### Truffle fails if it doesn't get a response from the network\n\nDuring the process of deploying contracts, it turned out that the proxy does not always return a response on time, which is why Truffle ends with an error:\n\n```\nTypeError: Cannot read properties of null (reading 'from')                                    \n    at Web3InterfaceAdapter.<anonymous> (/usr/lib/node_modules/truffle/build/webpack:/packages\n/interface-adapter/dist/adapter/web3/index.js:71:1)                                           \n    at Generator.next (<anonymous>)                                                           \n    at fulfilled (/usr/lib/node_modules/truffle/build/webpack:/packages/interface-adapter/dist\n/adapter/web3/index.js:5:43)                                                                  \n    at runMicrotasks (<anonymous>)\n    at processTicksAndRejections (node:internal/process/task_queues:96:5)\nTruffle v5.5.23 (core: 5.5.23)\nNode v16.14.0\n```\n\nIt was not possible to find a relationship between the test conditions and the occurrence of an error, but most likely Neon EVM cannot send a transaction receipt, and Truffle cannot process a Null response.\n\nIf we add timeout and retry here [index.ts#L75](https://github.com/trufflesuite/truffle/blob/develop/packages/interface-adapter/lib/adapter/web3/index.ts#L75), then the deployment should proceed without errors.\n\n### No WS/WSS Endpoint\n\nNeon EVM does not have a WS/WSS endpoint unlike Ethereum, which makes it impossible to subscribe to events from the network. Therefore, during testing, we monitored the events manually.\n\n### No Event Names\n\nNeon EVM returns rather poor descriptions of events after a transaction, for example:\n\n```\n events: {\n    '0': {\n      address: '0xCFa833bF0D46369D9024f95c9C8dFa1E4a07806C',\n      transactionHash: '0x9894a984e6b3f6ce469c8837e11739f6e50d00216cf7c5bc3d32da106a58d50a',\n      transactionLogIndex: '0x1',\n      blockHash: '0x72040f317d3a469d30327d4e1def903790b70dbede46b4f0ea4f28f30a679a80',\n      blockNumber: 156073183,\n      transactionIndex: 0,\n      logIndex: 1,\n      id: 'log_e51e2f9f',\n      returnValues: Result {},\n      event: undefined,\n      signature: null,\n      raw: [Object]\n    },\n...\n```\n\nInstead of 0, 1, etc. we expected to see named events.\n\n## Conclusion\n\nUsing the Neon EVM platform, a scenario was successfully tested whereby a liability contract between a Promisee and a Promisor is concluded with subsequent validation of the result of the work done by a third party. Additionally, a Provider participated, who checked the coincidence of supply and demand between the parties, and received a commission for this work.\n\nThe demonstration used a simulation of a robotic arm that was hired to perform a sequence of actions. As a result of the work, the robot sent a file with telemetry received during the task.\n\nDespite some peculiarities in the operation of the network, in the end, all participating contracts showed their operability in the Neon environment.\n\n\n\n","cover_image":{"type":"image","mimeType":"image/jpeg","src":"/assets/static/blog_cover_neon_multi-agent.62c183a.6231caf624da0ea84dd55d0582533702.jpg","size":{"width":1500,"height":675},"sizes":"(max-width: 1500px) 100vw, 1500px","srcset":["/assets/static/blog_cover_neon_multi-agent.9ea8d39.6231caf624da0ea84dd55d0582533702.jpg 480w","/assets/static/blog_cover_neon_multi-agent.6b2ed88.6231caf624da0ea84dd55d0582533702.jpg 1024w","/assets/static/blog_cover_neon_multi-agent.62c183a.6231caf624da0ea84dd55d0582533702.jpg 1500w"],"dataUri":"data:image/svg+xml,%3csvg fill='none' viewBox='0 0 1500 675' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'%3e%3cdefs%3e%3cfilter id='__svg-blur-6955165ddd4a470810755efcfe6cef5d'%3e%3cfeGaussianBlur in='SourceGraphic' stdDeviation='40'/%3e%3c/filter%3e%3c/defs%3e%3cimage x='0' y='0' filter='url(%23__svg-blur-6955165ddd4a470810755efcfe6cef5d)' width='1500' height='675' xlink:href='data:image/jpeg%3bbase64%2c/9j/2wBDAAYEBQYFBAYGBQYHBwYIChAKCgkJChQODwwQFxQYGBcUFhYaHSUfGhsjHBYWICwgIyYnKSopGR8tMC0oMCUoKSj/2wBDAQcHBwoIChMKChMoGhYaKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCj/wAARCAAdAEADASIAAhEBAxEB/8QAHAAAAQQDAQAAAAAAAAAAAAAABQIDBAYAAQcI/8QAJxAAAgIBAwQCAgMBAAAAAAAAAQIDEQQABTESEyFBBiJRsTJxgfD/xAAYAQADAQEAAAAAAAAAAAAAAAABAgMABP/EAB0RAAIDAAMBAQAAAAAAAAAAAAECAAMREiExQXH/2gAMAwEAAhEDEQA/APL6xdUDSdX8TVUf3/mmtb62CFQfqfWr/wDKvgMOxxZDR7gJ6EUkRJC0kjKv3HqiSLHjj%2btddVD2glB4NMtVRZaGZRoHc5/p7DiWadY26z1EABF6mJPAA1dF%2bARSQ96L5FtckZkKKik9xqu6W%2bbBoX5Au/WgW%2b7OuyZMKQbhiZ7Pas0B%2bqsKuieR9hTe/P41EEbItpHUCyhVkIQkr6sUdZ2ZfrUbnqXqFC7H51JxExp5HOVM0THwqqtgn%2b/Wuhr8Y7ewyjGDGWAMsUwnKO63bMAFocGlJPHIsWDMPJzF0aM06sp/DCtOTRdtEbqvqF8Ef9xolv8AtuVgSMNwmeTJ7hWyxYFfPmzzehTyM4AY2BxoiY7E6l5ORlZMQlycuabx26kkZiBzXn17rUTSu43b6L%2bvNaIOdQ63gMT/AINWX4JtsGZuGXl56scDb8WTImK0DYWlAv2T%2btVrVr2N0HwbfAYlMgdemSyCtgA%2b64/Oo2ozoVT0ytLIjhn8EGb1LsuRDDNtkOVjZMtmeFyGjiI9IeSDz5quPOimF8rnkx5cWeFCsg6mAmkRZGAFkgMALCiwKBrVT1mmROAzd/YjtzPIybumTkZ8pzcuVXllJJparzZ/eoWltIzIqE/UcDSNPEG/Z//Z' /%3e%3c/svg%3e"},"locale":"az"}},{"node":{"title":"Testing Neon EVM with Robonomics Smart Contracts","path":"/blog/de/testing-neon-with-robonomics/","date":"October 3, 2022","description":"The purpose of these tests were to validate the readiness of the Neon platform to move to the production stage using Robonomics smart contracts, which allow cyber-physical systems (robots) to make technical-economic transactions.","content":"\n## TL;DR\n\nThe purpose of these tests were to validate the readiness of the [Neon](https://neon-labs.org/) platform to move to the production stage using Robonomics smart contracts, which allow cyber-physical systems (robots) to make technical-economic transactions.\n\nIn the Robonomics network, interaction is established between two parties: Promisee - the one who orders the service, sends a description of technical task and transfers funds for its execution; Promisor - one who performs a service. A typical scenario was tested, whereby a liability contract is concluded between a Promisee and a Promisor - this was followed by validation of the resulting work by a third party, and a commission payment to the node that accompanied the contract between the parties.\n\nFor this example, a simulation of a robotic arm was used, which was asked to perform a sequence of actions. The tests were successful.\n\n## Scope and Goals of Testing\n\nEngineers of [Multi-Agent Systems](https://multi-agent.io/) have been working with [Robonomics Network](https://robonomics.network/) for several years. The first implementation of the Robonomics Network was created for the Ethereum network. It is a set of smart contracts for machine-to-machine communication.\n\nThe core of the Robonomics Network is the [Liability](https://github.com/airalab/robonomics_contracts/blob/master/contracts/robonomics/Liability.sol) contract, a smart contract that reproduces the typical relationship between the customer of a service (Promisee) and the service provider (Promisor), and includes the technical and economic parameters of the transaction between them. The parties can be either an autonomous agent and a person (human-to-machine interaction), or purely two autonomous agents (machine-to-machine interaction). The Promisee and Promisor broadcast messages with the parameters of their technical-economic transaction, and then the conclusion of the transaction is provided by a special node - the Provider - which looks for matches of these parameters. Providers are controlled by [Lighthouse](https://github.com/airalab/robonomics_contracts/blob/master/contracts/robonomics/Lighthouse.sol), which is a special smart contract that executes a transaction when the provider establishes a market match between the parties.\n\nThere are three scenarios in which the fulfillment of an obligation can take place:\n\n1. A simple commitment (with no verification of the final result, and no commission paid to Provider nodes)\n2. Obligation with a commission paid to the Provider\n3. Commitment with a commission to the Provider and validation of the results with the help of a third party - observing network.\n\nThe purpose of this test is to test the most complex, third Robonomics scenario on the Neon EVM platform.\n\n## Testing Scenarios Description\n\nAs we develop the industrial zones and the infrastructure of modern cities, the emergence of fully automated enterprises and services that are controlled by cyber-physical systems (CPS) and which provide their services as autonomous agents is highly likely. In this regard, we can also expect the formation of networks of autonomous CPS in order to increase the speed and quality of communication in the process of production and provision of services.\n\nIn order to take full advantage of the possibilities of smart contracts, a scenario of interaction between two autonomous economic agents was chosen. Consider the liability life cycle in the Robonomics network:\n\n![Liability Life Cycle](./images/testing-neon-with-robonomics/step-by-step-3.jpg)\n\nThe figure above shows that the Robonomics network provider calls the Lighthouse contract, which in turn calls the [contract factory](https://github.com/airalab/robonomics_contracts/blob/master/contracts/robonomics/Factory.sol) to create the Liability contract. The Liability contract contains data about the transaction, such as the terms of reference, payment for the service, validator address and the deadline.\n\nTo learn more about the possible use cases for Robonomics, check out the Robonomics [R&D](https://wiki.robonomics.network/docs/en/r-and-d-based-on-robonomics-network/#launching-a-drone-under-the-control-of-a-decentralized-computer) page!\n\nTo replicate the entire Robonomics infrastructure on the Neon network, we will implement a robot launch scenario through a Liability contract similar to this [example](https://wiki.robonomics.network/docs/en/kuka/). If the script can be repeated, then all functions will work.\n\n## Deliverables\n\nThe source code for the Robonomics contracts is available [here](https://github.com/airalab/robonomics_contracts).\nThe contracts use many features of the Ethereum VM which includes:\n\n- ERC20 [XRT](https://github.com/airalab/robonomics_contracts/blob/master/contracts/robonomics/XRT.sol) Token\n- [Factory](https://github.com/airalab/robonomics_contracts/blob/master/contracts/robonomics/Factory.sol)\n- Own contract for [ENS](https://github.com/airalab/robonomics_contracts/blob/master/contracts/ens/ENS.sol)\n- [Proxy](https://github.com/airalab/robonomics_contracts/blob/master/contracts/misc/SharedCode.sol) for contracts\n- Various modifiers and roles in contracts\n\nAddresses of contracts in the Neon devnet network https://devnet.neonevm.org\n\n| Contract Name  | Address                                    |\n|----------------|--------------------------------------------|\n| Migrations     | 0x1DC538bE2C8572509a571B150f11aB55E52EF12E |\n| ENS            | 0xa7AEa12F60D0278F01e14DBC7cc459d04d051406 |\n| DutchAuction   | 0xF44F8803548D72Dbc3E28340EFD7b5328aa4F058 |\n| Liability      | 0xA694196351dc1488e3884eCc6b650F0d8D55346a |\n| Lighthouse     | 0x80FB5CC4c396E272b56700E6ffF5DBf4661013A8 |\n| XRT            | 0x3322d7D99cF65Cab5A92073c928b5E9674af3c29 |\n| PublicAmbix    | 0x85c03bE5ccFf11E79a0A776D183eF067590549d1 |\n| Factory        | 0xCFa833bF0D46369D9024f95c9C8dFa1E4a07806C |\n| PublicResolver | 0xAC9E9AA8A4cB524FE87f2b14489F1D6bE68dc46e |\n\n[Source code](https://github.com/Multi-Agent-io/neon-kuka-demo) for the scenario\n\n## Changes Made to Original Contracts\n\nThe contracts are written for Solidity 0.5.0. As such, no changes were required when deploying and using the contracts.\n\n## Testing Workflow\n\nIn general, the test consists of sending corresponding messages from one agent to another.\n\nNext, the Promisor finds a new liability contract in the network and begins to execute it. Upon completion of the work, a message is sent with the result, which is then recorded in the contract.\n\nStep-by-step instructions for launching are in [README.md](https://github.com/Multi-Agent-io/neon-kuka-demo/blob/main/README.md)\n\n## Testing Results in Detail\n\nScreencast of the process\n\nhttps://youtu.be/fYJVF7KrNnI\n\n![Liability](./images/testing-neon-with-robonomics/liability.jpg)\n\nWhen the simulation starts, an offer message is created, and a demand message comes from the Promisee, after which a Liability contract is created using the createLiability function of the Lighthouse contract. With the help of the XRT contract, tokens are transferred from the Promisee’s address to the address of the Liability contract.\n\nAfter a new Liability contract has been discovered on the Neon devnet, the agent starts working. The result of the work (telemetry) is written to a file and sent to IPFS, the hash from the file is saved as a result.\n\nAfter the work is completed, the Liability contract is finalized using the finalizeLiability() function of the Lighthouse contract and the tokens are transferred from the Liability address to the addresses of the Promisor and Validator.\n\nThe successful execution of the simulation showed that all contracts worked correctly and the Neon platform works.\n\n## Neon Platform Drawbacks\n\n### Truffle fails if it doesn't get a response from the network\n\nDuring the process of deploying contracts, it turned out that the proxy does not always return a response on time, which is why Truffle ends with an error:\n\n```\nTypeError: Cannot read properties of null (reading 'from')                                    \n    at Web3InterfaceAdapter.<anonymous> (/usr/lib/node_modules/truffle/build/webpack:/packages\n/interface-adapter/dist/adapter/web3/index.js:71:1)                                           \n    at Generator.next (<anonymous>)                                                           \n    at fulfilled (/usr/lib/node_modules/truffle/build/webpack:/packages/interface-adapter/dist\n/adapter/web3/index.js:5:43)                                                                  \n    at runMicrotasks (<anonymous>)\n    at processTicksAndRejections (node:internal/process/task_queues:96:5)\nTruffle v5.5.23 (core: 5.5.23)\nNode v16.14.0\n```\n\nIt was not possible to find a relationship between the test conditions and the occurrence of an error, but most likely Neon EVM cannot send a transaction receipt, and Truffle cannot process a Null response.\n\nIf we add timeout and retry here [index.ts#L75](https://github.com/trufflesuite/truffle/blob/develop/packages/interface-adapter/lib/adapter/web3/index.ts#L75), then the deployment should proceed without errors.\n\n### No WS/WSS Endpoint\n\nNeon EVM does not have a WS/WSS endpoint unlike Ethereum, which makes it impossible to subscribe to events from the network. Therefore, during testing, we monitored the events manually.\n\n### No Event Names\n\nNeon EVM returns rather poor descriptions of events after a transaction, for example:\n\n```\n events: {\n    '0': {\n      address: '0xCFa833bF0D46369D9024f95c9C8dFa1E4a07806C',\n      transactionHash: '0x9894a984e6b3f6ce469c8837e11739f6e50d00216cf7c5bc3d32da106a58d50a',\n      transactionLogIndex: '0x1',\n      blockHash: '0x72040f317d3a469d30327d4e1def903790b70dbede46b4f0ea4f28f30a679a80',\n      blockNumber: 156073183,\n      transactionIndex: 0,\n      logIndex: 1,\n      id: 'log_e51e2f9f',\n      returnValues: Result {},\n      event: undefined,\n      signature: null,\n      raw: [Object]\n    },\n...\n```\n\nInstead of 0, 1, etc. we expected to see named events.\n\n## Conclusion\n\nUsing the Neon EVM platform, a scenario was successfully tested whereby a liability contract between a Promisee and a Promisor is concluded with subsequent validation of the result of the work done by a third party. Additionally, a Provider participated, who checked the coincidence of supply and demand between the parties, and received a commission for this work.\n\nThe demonstration used a simulation of a robotic arm that was hired to perform a sequence of actions. As a result of the work, the robot sent a file with telemetry received during the task.\n\nDespite some peculiarities in the operation of the network, in the end, all participating contracts showed their operability in the Neon environment.\n\n\n\n","cover_image":{"type":"image","mimeType":"image/jpeg","src":"/assets/static/blog_cover_neon_multi-agent.62c183a.6231caf624da0ea84dd55d0582533702.jpg","size":{"width":1500,"height":675},"sizes":"(max-width: 1500px) 100vw, 1500px","srcset":["/assets/static/blog_cover_neon_multi-agent.9ea8d39.6231caf624da0ea84dd55d0582533702.jpg 480w","/assets/static/blog_cover_neon_multi-agent.6b2ed88.6231caf624da0ea84dd55d0582533702.jpg 1024w","/assets/static/blog_cover_neon_multi-agent.62c183a.6231caf624da0ea84dd55d0582533702.jpg 1500w"],"dataUri":"data:image/svg+xml,%3csvg fill='none' viewBox='0 0 1500 675' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'%3e%3cdefs%3e%3cfilter id='__svg-blur-6955165ddd4a470810755efcfe6cef5d'%3e%3cfeGaussianBlur in='SourceGraphic' stdDeviation='40'/%3e%3c/filter%3e%3c/defs%3e%3cimage x='0' y='0' filter='url(%23__svg-blur-6955165ddd4a470810755efcfe6cef5d)' width='1500' height='675' xlink:href='data:image/jpeg%3bbase64%2c/9j/2wBDAAYEBQYFBAYGBQYHBwYIChAKCgkJChQODwwQFxQYGBcUFhYaHSUfGhsjHBYWICwgIyYnKSopGR8tMC0oMCUoKSj/2wBDAQcHBwoIChMKChMoGhYaKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCj/wAARCAAdAEADASIAAhEBAxEB/8QAHAAAAQQDAQAAAAAAAAAAAAAABQIDBAYAAQcI/8QAJxAAAgIBAwQCAgMBAAAAAAAAAQIDEQQABTESEyFBBiJRsTJxgfD/xAAYAQADAQEAAAAAAAAAAAAAAAABAgMABP/EAB0RAAIDAAMBAQAAAAAAAAAAAAECAAMREiExQXH/2gAMAwEAAhEDEQA/APL6xdUDSdX8TVUf3/mmtb62CFQfqfWr/wDKvgMOxxZDR7gJ6EUkRJC0kjKv3HqiSLHjj%2btddVD2glB4NMtVRZaGZRoHc5/p7DiWadY26z1EABF6mJPAA1dF%2bARSQ96L5FtckZkKKik9xqu6W%2bbBoX5Au/WgW%2b7OuyZMKQbhiZ7Pas0B%2bqsKuieR9hTe/P41EEbItpHUCyhVkIQkr6sUdZ2ZfrUbnqXqFC7H51JxExp5HOVM0THwqqtgn%2b/Wuhr8Y7ewyjGDGWAMsUwnKO63bMAFocGlJPHIsWDMPJzF0aM06sp/DCtOTRdtEbqvqF8Ef9xolv8AtuVgSMNwmeTJ7hWyxYFfPmzzehTyM4AY2BxoiY7E6l5ORlZMQlycuabx26kkZiBzXn17rUTSu43b6L%2bvNaIOdQ63gMT/AINWX4JtsGZuGXl56scDb8WTImK0DYWlAv2T%2btVrVr2N0HwbfAYlMgdemSyCtgA%2b64/Oo2ozoVT0ytLIjhn8EGb1LsuRDDNtkOVjZMtmeFyGjiI9IeSDz5quPOimF8rnkx5cWeFCsg6mAmkRZGAFkgMALCiwKBrVT1mmROAzd/YjtzPIybumTkZ8pzcuVXllJJparzZ/eoWltIzIqE/UcDSNPEG/Z//Z' /%3e%3c/svg%3e"},"locale":"de"}},{"node":{"title":"Testing Neon EVM with Robonomics Smart Contracts","path":"/blog/es/testing-neon-with-robonomics/","date":"October 3, 2022","description":"The purpose of these tests were to validate the readiness of the Neon platform to move to the production stage using Robonomics smart contracts, which allow cyber-physical systems (robots) to make technical-economic transactions.","content":"\n## TL;DR\n\nThe purpose of these tests were to validate the readiness of the [Neon](https://neon-labs.org/) platform to move to the production stage using Robonomics smart contracts, which allow cyber-physical systems (robots) to make technical-economic transactions.\n\nIn the Robonomics network, interaction is established between two parties: Promisee - the one who orders the service, sends a description of technical task and transfers funds for its execution; Promisor - one who performs a service. A typical scenario was tested, whereby a liability contract is concluded between a Promisee and a Promisor - this was followed by validation of the resulting work by a third party, and a commission payment to the node that accompanied the contract between the parties.\n\nFor this example, a simulation of a robotic arm was used, which was asked to perform a sequence of actions. The tests were successful.\n\n## Scope and Goals of Testing\n\nEngineers of [Multi-Agent Systems](https://multi-agent.io/) have been working with [Robonomics Network](https://robonomics.network/) for several years. The first implementation of the Robonomics Network was created for the Ethereum network. It is a set of smart contracts for machine-to-machine communication.\n\nThe core of the Robonomics Network is the [Liability](https://github.com/airalab/robonomics_contracts/blob/master/contracts/robonomics/Liability.sol) contract, a smart contract that reproduces the typical relationship between the customer of a service (Promisee) and the service provider (Promisor), and includes the technical and economic parameters of the transaction between them. The parties can be either an autonomous agent and a person (human-to-machine interaction), or purely two autonomous agents (machine-to-machine interaction). The Promisee and Promisor broadcast messages with the parameters of their technical-economic transaction, and then the conclusion of the transaction is provided by a special node - the Provider - which looks for matches of these parameters. Providers are controlled by [Lighthouse](https://github.com/airalab/robonomics_contracts/blob/master/contracts/robonomics/Lighthouse.sol), which is a special smart contract that executes a transaction when the provider establishes a market match between the parties.\n\nThere are three scenarios in which the fulfillment of an obligation can take place:\n\n1. A simple commitment (with no verification of the final result, and no commission paid to Provider nodes)\n2. Obligation with a commission paid to the Provider\n3. Commitment with a commission to the Provider and validation of the results with the help of a third party - observing network.\n\nThe purpose of this test is to test the most complex, third Robonomics scenario on the Neon EVM platform.\n\n## Testing Scenarios Description\n\nAs we develop the industrial zones and the infrastructure of modern cities, the emergence of fully automated enterprises and services that are controlled by cyber-physical systems (CPS) and which provide their services as autonomous agents is highly likely. In this regard, we can also expect the formation of networks of autonomous CPS in order to increase the speed and quality of communication in the process of production and provision of services.\n\nIn order to take full advantage of the possibilities of smart contracts, a scenario of interaction between two autonomous economic agents was chosen. Consider the liability life cycle in the Robonomics network:\n\n![Liability Life Cycle](./images/testing-neon-with-robonomics/step-by-step-3.jpg)\n\nThe figure above shows that the Robonomics network provider calls the Lighthouse contract, which in turn calls the [contract factory](https://github.com/airalab/robonomics_contracts/blob/master/contracts/robonomics/Factory.sol) to create the Liability contract. The Liability contract contains data about the transaction, such as the terms of reference, payment for the service, validator address and the deadline.\n\nTo learn more about the possible use cases for Robonomics, check out the Robonomics [R&D](https://wiki.robonomics.network/docs/en/r-and-d-based-on-robonomics-network/#launching-a-drone-under-the-control-of-a-decentralized-computer) page!\n\nTo replicate the entire Robonomics infrastructure on the Neon network, we will implement a robot launch scenario through a Liability contract similar to this [example](https://wiki.robonomics.network/docs/en/kuka/). If the script can be repeated, then all functions will work.\n\n## Deliverables\n\nThe source code for the Robonomics contracts is available [here](https://github.com/airalab/robonomics_contracts).\nThe contracts use many features of the Ethereum VM which includes:\n\n- ERC20 [XRT](https://github.com/airalab/robonomics_contracts/blob/master/contracts/robonomics/XRT.sol) Token\n- [Factory](https://github.com/airalab/robonomics_contracts/blob/master/contracts/robonomics/Factory.sol)\n- Own contract for [ENS](https://github.com/airalab/robonomics_contracts/blob/master/contracts/ens/ENS.sol)\n- [Proxy](https://github.com/airalab/robonomics_contracts/blob/master/contracts/misc/SharedCode.sol) for contracts\n- Various modifiers and roles in contracts\n\nAddresses of contracts in the Neon devnet network https://devnet.neonevm.org\n\n| Contract Name  | Address                                    |\n|----------------|--------------------------------------------|\n| Migrations     | 0x1DC538bE2C8572509a571B150f11aB55E52EF12E |\n| ENS            | 0xa7AEa12F60D0278F01e14DBC7cc459d04d051406 |\n| DutchAuction   | 0xF44F8803548D72Dbc3E28340EFD7b5328aa4F058 |\n| Liability      | 0xA694196351dc1488e3884eCc6b650F0d8D55346a |\n| Lighthouse     | 0x80FB5CC4c396E272b56700E6ffF5DBf4661013A8 |\n| XRT            | 0x3322d7D99cF65Cab5A92073c928b5E9674af3c29 |\n| PublicAmbix    | 0x85c03bE5ccFf11E79a0A776D183eF067590549d1 |\n| Factory        | 0xCFa833bF0D46369D9024f95c9C8dFa1E4a07806C |\n| PublicResolver | 0xAC9E9AA8A4cB524FE87f2b14489F1D6bE68dc46e |\n\n[Source code](https://github.com/Multi-Agent-io/neon-kuka-demo) for the scenario\n\n## Changes Made to Original Contracts\n\nThe contracts are written for Solidity 0.5.0. As such, no changes were required when deploying and using the contracts.\n\n## Testing Workflow\n\nIn general, the test consists of sending corresponding messages from one agent to another.\n\nNext, the Promisor finds a new liability contract in the network and begins to execute it. Upon completion of the work, a message is sent with the result, which is then recorded in the contract.\n\nStep-by-step instructions for launching are in [README.md](https://github.com/Multi-Agent-io/neon-kuka-demo/blob/main/README.md)\n\n## Testing Results in Detail\n\nScreencast of the process\n\nhttps://youtu.be/fYJVF7KrNnI\n\n![Liability](./images/testing-neon-with-robonomics/liability.jpg)\n\nWhen the simulation starts, an offer message is created, and a demand message comes from the Promisee, after which a Liability contract is created using the createLiability function of the Lighthouse contract. With the help of the XRT contract, tokens are transferred from the Promisee’s address to the address of the Liability contract.\n\nAfter a new Liability contract has been discovered on the Neon devnet, the agent starts working. The result of the work (telemetry) is written to a file and sent to IPFS, the hash from the file is saved as a result.\n\nAfter the work is completed, the Liability contract is finalized using the finalizeLiability() function of the Lighthouse contract and the tokens are transferred from the Liability address to the addresses of the Promisor and Validator.\n\nThe successful execution of the simulation showed that all contracts worked correctly and the Neon platform works.\n\n## Neon Platform Drawbacks\n\n### Truffle fails if it doesn't get a response from the network\n\nDuring the process of deploying contracts, it turned out that the proxy does not always return a response on time, which is why Truffle ends with an error:\n\n```\nTypeError: Cannot read properties of null (reading 'from')                                    \n    at Web3InterfaceAdapter.<anonymous> (/usr/lib/node_modules/truffle/build/webpack:/packages\n/interface-adapter/dist/adapter/web3/index.js:71:1)                                           \n    at Generator.next (<anonymous>)                                                           \n    at fulfilled (/usr/lib/node_modules/truffle/build/webpack:/packages/interface-adapter/dist\n/adapter/web3/index.js:5:43)                                                                  \n    at runMicrotasks (<anonymous>)\n    at processTicksAndRejections (node:internal/process/task_queues:96:5)\nTruffle v5.5.23 (core: 5.5.23)\nNode v16.14.0\n```\n\nIt was not possible to find a relationship between the test conditions and the occurrence of an error, but most likely Neon EVM cannot send a transaction receipt, and Truffle cannot process a Null response.\n\nIf we add timeout and retry here [index.ts#L75](https://github.com/trufflesuite/truffle/blob/develop/packages/interface-adapter/lib/adapter/web3/index.ts#L75), then the deployment should proceed without errors.\n\n### No WS/WSS Endpoint\n\nNeon EVM does not have a WS/WSS endpoint unlike Ethereum, which makes it impossible to subscribe to events from the network. Therefore, during testing, we monitored the events manually.\n\n### No Event Names\n\nNeon EVM returns rather poor descriptions of events after a transaction, for example:\n\n```\n events: {\n    '0': {\n      address: '0xCFa833bF0D46369D9024f95c9C8dFa1E4a07806C',\n      transactionHash: '0x9894a984e6b3f6ce469c8837e11739f6e50d00216cf7c5bc3d32da106a58d50a',\n      transactionLogIndex: '0x1',\n      blockHash: '0x72040f317d3a469d30327d4e1def903790b70dbede46b4f0ea4f28f30a679a80',\n      blockNumber: 156073183,\n      transactionIndex: 0,\n      logIndex: 1,\n      id: 'log_e51e2f9f',\n      returnValues: Result {},\n      event: undefined,\n      signature: null,\n      raw: [Object]\n    },\n...\n```\n\nInstead of 0, 1, etc. we expected to see named events.\n\n## Conclusion\n\nUsing the Neon EVM platform, a scenario was successfully tested whereby a liability contract between a Promisee and a Promisor is concluded with subsequent validation of the result of the work done by a third party. Additionally, a Provider participated, who checked the coincidence of supply and demand between the parties, and received a commission for this work.\n\nThe demonstration used a simulation of a robotic arm that was hired to perform a sequence of actions. As a result of the work, the robot sent a file with telemetry received during the task.\n\nDespite some peculiarities in the operation of the network, in the end, all participating contracts showed their operability in the Neon environment.\n\n\n\n","cover_image":{"type":"image","mimeType":"image/jpeg","src":"/assets/static/blog_cover_neon_multi-agent.62c183a.6231caf624da0ea84dd55d0582533702.jpg","size":{"width":1500,"height":675},"sizes":"(max-width: 1500px) 100vw, 1500px","srcset":["/assets/static/blog_cover_neon_multi-agent.9ea8d39.6231caf624da0ea84dd55d0582533702.jpg 480w","/assets/static/blog_cover_neon_multi-agent.6b2ed88.6231caf624da0ea84dd55d0582533702.jpg 1024w","/assets/static/blog_cover_neon_multi-agent.62c183a.6231caf624da0ea84dd55d0582533702.jpg 1500w"],"dataUri":"data:image/svg+xml,%3csvg fill='none' viewBox='0 0 1500 675' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'%3e%3cdefs%3e%3cfilter id='__svg-blur-6955165ddd4a470810755efcfe6cef5d'%3e%3cfeGaussianBlur in='SourceGraphic' stdDeviation='40'/%3e%3c/filter%3e%3c/defs%3e%3cimage x='0' y='0' filter='url(%23__svg-blur-6955165ddd4a470810755efcfe6cef5d)' width='1500' height='675' xlink:href='data:image/jpeg%3bbase64%2c/9j/2wBDAAYEBQYFBAYGBQYHBwYIChAKCgkJChQODwwQFxQYGBcUFhYaHSUfGhsjHBYWICwgIyYnKSopGR8tMC0oMCUoKSj/2wBDAQcHBwoIChMKChMoGhYaKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCj/wAARCAAdAEADASIAAhEBAxEB/8QAHAAAAQQDAQAAAAAAAAAAAAAABQIDBAYAAQcI/8QAJxAAAgIBAwQCAgMBAAAAAAAAAQIDEQQABTESEyFBBiJRsTJxgfD/xAAYAQADAQEAAAAAAAAAAAAAAAABAgMABP/EAB0RAAIDAAMBAQAAAAAAAAAAAAECAAMREiExQXH/2gAMAwEAAhEDEQA/APL6xdUDSdX8TVUf3/mmtb62CFQfqfWr/wDKvgMOxxZDR7gJ6EUkRJC0kjKv3HqiSLHjj%2btddVD2glB4NMtVRZaGZRoHc5/p7DiWadY26z1EABF6mJPAA1dF%2bARSQ96L5FtckZkKKik9xqu6W%2bbBoX5Au/WgW%2b7OuyZMKQbhiZ7Pas0B%2bqsKuieR9hTe/P41EEbItpHUCyhVkIQkr6sUdZ2ZfrUbnqXqFC7H51JxExp5HOVM0THwqqtgn%2b/Wuhr8Y7ewyjGDGWAMsUwnKO63bMAFocGlJPHIsWDMPJzF0aM06sp/DCtOTRdtEbqvqF8Ef9xolv8AtuVgSMNwmeTJ7hWyxYFfPmzzehTyM4AY2BxoiY7E6l5ORlZMQlycuabx26kkZiBzXn17rUTSu43b6L%2bvNaIOdQ63gMT/AINWX4JtsGZuGXl56scDb8WTImK0DYWlAv2T%2btVrVr2N0HwbfAYlMgdemSyCtgA%2b64/Oo2ozoVT0ytLIjhn8EGb1LsuRDDNtkOVjZMtmeFyGjiI9IeSDz5quPOimF8rnkx5cWeFCsg6mAmkRZGAFkgMALCiwKBrVT1mmROAzd/YjtzPIybumTkZ8pzcuVXllJJparzZ/eoWltIzIqE/UcDSNPEG/Z//Z' /%3e%3c/svg%3e"},"locale":"es"}},{"node":{"title":"Testing Neon EVM with Robonomics Smart Contracts","path":"/blog/fr/testing-neon-with-robonomics/","date":"October 3, 2022","description":"The purpose of these tests were to validate the readiness of the Neon platform to move to the production stage using Robonomics smart contracts, which allow cyber-physical systems (robots) to make technical-economic transactions.","content":"\n## TL;DR\n\nThe purpose of these tests were to validate the readiness of the [Neon](https://neon-labs.org/) platform to move to the production stage using Robonomics smart contracts, which allow cyber-physical systems (robots) to make technical-economic transactions.\n\nIn the Robonomics network, interaction is established between two parties: Promisee - the one who orders the service, sends a description of technical task and transfers funds for its execution; Promisor - one who performs a service. A typical scenario was tested, whereby a liability contract is concluded between a Promisee and a Promisor - this was followed by validation of the resulting work by a third party, and a commission payment to the node that accompanied the contract between the parties.\n\nFor this example, a simulation of a robotic arm was used, which was asked to perform a sequence of actions. The tests were successful.\n\n## Scope and Goals of Testing\n\nEngineers of [Multi-Agent Systems](https://multi-agent.io/) have been working with [Robonomics Network](https://robonomics.network/) for several years. The first implementation of the Robonomics Network was created for the Ethereum network. It is a set of smart contracts for machine-to-machine communication.\n\nThe core of the Robonomics Network is the [Liability](https://github.com/airalab/robonomics_contracts/blob/master/contracts/robonomics/Liability.sol) contract, a smart contract that reproduces the typical relationship between the customer of a service (Promisee) and the service provider (Promisor), and includes the technical and economic parameters of the transaction between them. The parties can be either an autonomous agent and a person (human-to-machine interaction), or purely two autonomous agents (machine-to-machine interaction). The Promisee and Promisor broadcast messages with the parameters of their technical-economic transaction, and then the conclusion of the transaction is provided by a special node - the Provider - which looks for matches of these parameters. Providers are controlled by [Lighthouse](https://github.com/airalab/robonomics_contracts/blob/master/contracts/robonomics/Lighthouse.sol), which is a special smart contract that executes a transaction when the provider establishes a market match between the parties.\n\nThere are three scenarios in which the fulfillment of an obligation can take place:\n\n1. A simple commitment (with no verification of the final result, and no commission paid to Provider nodes)\n2. Obligation with a commission paid to the Provider\n3. Commitment with a commission to the Provider and validation of the results with the help of a third party - observing network.\n\nThe purpose of this test is to test the most complex, third Robonomics scenario on the Neon EVM platform.\n\n## Testing Scenarios Description\n\nAs we develop the industrial zones and the infrastructure of modern cities, the emergence of fully automated enterprises and services that are controlled by cyber-physical systems (CPS) and which provide their services as autonomous agents is highly likely. In this regard, we can also expect the formation of networks of autonomous CPS in order to increase the speed and quality of communication in the process of production and provision of services.\n\nIn order to take full advantage of the possibilities of smart contracts, a scenario of interaction between two autonomous economic agents was chosen. Consider the liability life cycle in the Robonomics network:\n\n![Liability Life Cycle](./images/testing-neon-with-robonomics/step-by-step-3.jpg)\n\nThe figure above shows that the Robonomics network provider calls the Lighthouse contract, which in turn calls the [contract factory](https://github.com/airalab/robonomics_contracts/blob/master/contracts/robonomics/Factory.sol) to create the Liability contract. The Liability contract contains data about the transaction, such as the terms of reference, payment for the service, validator address and the deadline.\n\nTo learn more about the possible use cases for Robonomics, check out the Robonomics [R&D](https://wiki.robonomics.network/docs/en/r-and-d-based-on-robonomics-network/#launching-a-drone-under-the-control-of-a-decentralized-computer) page!\n\nTo replicate the entire Robonomics infrastructure on the Neon network, we will implement a robot launch scenario through a Liability contract similar to this [example](https://wiki.robonomics.network/docs/en/kuka/). If the script can be repeated, then all functions will work.\n\n## Deliverables\n\nThe source code for the Robonomics contracts is available [here](https://github.com/airalab/robonomics_contracts).\nThe contracts use many features of the Ethereum VM which includes:\n\n- ERC20 [XRT](https://github.com/airalab/robonomics_contracts/blob/master/contracts/robonomics/XRT.sol) Token\n- [Factory](https://github.com/airalab/robonomics_contracts/blob/master/contracts/robonomics/Factory.sol)\n- Own contract for [ENS](https://github.com/airalab/robonomics_contracts/blob/master/contracts/ens/ENS.sol)\n- [Proxy](https://github.com/airalab/robonomics_contracts/blob/master/contracts/misc/SharedCode.sol) for contracts\n- Various modifiers and roles in contracts\n\nAddresses of contracts in the Neon devnet network https://devnet.neonevm.org\n\n| Contract Name  | Address                                    |\n|----------------|--------------------------------------------|\n| Migrations     | 0x1DC538bE2C8572509a571B150f11aB55E52EF12E |\n| ENS            | 0xa7AEa12F60D0278F01e14DBC7cc459d04d051406 |\n| DutchAuction   | 0xF44F8803548D72Dbc3E28340EFD7b5328aa4F058 |\n| Liability      | 0xA694196351dc1488e3884eCc6b650F0d8D55346a |\n| Lighthouse     | 0x80FB5CC4c396E272b56700E6ffF5DBf4661013A8 |\n| XRT            | 0x3322d7D99cF65Cab5A92073c928b5E9674af3c29 |\n| PublicAmbix    | 0x85c03bE5ccFf11E79a0A776D183eF067590549d1 |\n| Factory        | 0xCFa833bF0D46369D9024f95c9C8dFa1E4a07806C |\n| PublicResolver | 0xAC9E9AA8A4cB524FE87f2b14489F1D6bE68dc46e |\n\n[Source code](https://github.com/Multi-Agent-io/neon-kuka-demo) for the scenario\n\n## Changes Made to Original Contracts\n\nThe contracts are written for Solidity 0.5.0. As such, no changes were required when deploying and using the contracts.\n\n## Testing Workflow\n\nIn general, the test consists of sending corresponding messages from one agent to another.\n\nNext, the Promisor finds a new liability contract in the network and begins to execute it. Upon completion of the work, a message is sent with the result, which is then recorded in the contract.\n\nStep-by-step instructions for launching are in [README.md](https://github.com/Multi-Agent-io/neon-kuka-demo/blob/main/README.md)\n\n## Testing Results in Detail\n\nScreencast of the process\n\nhttps://youtu.be/fYJVF7KrNnI\n\n![Liability](./images/testing-neon-with-robonomics/liability.jpg)\n\nWhen the simulation starts, an offer message is created, and a demand message comes from the Promisee, after which a Liability contract is created using the createLiability function of the Lighthouse contract. With the help of the XRT contract, tokens are transferred from the Promisee’s address to the address of the Liability contract.\n\nAfter a new Liability contract has been discovered on the Neon devnet, the agent starts working. The result of the work (telemetry) is written to a file and sent to IPFS, the hash from the file is saved as a result.\n\nAfter the work is completed, the Liability contract is finalized using the finalizeLiability() function of the Lighthouse contract and the tokens are transferred from the Liability address to the addresses of the Promisor and Validator.\n\nThe successful execution of the simulation showed that all contracts worked correctly and the Neon platform works.\n\n## Neon Platform Drawbacks\n\n### Truffle fails if it doesn't get a response from the network\n\nDuring the process of deploying contracts, it turned out that the proxy does not always return a response on time, which is why Truffle ends with an error:\n\n```\nTypeError: Cannot read properties of null (reading 'from')                                    \n    at Web3InterfaceAdapter.<anonymous> (/usr/lib/node_modules/truffle/build/webpack:/packages\n/interface-adapter/dist/adapter/web3/index.js:71:1)                                           \n    at Generator.next (<anonymous>)                                                           \n    at fulfilled (/usr/lib/node_modules/truffle/build/webpack:/packages/interface-adapter/dist\n/adapter/web3/index.js:5:43)                                                                  \n    at runMicrotasks (<anonymous>)\n    at processTicksAndRejections (node:internal/process/task_queues:96:5)\nTruffle v5.5.23 (core: 5.5.23)\nNode v16.14.0\n```\n\nIt was not possible to find a relationship between the test conditions and the occurrence of an error, but most likely Neon EVM cannot send a transaction receipt, and Truffle cannot process a Null response.\n\nIf we add timeout and retry here [index.ts#L75](https://github.com/trufflesuite/truffle/blob/develop/packages/interface-adapter/lib/adapter/web3/index.ts#L75), then the deployment should proceed without errors.\n\n### No WS/WSS Endpoint\n\nNeon EVM does not have a WS/WSS endpoint unlike Ethereum, which makes it impossible to subscribe to events from the network. Therefore, during testing, we monitored the events manually.\n\n### No Event Names\n\nNeon EVM returns rather poor descriptions of events after a transaction, for example:\n\n```\n events: {\n    '0': {\n      address: '0xCFa833bF0D46369D9024f95c9C8dFa1E4a07806C',\n      transactionHash: '0x9894a984e6b3f6ce469c8837e11739f6e50d00216cf7c5bc3d32da106a58d50a',\n      transactionLogIndex: '0x1',\n      blockHash: '0x72040f317d3a469d30327d4e1def903790b70dbede46b4f0ea4f28f30a679a80',\n      blockNumber: 156073183,\n      transactionIndex: 0,\n      logIndex: 1,\n      id: 'log_e51e2f9f',\n      returnValues: Result {},\n      event: undefined,\n      signature: null,\n      raw: [Object]\n    },\n...\n```\n\nInstead of 0, 1, etc. we expected to see named events.\n\n## Conclusion\n\nUsing the Neon EVM platform, a scenario was successfully tested whereby a liability contract between a Promisee and a Promisor is concluded with subsequent validation of the result of the work done by a third party. Additionally, a Provider participated, who checked the coincidence of supply and demand between the parties, and received a commission for this work.\n\nThe demonstration used a simulation of a robotic arm that was hired to perform a sequence of actions. As a result of the work, the robot sent a file with telemetry received during the task.\n\nDespite some peculiarities in the operation of the network, in the end, all participating contracts showed their operability in the Neon environment.\n\n\n\n","cover_image":{"type":"image","mimeType":"image/jpeg","src":"/assets/static/blog_cover_neon_multi-agent.62c183a.6231caf624da0ea84dd55d0582533702.jpg","size":{"width":1500,"height":675},"sizes":"(max-width: 1500px) 100vw, 1500px","srcset":["/assets/static/blog_cover_neon_multi-agent.9ea8d39.6231caf624da0ea84dd55d0582533702.jpg 480w","/assets/static/blog_cover_neon_multi-agent.6b2ed88.6231caf624da0ea84dd55d0582533702.jpg 1024w","/assets/static/blog_cover_neon_multi-agent.62c183a.6231caf624da0ea84dd55d0582533702.jpg 1500w"],"dataUri":"data:image/svg+xml,%3csvg fill='none' viewBox='0 0 1500 675' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'%3e%3cdefs%3e%3cfilter id='__svg-blur-6955165ddd4a470810755efcfe6cef5d'%3e%3cfeGaussianBlur in='SourceGraphic' stdDeviation='40'/%3e%3c/filter%3e%3c/defs%3e%3cimage x='0' y='0' filter='url(%23__svg-blur-6955165ddd4a470810755efcfe6cef5d)' width='1500' height='675' xlink:href='data:image/jpeg%3bbase64%2c/9j/2wBDAAYEBQYFBAYGBQYHBwYIChAKCgkJChQODwwQFxQYGBcUFhYaHSUfGhsjHBYWICwgIyYnKSopGR8tMC0oMCUoKSj/2wBDAQcHBwoIChMKChMoGhYaKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCj/wAARCAAdAEADASIAAhEBAxEB/8QAHAAAAQQDAQAAAAAAAAAAAAAABQIDBAYAAQcI/8QAJxAAAgIBAwQCAgMBAAAAAAAAAQIDEQQABTESEyFBBiJRsTJxgfD/xAAYAQADAQEAAAAAAAAAAAAAAAABAgMABP/EAB0RAAIDAAMBAQAAAAAAAAAAAAECAAMREiExQXH/2gAMAwEAAhEDEQA/APL6xdUDSdX8TVUf3/mmtb62CFQfqfWr/wDKvgMOxxZDR7gJ6EUkRJC0kjKv3HqiSLHjj%2btddVD2glB4NMtVRZaGZRoHc5/p7DiWadY26z1EABF6mJPAA1dF%2bARSQ96L5FtckZkKKik9xqu6W%2bbBoX5Au/WgW%2b7OuyZMKQbhiZ7Pas0B%2bqsKuieR9hTe/P41EEbItpHUCyhVkIQkr6sUdZ2ZfrUbnqXqFC7H51JxExp5HOVM0THwqqtgn%2b/Wuhr8Y7ewyjGDGWAMsUwnKO63bMAFocGlJPHIsWDMPJzF0aM06sp/DCtOTRdtEbqvqF8Ef9xolv8AtuVgSMNwmeTJ7hWyxYFfPmzzehTyM4AY2BxoiY7E6l5ORlZMQlycuabx26kkZiBzXn17rUTSu43b6L%2bvNaIOdQ63gMT/AINWX4JtsGZuGXl56scDb8WTImK0DYWlAv2T%2btVrVr2N0HwbfAYlMgdemSyCtgA%2b64/Oo2ozoVT0ytLIjhn8EGb1LsuRDDNtkOVjZMtmeFyGjiI9IeSDz5quPOimF8rnkx5cWeFCsg6mAmkRZGAFkgMALCiwKBrVT1mmROAzd/YjtzPIybumTkZ8pzcuVXllJJparzZ/eoWltIzIqE/UcDSNPEG/Z//Z' /%3e%3c/svg%3e"},"locale":"fr"}},{"node":{"title":"Testing Neon EVM with Robonomics Smart Contracts","path":"/blog/it/testing-neon-with-robonomics/","date":"October 3, 2022","description":"The purpose of these tests were to validate the readiness of the Neon platform to move to the production stage using Robonomics smart contracts, which allow cyber-physical systems (robots) to make technical-economic transactions.","content":"\n## TL;DR\n\nThe purpose of these tests were to validate the readiness of the [Neon](https://neon-labs.org/) platform to move to the production stage using Robonomics smart contracts, which allow cyber-physical systems (robots) to make technical-economic transactions.\n\nIn the Robonomics network, interaction is established between two parties: Promisee - the one who orders the service, sends a description of technical task and transfers funds for its execution; Promisor - one who performs a service. A typical scenario was tested, whereby a liability contract is concluded between a Promisee and a Promisor - this was followed by validation of the resulting work by a third party, and a commission payment to the node that accompanied the contract between the parties.\n\nFor this example, a simulation of a robotic arm was used, which was asked to perform a sequence of actions. The tests were successful.\n\n## Scope and Goals of Testing\n\nEngineers of [Multi-Agent Systems](https://multi-agent.io/) have been working with [Robonomics Network](https://robonomics.network/) for several years. The first implementation of the Robonomics Network was created for the Ethereum network. It is a set of smart contracts for machine-to-machine communication.\n\nThe core of the Robonomics Network is the [Liability](https://github.com/airalab/robonomics_contracts/blob/master/contracts/robonomics/Liability.sol) contract, a smart contract that reproduces the typical relationship between the customer of a service (Promisee) and the service provider (Promisor), and includes the technical and economic parameters of the transaction between them. The parties can be either an autonomous agent and a person (human-to-machine interaction), or purely two autonomous agents (machine-to-machine interaction). The Promisee and Promisor broadcast messages with the parameters of their technical-economic transaction, and then the conclusion of the transaction is provided by a special node - the Provider - which looks for matches of these parameters. Providers are controlled by [Lighthouse](https://github.com/airalab/robonomics_contracts/blob/master/contracts/robonomics/Lighthouse.sol), which is a special smart contract that executes a transaction when the provider establishes a market match between the parties.\n\nThere are three scenarios in which the fulfillment of an obligation can take place:\n\n1. A simple commitment (with no verification of the final result, and no commission paid to Provider nodes)\n2. Obligation with a commission paid to the Provider\n3. Commitment with a commission to the Provider and validation of the results with the help of a third party - observing network.\n\nThe purpose of this test is to test the most complex, third Robonomics scenario on the Neon EVM platform.\n\n## Testing Scenarios Description\n\nAs we develop the industrial zones and the infrastructure of modern cities, the emergence of fully automated enterprises and services that are controlled by cyber-physical systems (CPS) and which provide their services as autonomous agents is highly likely. In this regard, we can also expect the formation of networks of autonomous CPS in order to increase the speed and quality of communication in the process of production and provision of services.\n\nIn order to take full advantage of the possibilities of smart contracts, a scenario of interaction between two autonomous economic agents was chosen. Consider the liability life cycle in the Robonomics network:\n\n![Liability Life Cycle](./images/testing-neon-with-robonomics/step-by-step-3.jpg)\n\nThe figure above shows that the Robonomics network provider calls the Lighthouse contract, which in turn calls the [contract factory](https://github.com/airalab/robonomics_contracts/blob/master/contracts/robonomics/Factory.sol) to create the Liability contract. The Liability contract contains data about the transaction, such as the terms of reference, payment for the service, validator address and the deadline.\n\nTo learn more about the possible use cases for Robonomics, check out the Robonomics [R&D](https://wiki.robonomics.network/docs/en/r-and-d-based-on-robonomics-network/#launching-a-drone-under-the-control-of-a-decentralized-computer) page!\n\nTo replicate the entire Robonomics infrastructure on the Neon network, we will implement a robot launch scenario through a Liability contract similar to this [example](https://wiki.robonomics.network/docs/en/kuka/). If the script can be repeated, then all functions will work.\n\n## Deliverables\n\nThe source code for the Robonomics contracts is available [here](https://github.com/airalab/robonomics_contracts).\nThe contracts use many features of the Ethereum VM which includes:\n\n- ERC20 [XRT](https://github.com/airalab/robonomics_contracts/blob/master/contracts/robonomics/XRT.sol) Token\n- [Factory](https://github.com/airalab/robonomics_contracts/blob/master/contracts/robonomics/Factory.sol)\n- Own contract for [ENS](https://github.com/airalab/robonomics_contracts/blob/master/contracts/ens/ENS.sol)\n- [Proxy](https://github.com/airalab/robonomics_contracts/blob/master/contracts/misc/SharedCode.sol) for contracts\n- Various modifiers and roles in contracts\n\nAddresses of contracts in the Neon devnet network https://devnet.neonevm.org\n\n| Contract Name  | Address                                    |\n|----------------|--------------------------------------------|\n| Migrations     | 0x1DC538bE2C8572509a571B150f11aB55E52EF12E |\n| ENS            | 0xa7AEa12F60D0278F01e14DBC7cc459d04d051406 |\n| DutchAuction   | 0xF44F8803548D72Dbc3E28340EFD7b5328aa4F058 |\n| Liability      | 0xA694196351dc1488e3884eCc6b650F0d8D55346a |\n| Lighthouse     | 0x80FB5CC4c396E272b56700E6ffF5DBf4661013A8 |\n| XRT            | 0x3322d7D99cF65Cab5A92073c928b5E9674af3c29 |\n| PublicAmbix    | 0x85c03bE5ccFf11E79a0A776D183eF067590549d1 |\n| Factory        | 0xCFa833bF0D46369D9024f95c9C8dFa1E4a07806C |\n| PublicResolver | 0xAC9E9AA8A4cB524FE87f2b14489F1D6bE68dc46e |\n\n[Source code](https://github.com/Multi-Agent-io/neon-kuka-demo) for the scenario\n\n## Changes Made to Original Contracts\n\nThe contracts are written for Solidity 0.5.0. As such, no changes were required when deploying and using the contracts.\n\n## Testing Workflow\n\nIn general, the test consists of sending corresponding messages from one agent to another.\n\nNext, the Promisor finds a new liability contract in the network and begins to execute it. Upon completion of the work, a message is sent with the result, which is then recorded in the contract.\n\nStep-by-step instructions for launching are in [README.md](https://github.com/Multi-Agent-io/neon-kuka-demo/blob/main/README.md)\n\n## Testing Results in Detail\n\nScreencast of the process\n\nhttps://youtu.be/fYJVF7KrNnI\n\n![Liability](./images/testing-neon-with-robonomics/liability.jpg)\n\nWhen the simulation starts, an offer message is created, and a demand message comes from the Promisee, after which a Liability contract is created using the createLiability function of the Lighthouse contract. With the help of the XRT contract, tokens are transferred from the Promisee’s address to the address of the Liability contract.\n\nAfter a new Liability contract has been discovered on the Neon devnet, the agent starts working. The result of the work (telemetry) is written to a file and sent to IPFS, the hash from the file is saved as a result.\n\nAfter the work is completed, the Liability contract is finalized using the finalizeLiability() function of the Lighthouse contract and the tokens are transferred from the Liability address to the addresses of the Promisor and Validator.\n\nThe successful execution of the simulation showed that all contracts worked correctly and the Neon platform works.\n\n## Neon Platform Drawbacks\n\n### Truffle fails if it doesn't get a response from the network\n\nDuring the process of deploying contracts, it turned out that the proxy does not always return a response on time, which is why Truffle ends with an error:\n\n```\nTypeError: Cannot read properties of null (reading 'from')                                    \n    at Web3InterfaceAdapter.<anonymous> (/usr/lib/node_modules/truffle/build/webpack:/packages\n/interface-adapter/dist/adapter/web3/index.js:71:1)                                           \n    at Generator.next (<anonymous>)                                                           \n    at fulfilled (/usr/lib/node_modules/truffle/build/webpack:/packages/interface-adapter/dist\n/adapter/web3/index.js:5:43)                                                                  \n    at runMicrotasks (<anonymous>)\n    at processTicksAndRejections (node:internal/process/task_queues:96:5)\nTruffle v5.5.23 (core: 5.5.23)\nNode v16.14.0\n```\n\nIt was not possible to find a relationship between the test conditions and the occurrence of an error, but most likely Neon EVM cannot send a transaction receipt, and Truffle cannot process a Null response.\n\nIf we add timeout and retry here [index.ts#L75](https://github.com/trufflesuite/truffle/blob/develop/packages/interface-adapter/lib/adapter/web3/index.ts#L75), then the deployment should proceed without errors.\n\n### No WS/WSS Endpoint\n\nNeon EVM does not have a WS/WSS endpoint unlike Ethereum, which makes it impossible to subscribe to events from the network. Therefore, during testing, we monitored the events manually.\n\n### No Event Names\n\nNeon EVM returns rather poor descriptions of events after a transaction, for example:\n\n```\n events: {\n    '0': {\n      address: '0xCFa833bF0D46369D9024f95c9C8dFa1E4a07806C',\n      transactionHash: '0x9894a984e6b3f6ce469c8837e11739f6e50d00216cf7c5bc3d32da106a58d50a',\n      transactionLogIndex: '0x1',\n      blockHash: '0x72040f317d3a469d30327d4e1def903790b70dbede46b4f0ea4f28f30a679a80',\n      blockNumber: 156073183,\n      transactionIndex: 0,\n      logIndex: 1,\n      id: 'log_e51e2f9f',\n      returnValues: Result {},\n      event: undefined,\n      signature: null,\n      raw: [Object]\n    },\n...\n```\n\nInstead of 0, 1, etc. we expected to see named events.\n\n## Conclusion\n\nUsing the Neon EVM platform, a scenario was successfully tested whereby a liability contract between a Promisee and a Promisor is concluded with subsequent validation of the result of the work done by a third party. Additionally, a Provider participated, who checked the coincidence of supply and demand between the parties, and received a commission for this work.\n\nThe demonstration used a simulation of a robotic arm that was hired to perform a sequence of actions. As a result of the work, the robot sent a file with telemetry received during the task.\n\nDespite some peculiarities in the operation of the network, in the end, all participating contracts showed their operability in the Neon environment.\n\n\n\n","cover_image":{"type":"image","mimeType":"image/jpeg","src":"/assets/static/blog_cover_neon_multi-agent.62c183a.6231caf624da0ea84dd55d0582533702.jpg","size":{"width":1500,"height":675},"sizes":"(max-width: 1500px) 100vw, 1500px","srcset":["/assets/static/blog_cover_neon_multi-agent.9ea8d39.6231caf624da0ea84dd55d0582533702.jpg 480w","/assets/static/blog_cover_neon_multi-agent.6b2ed88.6231caf624da0ea84dd55d0582533702.jpg 1024w","/assets/static/blog_cover_neon_multi-agent.62c183a.6231caf624da0ea84dd55d0582533702.jpg 1500w"],"dataUri":"data:image/svg+xml,%3csvg fill='none' viewBox='0 0 1500 675' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'%3e%3cdefs%3e%3cfilter id='__svg-blur-6955165ddd4a470810755efcfe6cef5d'%3e%3cfeGaussianBlur in='SourceGraphic' stdDeviation='40'/%3e%3c/filter%3e%3c/defs%3e%3cimage x='0' y='0' filter='url(%23__svg-blur-6955165ddd4a470810755efcfe6cef5d)' width='1500' height='675' xlink:href='data:image/jpeg%3bbase64%2c/9j/2wBDAAYEBQYFBAYGBQYHBwYIChAKCgkJChQODwwQFxQYGBcUFhYaHSUfGhsjHBYWICwgIyYnKSopGR8tMC0oMCUoKSj/2wBDAQcHBwoIChMKChMoGhYaKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCj/wAARCAAdAEADASIAAhEBAxEB/8QAHAAAAQQDAQAAAAAAAAAAAAAABQIDBAYAAQcI/8QAJxAAAgIBAwQCAgMBAAAAAAAAAQIDEQQABTESEyFBBiJRsTJxgfD/xAAYAQADAQEAAAAAAAAAAAAAAAABAgMABP/EAB0RAAIDAAMBAQAAAAAAAAAAAAECAAMREiExQXH/2gAMAwEAAhEDEQA/APL6xdUDSdX8TVUf3/mmtb62CFQfqfWr/wDKvgMOxxZDR7gJ6EUkRJC0kjKv3HqiSLHjj%2btddVD2glB4NMtVRZaGZRoHc5/p7DiWadY26z1EABF6mJPAA1dF%2bARSQ96L5FtckZkKKik9xqu6W%2bbBoX5Au/WgW%2b7OuyZMKQbhiZ7Pas0B%2bqsKuieR9hTe/P41EEbItpHUCyhVkIQkr6sUdZ2ZfrUbnqXqFC7H51JxExp5HOVM0THwqqtgn%2b/Wuhr8Y7ewyjGDGWAMsUwnKO63bMAFocGlJPHIsWDMPJzF0aM06sp/DCtOTRdtEbqvqF8Ef9xolv8AtuVgSMNwmeTJ7hWyxYFfPmzzehTyM4AY2BxoiY7E6l5ORlZMQlycuabx26kkZiBzXn17rUTSu43b6L%2bvNaIOdQ63gMT/AINWX4JtsGZuGXl56scDb8WTImK0DYWlAv2T%2btVrVr2N0HwbfAYlMgdemSyCtgA%2b64/Oo2ozoVT0ytLIjhn8EGb1LsuRDDNtkOVjZMtmeFyGjiI9IeSDz5quPOimF8rnkx5cWeFCsg6mAmkRZGAFkgMALCiwKBrVT1mmROAzd/YjtzPIybumTkZ8pzcuVXllJJparzZ/eoWltIzIqE/UcDSNPEG/Z//Z' /%3e%3c/svg%3e"},"locale":"it"}},{"node":{"title":"Testing Neon EVM with Robonomics Smart Contracts","path":"/blog/ja/testing-neon-with-robonomics/","date":"October 3, 2022","description":"The purpose of these tests were to validate the readiness of the Neon platform to move to the production stage using Robonomics smart contracts, which allow cyber-physical systems (robots) to make technical-economic transactions.","content":"\n## TL;DR\n\nThe purpose of these tests were to validate the readiness of the [Neon](https://neon-labs.org/) platform to move to the production stage using Robonomics smart contracts, which allow cyber-physical systems (robots) to make technical-economic transactions.\n\nIn the Robonomics network, interaction is established between two parties: Promisee - the one who orders the service, sends a description of technical task and transfers funds for its execution; Promisor - one who performs a service. A typical scenario was tested, whereby a liability contract is concluded between a Promisee and a Promisor - this was followed by validation of the resulting work by a third party, and a commission payment to the node that accompanied the contract between the parties.\n\nFor this example, a simulation of a robotic arm was used, which was asked to perform a sequence of actions. The tests were successful.\n\n## Scope and Goals of Testing\n\nEngineers of [Multi-Agent Systems](https://multi-agent.io/) have been working with [Robonomics Network](https://robonomics.network/) for several years. The first implementation of the Robonomics Network was created for the Ethereum network. It is a set of smart contracts for machine-to-machine communication.\n\nThe core of the Robonomics Network is the [Liability](https://github.com/airalab/robonomics_contracts/blob/master/contracts/robonomics/Liability.sol) contract, a smart contract that reproduces the typical relationship between the customer of a service (Promisee) and the service provider (Promisor), and includes the technical and economic parameters of the transaction between them. The parties can be either an autonomous agent and a person (human-to-machine interaction), or purely two autonomous agents (machine-to-machine interaction). The Promisee and Promisor broadcast messages with the parameters of their technical-economic transaction, and then the conclusion of the transaction is provided by a special node - the Provider - which looks for matches of these parameters. Providers are controlled by [Lighthouse](https://github.com/airalab/robonomics_contracts/blob/master/contracts/robonomics/Lighthouse.sol), which is a special smart contract that executes a transaction when the provider establishes a market match between the parties.\n\nThere are three scenarios in which the fulfillment of an obligation can take place:\n\n1. A simple commitment (with no verification of the final result, and no commission paid to Provider nodes)\n2. Obligation with a commission paid to the Provider\n3. Commitment with a commission to the Provider and validation of the results with the help of a third party - observing network.\n\nThe purpose of this test is to test the most complex, third Robonomics scenario on the Neon EVM platform.\n\n## Testing Scenarios Description\n\nAs we develop the industrial zones and the infrastructure of modern cities, the emergence of fully automated enterprises and services that are controlled by cyber-physical systems (CPS) and which provide their services as autonomous agents is highly likely. In this regard, we can also expect the formation of networks of autonomous CPS in order to increase the speed and quality of communication in the process of production and provision of services.\n\nIn order to take full advantage of the possibilities of smart contracts, a scenario of interaction between two autonomous economic agents was chosen. Consider the liability life cycle in the Robonomics network:\n\n![Liability Life Cycle](./images/testing-neon-with-robonomics/step-by-step-3.jpg)\n\nThe figure above shows that the Robonomics network provider calls the Lighthouse contract, which in turn calls the [contract factory](https://github.com/airalab/robonomics_contracts/blob/master/contracts/robonomics/Factory.sol) to create the Liability contract. The Liability contract contains data about the transaction, such as the terms of reference, payment for the service, validator address and the deadline.\n\nTo learn more about the possible use cases for Robonomics, check out the Robonomics [R&D](https://wiki.robonomics.network/docs/en/r-and-d-based-on-robonomics-network/#launching-a-drone-under-the-control-of-a-decentralized-computer) page!\n\nTo replicate the entire Robonomics infrastructure on the Neon network, we will implement a robot launch scenario through a Liability contract similar to this [example](https://wiki.robonomics.network/docs/en/kuka/). If the script can be repeated, then all functions will work.\n\n## Deliverables\n\nThe source code for the Robonomics contracts is available [here](https://github.com/airalab/robonomics_contracts).\nThe contracts use many features of the Ethereum VM which includes:\n\n- ERC20 [XRT](https://github.com/airalab/robonomics_contracts/blob/master/contracts/robonomics/XRT.sol) Token\n- [Factory](https://github.com/airalab/robonomics_contracts/blob/master/contracts/robonomics/Factory.sol)\n- Own contract for [ENS](https://github.com/airalab/robonomics_contracts/blob/master/contracts/ens/ENS.sol)\n- [Proxy](https://github.com/airalab/robonomics_contracts/blob/master/contracts/misc/SharedCode.sol) for contracts\n- Various modifiers and roles in contracts\n\nAddresses of contracts in the Neon devnet network https://devnet.neonevm.org\n\n| Contract Name  | Address                                    |\n|----------------|--------------------------------------------|\n| Migrations     | 0x1DC538bE2C8572509a571B150f11aB55E52EF12E |\n| ENS            | 0xa7AEa12F60D0278F01e14DBC7cc459d04d051406 |\n| DutchAuction   | 0xF44F8803548D72Dbc3E28340EFD7b5328aa4F058 |\n| Liability      | 0xA694196351dc1488e3884eCc6b650F0d8D55346a |\n| Lighthouse     | 0x80FB5CC4c396E272b56700E6ffF5DBf4661013A8 |\n| XRT            | 0x3322d7D99cF65Cab5A92073c928b5E9674af3c29 |\n| PublicAmbix    | 0x85c03bE5ccFf11E79a0A776D183eF067590549d1 |\n| Factory        | 0xCFa833bF0D46369D9024f95c9C8dFa1E4a07806C |\n| PublicResolver | 0xAC9E9AA8A4cB524FE87f2b14489F1D6bE68dc46e |\n\n[Source code](https://github.com/Multi-Agent-io/neon-kuka-demo) for the scenario\n\n## Changes Made to Original Contracts\n\nThe contracts are written for Solidity 0.5.0. As such, no changes were required when deploying and using the contracts.\n\n## Testing Workflow\n\nIn general, the test consists of sending corresponding messages from one agent to another.\n\nNext, the Promisor finds a new liability contract in the network and begins to execute it. Upon completion of the work, a message is sent with the result, which is then recorded in the contract.\n\nStep-by-step instructions for launching are in [README.md](https://github.com/Multi-Agent-io/neon-kuka-demo/blob/main/README.md)\n\n## Testing Results in Detail\n\nScreencast of the process\n\nhttps://youtu.be/fYJVF7KrNnI\n\n![Liability](./images/testing-neon-with-robonomics/liability.jpg)\n\nWhen the simulation starts, an offer message is created, and a demand message comes from the Promisee, after which a Liability contract is created using the createLiability function of the Lighthouse contract. With the help of the XRT contract, tokens are transferred from the Promisee’s address to the address of the Liability contract.\n\nAfter a new Liability contract has been discovered on the Neon devnet, the agent starts working. The result of the work (telemetry) is written to a file and sent to IPFS, the hash from the file is saved as a result.\n\nAfter the work is completed, the Liability contract is finalized using the finalizeLiability() function of the Lighthouse contract and the tokens are transferred from the Liability address to the addresses of the Promisor and Validator.\n\nThe successful execution of the simulation showed that all contracts worked correctly and the Neon platform works.\n\n## Neon Platform Drawbacks\n\n### Truffle fails if it doesn't get a response from the network\n\nDuring the process of deploying contracts, it turned out that the proxy does not always return a response on time, which is why Truffle ends with an error:\n\n```\nTypeError: Cannot read properties of null (reading 'from')                                    \n    at Web3InterfaceAdapter.<anonymous> (/usr/lib/node_modules/truffle/build/webpack:/packages\n/interface-adapter/dist/adapter/web3/index.js:71:1)                                           \n    at Generator.next (<anonymous>)                                                           \n    at fulfilled (/usr/lib/node_modules/truffle/build/webpack:/packages/interface-adapter/dist\n/adapter/web3/index.js:5:43)                                                                  \n    at runMicrotasks (<anonymous>)\n    at processTicksAndRejections (node:internal/process/task_queues:96:5)\nTruffle v5.5.23 (core: 5.5.23)\nNode v16.14.0\n```\n\nIt was not possible to find a relationship between the test conditions and the occurrence of an error, but most likely Neon EVM cannot send a transaction receipt, and Truffle cannot process a Null response.\n\nIf we add timeout and retry here [index.ts#L75](https://github.com/trufflesuite/truffle/blob/develop/packages/interface-adapter/lib/adapter/web3/index.ts#L75), then the deployment should proceed without errors.\n\n### No WS/WSS Endpoint\n\nNeon EVM does not have a WS/WSS endpoint unlike Ethereum, which makes it impossible to subscribe to events from the network. Therefore, during testing, we monitored the events manually.\n\n### No Event Names\n\nNeon EVM returns rather poor descriptions of events after a transaction, for example:\n\n```\n events: {\n    '0': {\n      address: '0xCFa833bF0D46369D9024f95c9C8dFa1E4a07806C',\n      transactionHash: '0x9894a984e6b3f6ce469c8837e11739f6e50d00216cf7c5bc3d32da106a58d50a',\n      transactionLogIndex: '0x1',\n      blockHash: '0x72040f317d3a469d30327d4e1def903790b70dbede46b4f0ea4f28f30a679a80',\n      blockNumber: 156073183,\n      transactionIndex: 0,\n      logIndex: 1,\n      id: 'log_e51e2f9f',\n      returnValues: Result {},\n      event: undefined,\n      signature: null,\n      raw: [Object]\n    },\n...\n```\n\nInstead of 0, 1, etc. we expected to see named events.\n\n## Conclusion\n\nUsing the Neon EVM platform, a scenario was successfully tested whereby a liability contract between a Promisee and a Promisor is concluded with subsequent validation of the result of the work done by a third party. Additionally, a Provider participated, who checked the coincidence of supply and demand between the parties, and received a commission for this work.\n\nThe demonstration used a simulation of a robotic arm that was hired to perform a sequence of actions. As a result of the work, the robot sent a file with telemetry received during the task.\n\nDespite some peculiarities in the operation of the network, in the end, all participating contracts showed their operability in the Neon environment.\n\n\n\n","cover_image":{"type":"image","mimeType":"image/jpeg","src":"/assets/static/blog_cover_neon_multi-agent.62c183a.6231caf624da0ea84dd55d0582533702.jpg","size":{"width":1500,"height":675},"sizes":"(max-width: 1500px) 100vw, 1500px","srcset":["/assets/static/blog_cover_neon_multi-agent.9ea8d39.6231caf624da0ea84dd55d0582533702.jpg 480w","/assets/static/blog_cover_neon_multi-agent.6b2ed88.6231caf624da0ea84dd55d0582533702.jpg 1024w","/assets/static/blog_cover_neon_multi-agent.62c183a.6231caf624da0ea84dd55d0582533702.jpg 1500w"],"dataUri":"data:image/svg+xml,%3csvg fill='none' viewBox='0 0 1500 675' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'%3e%3cdefs%3e%3cfilter id='__svg-blur-6955165ddd4a470810755efcfe6cef5d'%3e%3cfeGaussianBlur in='SourceGraphic' stdDeviation='40'/%3e%3c/filter%3e%3c/defs%3e%3cimage x='0' y='0' filter='url(%23__svg-blur-6955165ddd4a470810755efcfe6cef5d)' width='1500' height='675' xlink:href='data:image/jpeg%3bbase64%2c/9j/2wBDAAYEBQYFBAYGBQYHBwYIChAKCgkJChQODwwQFxQYGBcUFhYaHSUfGhsjHBYWICwgIyYnKSopGR8tMC0oMCUoKSj/2wBDAQcHBwoIChMKChMoGhYaKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCj/wAARCAAdAEADASIAAhEBAxEB/8QAHAAAAQQDAQAAAAAAAAAAAAAABQIDBAYAAQcI/8QAJxAAAgIBAwQCAgMBAAAAAAAAAQIDEQQABTESEyFBBiJRsTJxgfD/xAAYAQADAQEAAAAAAAAAAAAAAAABAgMABP/EAB0RAAIDAAMBAQAAAAAAAAAAAAECAAMREiExQXH/2gAMAwEAAhEDEQA/APL6xdUDSdX8TVUf3/mmtb62CFQfqfWr/wDKvgMOxxZDR7gJ6EUkRJC0kjKv3HqiSLHjj%2btddVD2glB4NMtVRZaGZRoHc5/p7DiWadY26z1EABF6mJPAA1dF%2bARSQ96L5FtckZkKKik9xqu6W%2bbBoX5Au/WgW%2b7OuyZMKQbhiZ7Pas0B%2bqsKuieR9hTe/P41EEbItpHUCyhVkIQkr6sUdZ2ZfrUbnqXqFC7H51JxExp5HOVM0THwqqtgn%2b/Wuhr8Y7ewyjGDGWAMsUwnKO63bMAFocGlJPHIsWDMPJzF0aM06sp/DCtOTRdtEbqvqF8Ef9xolv8AtuVgSMNwmeTJ7hWyxYFfPmzzehTyM4AY2BxoiY7E6l5ORlZMQlycuabx26kkZiBzXn17rUTSu43b6L%2bvNaIOdQ63gMT/AINWX4JtsGZuGXl56scDb8WTImK0DYWlAv2T%2btVrVr2N0HwbfAYlMgdemSyCtgA%2b64/Oo2ozoVT0ytLIjhn8EGb1LsuRDDNtkOVjZMtmeFyGjiI9IeSDz5quPOimF8rnkx5cWeFCsg6mAmkRZGAFkgMALCiwKBrVT1mmROAzd/YjtzPIybumTkZ8pzcuVXllJJparzZ/eoWltIzIqE/UcDSNPEG/Z//Z' /%3e%3c/svg%3e"},"locale":"ja"}},{"node":{"title":"Testing Neon EVM with Robonomics Smart Contracts","path":"/blog/ko/testing-neon-with-robonomics/","date":"October 3, 2022","description":"The purpose of these tests were to validate the readiness of the Neon platform to move to the production stage using Robonomics smart contracts, which allow cyber-physical systems (robots) to make technical-economic transactions.","content":"\n## TL;DR\n\nThe purpose of these tests were to validate the readiness of the [Neon](https://neon-labs.org/) platform to move to the production stage using Robonomics smart contracts, which allow cyber-physical systems (robots) to make technical-economic transactions.\n\nIn the Robonomics network, interaction is established between two parties: Promisee - the one who orders the service, sends a description of technical task and transfers funds for its execution; Promisor - one who performs a service. A typical scenario was tested, whereby a liability contract is concluded between a Promisee and a Promisor - this was followed by validation of the resulting work by a third party, and a commission payment to the node that accompanied the contract between the parties.\n\nFor this example, a simulation of a robotic arm was used, which was asked to perform a sequence of actions. The tests were successful.\n\n## Scope and Goals of Testing\n\nEngineers of [Multi-Agent Systems](https://multi-agent.io/) have been working with [Robonomics Network](https://robonomics.network/) for several years. The first implementation of the Robonomics Network was created for the Ethereum network. It is a set of smart contracts for machine-to-machine communication.\n\nThe core of the Robonomics Network is the [Liability](https://github.com/airalab/robonomics_contracts/blob/master/contracts/robonomics/Liability.sol) contract, a smart contract that reproduces the typical relationship between the customer of a service (Promisee) and the service provider (Promisor), and includes the technical and economic parameters of the transaction between them. The parties can be either an autonomous agent and a person (human-to-machine interaction), or purely two autonomous agents (machine-to-machine interaction). The Promisee and Promisor broadcast messages with the parameters of their technical-economic transaction, and then the conclusion of the transaction is provided by a special node - the Provider - which looks for matches of these parameters. Providers are controlled by [Lighthouse](https://github.com/airalab/robonomics_contracts/blob/master/contracts/robonomics/Lighthouse.sol), which is a special smart contract that executes a transaction when the provider establishes a market match between the parties.\n\nThere are three scenarios in which the fulfillment of an obligation can take place:\n\n1. A simple commitment (with no verification of the final result, and no commission paid to Provider nodes)\n2. Obligation with a commission paid to the Provider\n3. Commitment with a commission to the Provider and validation of the results with the help of a third party - observing network.\n\nThe purpose of this test is to test the most complex, third Robonomics scenario on the Neon EVM platform.\n\n## Testing Scenarios Description\n\nAs we develop the industrial zones and the infrastructure of modern cities, the emergence of fully automated enterprises and services that are controlled by cyber-physical systems (CPS) and which provide their services as autonomous agents is highly likely. In this regard, we can also expect the formation of networks of autonomous CPS in order to increase the speed and quality of communication in the process of production and provision of services.\n\nIn order to take full advantage of the possibilities of smart contracts, a scenario of interaction between two autonomous economic agents was chosen. Consider the liability life cycle in the Robonomics network:\n\n![Liability Life Cycle](./images/testing-neon-with-robonomics/step-by-step-3.jpg)\n\nThe figure above shows that the Robonomics network provider calls the Lighthouse contract, which in turn calls the [contract factory](https://github.com/airalab/robonomics_contracts/blob/master/contracts/robonomics/Factory.sol) to create the Liability contract. The Liability contract contains data about the transaction, such as the terms of reference, payment for the service, validator address and the deadline.\n\nTo learn more about the possible use cases for Robonomics, check out the Robonomics [R&D](https://wiki.robonomics.network/docs/en/r-and-d-based-on-robonomics-network/#launching-a-drone-under-the-control-of-a-decentralized-computer) page!\n\nTo replicate the entire Robonomics infrastructure on the Neon network, we will implement a robot launch scenario through a Liability contract similar to this [example](https://wiki.robonomics.network/docs/en/kuka/). If the script can be repeated, then all functions will work.\n\n## Deliverables\n\nThe source code for the Robonomics contracts is available [here](https://github.com/airalab/robonomics_contracts).\nThe contracts use many features of the Ethereum VM which includes:\n\n- ERC20 [XRT](https://github.com/airalab/robonomics_contracts/blob/master/contracts/robonomics/XRT.sol) Token\n- [Factory](https://github.com/airalab/robonomics_contracts/blob/master/contracts/robonomics/Factory.sol)\n- Own contract for [ENS](https://github.com/airalab/robonomics_contracts/blob/master/contracts/ens/ENS.sol)\n- [Proxy](https://github.com/airalab/robonomics_contracts/blob/master/contracts/misc/SharedCode.sol) for contracts\n- Various modifiers and roles in contracts\n\nAddresses of contracts in the Neon devnet network https://devnet.neonevm.org\n\n| Contract Name  | Address                                    |\n|----------------|--------------------------------------------|\n| Migrations     | 0x1DC538bE2C8572509a571B150f11aB55E52EF12E |\n| ENS            | 0xa7AEa12F60D0278F01e14DBC7cc459d04d051406 |\n| DutchAuction   | 0xF44F8803548D72Dbc3E28340EFD7b5328aa4F058 |\n| Liability      | 0xA694196351dc1488e3884eCc6b650F0d8D55346a |\n| Lighthouse     | 0x80FB5CC4c396E272b56700E6ffF5DBf4661013A8 |\n| XRT            | 0x3322d7D99cF65Cab5A92073c928b5E9674af3c29 |\n| PublicAmbix    | 0x85c03bE5ccFf11E79a0A776D183eF067590549d1 |\n| Factory        | 0xCFa833bF0D46369D9024f95c9C8dFa1E4a07806C |\n| PublicResolver | 0xAC9E9AA8A4cB524FE87f2b14489F1D6bE68dc46e |\n\n[Source code](https://github.com/Multi-Agent-io/neon-kuka-demo) for the scenario\n\n## Changes Made to Original Contracts\n\nThe contracts are written for Solidity 0.5.0. As such, no changes were required when deploying and using the contracts.\n\n## Testing Workflow\n\nIn general, the test consists of sending corresponding messages from one agent to another.\n\nNext, the Promisor finds a new liability contract in the network and begins to execute it. Upon completion of the work, a message is sent with the result, which is then recorded in the contract.\n\nStep-by-step instructions for launching are in [README.md](https://github.com/Multi-Agent-io/neon-kuka-demo/blob/main/README.md)\n\n## Testing Results in Detail\n\nScreencast of the process\n\nhttps://youtu.be/fYJVF7KrNnI\n\n![Liability](./images/testing-neon-with-robonomics/liability.jpg)\n\nWhen the simulation starts, an offer message is created, and a demand message comes from the Promisee, after which a Liability contract is created using the createLiability function of the Lighthouse contract. With the help of the XRT contract, tokens are transferred from the Promisee’s address to the address of the Liability contract.\n\nAfter a new Liability contract has been discovered on the Neon devnet, the agent starts working. The result of the work (telemetry) is written to a file and sent to IPFS, the hash from the file is saved as a result.\n\nAfter the work is completed, the Liability contract is finalized using the finalizeLiability() function of the Lighthouse contract and the tokens are transferred from the Liability address to the addresses of the Promisor and Validator.\n\nThe successful execution of the simulation showed that all contracts worked correctly and the Neon platform works.\n\n## Neon Platform Drawbacks\n\n### Truffle fails if it doesn't get a response from the network\n\nDuring the process of deploying contracts, it turned out that the proxy does not always return a response on time, which is why Truffle ends with an error:\n\n```\nTypeError: Cannot read properties of null (reading 'from')                                    \n    at Web3InterfaceAdapter.<anonymous> (/usr/lib/node_modules/truffle/build/webpack:/packages\n/interface-adapter/dist/adapter/web3/index.js:71:1)                                           \n    at Generator.next (<anonymous>)                                                           \n    at fulfilled (/usr/lib/node_modules/truffle/build/webpack:/packages/interface-adapter/dist\n/adapter/web3/index.js:5:43)                                                                  \n    at runMicrotasks (<anonymous>)\n    at processTicksAndRejections (node:internal/process/task_queues:96:5)\nTruffle v5.5.23 (core: 5.5.23)\nNode v16.14.0\n```\n\nIt was not possible to find a relationship between the test conditions and the occurrence of an error, but most likely Neon EVM cannot send a transaction receipt, and Truffle cannot process a Null response.\n\nIf we add timeout and retry here [index.ts#L75](https://github.com/trufflesuite/truffle/blob/develop/packages/interface-adapter/lib/adapter/web3/index.ts#L75), then the deployment should proceed without errors.\n\n### No WS/WSS Endpoint\n\nNeon EVM does not have a WS/WSS endpoint unlike Ethereum, which makes it impossible to subscribe to events from the network. Therefore, during testing, we monitored the events manually.\n\n### No Event Names\n\nNeon EVM returns rather poor descriptions of events after a transaction, for example:\n\n```\n events: {\n    '0': {\n      address: '0xCFa833bF0D46369D9024f95c9C8dFa1E4a07806C',\n      transactionHash: '0x9894a984e6b3f6ce469c8837e11739f6e50d00216cf7c5bc3d32da106a58d50a',\n      transactionLogIndex: '0x1',\n      blockHash: '0x72040f317d3a469d30327d4e1def903790b70dbede46b4f0ea4f28f30a679a80',\n      blockNumber: 156073183,\n      transactionIndex: 0,\n      logIndex: 1,\n      id: 'log_e51e2f9f',\n      returnValues: Result {},\n      event: undefined,\n      signature: null,\n      raw: [Object]\n    },\n...\n```\n\nInstead of 0, 1, etc. we expected to see named events.\n\n## Conclusion\n\nUsing the Neon EVM platform, a scenario was successfully tested whereby a liability contract between a Promisee and a Promisor is concluded with subsequent validation of the result of the work done by a third party. Additionally, a Provider participated, who checked the coincidence of supply and demand between the parties, and received a commission for this work.\n\nThe demonstration used a simulation of a robotic arm that was hired to perform a sequence of actions. As a result of the work, the robot sent a file with telemetry received during the task.\n\nDespite some peculiarities in the operation of the network, in the end, all participating contracts showed their operability in the Neon environment.\n\n\n\n","cover_image":{"type":"image","mimeType":"image/jpeg","src":"/assets/static/blog_cover_neon_multi-agent.62c183a.6231caf624da0ea84dd55d0582533702.jpg","size":{"width":1500,"height":675},"sizes":"(max-width: 1500px) 100vw, 1500px","srcset":["/assets/static/blog_cover_neon_multi-agent.9ea8d39.6231caf624da0ea84dd55d0582533702.jpg 480w","/assets/static/blog_cover_neon_multi-agent.6b2ed88.6231caf624da0ea84dd55d0582533702.jpg 1024w","/assets/static/blog_cover_neon_multi-agent.62c183a.6231caf624da0ea84dd55d0582533702.jpg 1500w"],"dataUri":"data:image/svg+xml,%3csvg fill='none' viewBox='0 0 1500 675' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'%3e%3cdefs%3e%3cfilter id='__svg-blur-6955165ddd4a470810755efcfe6cef5d'%3e%3cfeGaussianBlur in='SourceGraphic' stdDeviation='40'/%3e%3c/filter%3e%3c/defs%3e%3cimage x='0' y='0' filter='url(%23__svg-blur-6955165ddd4a470810755efcfe6cef5d)' width='1500' height='675' xlink:href='data:image/jpeg%3bbase64%2c/9j/2wBDAAYEBQYFBAYGBQYHBwYIChAKCgkJChQODwwQFxQYGBcUFhYaHSUfGhsjHBYWICwgIyYnKSopGR8tMC0oMCUoKSj/2wBDAQcHBwoIChMKChMoGhYaKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCj/wAARCAAdAEADASIAAhEBAxEB/8QAHAAAAQQDAQAAAAAAAAAAAAAABQIDBAYAAQcI/8QAJxAAAgIBAwQCAgMBAAAAAAAAAQIDEQQABTESEyFBBiJRsTJxgfD/xAAYAQADAQEAAAAAAAAAAAAAAAABAgMABP/EAB0RAAIDAAMBAQAAAAAAAAAAAAECAAMREiExQXH/2gAMAwEAAhEDEQA/APL6xdUDSdX8TVUf3/mmtb62CFQfqfWr/wDKvgMOxxZDR7gJ6EUkRJC0kjKv3HqiSLHjj%2btddVD2glB4NMtVRZaGZRoHc5/p7DiWadY26z1EABF6mJPAA1dF%2bARSQ96L5FtckZkKKik9xqu6W%2bbBoX5Au/WgW%2b7OuyZMKQbhiZ7Pas0B%2bqsKuieR9hTe/P41EEbItpHUCyhVkIQkr6sUdZ2ZfrUbnqXqFC7H51JxExp5HOVM0THwqqtgn%2b/Wuhr8Y7ewyjGDGWAMsUwnKO63bMAFocGlJPHIsWDMPJzF0aM06sp/DCtOTRdtEbqvqF8Ef9xolv8AtuVgSMNwmeTJ7hWyxYFfPmzzehTyM4AY2BxoiY7E6l5ORlZMQlycuabx26kkZiBzXn17rUTSu43b6L%2bvNaIOdQ63gMT/AINWX4JtsGZuGXl56scDb8WTImK0DYWlAv2T%2btVrVr2N0HwbfAYlMgdemSyCtgA%2b64/Oo2ozoVT0ytLIjhn8EGb1LsuRDDNtkOVjZMtmeFyGjiI9IeSDz5quPOimF8rnkx5cWeFCsg6mAmkRZGAFkgMALCiwKBrVT1mmROAzd/YjtzPIybumTkZ8pzcuVXllJJparzZ/eoWltIzIqE/UcDSNPEG/Z//Z' /%3e%3c/svg%3e"},"locale":"ko"}},{"node":{"title":"Testing Neon EVM with Robonomics Smart Contracts","path":"/blog/pt/testing-neon-with-robonomics/","date":"October 3, 2022","description":"The purpose of these tests were to validate the readiness of the Neon platform to move to the production stage using Robonomics smart contracts, which allow cyber-physical systems (robots) to make technical-economic transactions.","content":"\n## TL;DR\n\nThe purpose of these tests were to validate the readiness of the [Neon](https://neon-labs.org/) platform to move to the production stage using Robonomics smart contracts, which allow cyber-physical systems (robots) to make technical-economic transactions.\n\nIn the Robonomics network, interaction is established between two parties: Promisee - the one who orders the service, sends a description of technical task and transfers funds for its execution; Promisor - one who performs a service. A typical scenario was tested, whereby a liability contract is concluded between a Promisee and a Promisor - this was followed by validation of the resulting work by a third party, and a commission payment to the node that accompanied the contract between the parties.\n\nFor this example, a simulation of a robotic arm was used, which was asked to perform a sequence of actions. The tests were successful.\n\n## Scope and Goals of Testing\n\nEngineers of [Multi-Agent Systems](https://multi-agent.io/) have been working with [Robonomics Network](https://robonomics.network/) for several years. The first implementation of the Robonomics Network was created for the Ethereum network. It is a set of smart contracts for machine-to-machine communication.\n\nThe core of the Robonomics Network is the [Liability](https://github.com/airalab/robonomics_contracts/blob/master/contracts/robonomics/Liability.sol) contract, a smart contract that reproduces the typical relationship between the customer of a service (Promisee) and the service provider (Promisor), and includes the technical and economic parameters of the transaction between them. The parties can be either an autonomous agent and a person (human-to-machine interaction), or purely two autonomous agents (machine-to-machine interaction). The Promisee and Promisor broadcast messages with the parameters of their technical-economic transaction, and then the conclusion of the transaction is provided by a special node - the Provider - which looks for matches of these parameters. Providers are controlled by [Lighthouse](https://github.com/airalab/robonomics_contracts/blob/master/contracts/robonomics/Lighthouse.sol), which is a special smart contract that executes a transaction when the provider establishes a market match between the parties.\n\nThere are three scenarios in which the fulfillment of an obligation can take place:\n\n1. A simple commitment (with no verification of the final result, and no commission paid to Provider nodes)\n2. Obligation with a commission paid to the Provider\n3. Commitment with a commission to the Provider and validation of the results with the help of a third party - observing network.\n\nThe purpose of this test is to test the most complex, third Robonomics scenario on the Neon EVM platform.\n\n## Testing Scenarios Description\n\nAs we develop the industrial zones and the infrastructure of modern cities, the emergence of fully automated enterprises and services that are controlled by cyber-physical systems (CPS) and which provide their services as autonomous agents is highly likely. In this regard, we can also expect the formation of networks of autonomous CPS in order to increase the speed and quality of communication in the process of production and provision of services.\n\nIn order to take full advantage of the possibilities of smart contracts, a scenario of interaction between two autonomous economic agents was chosen. Consider the liability life cycle in the Robonomics network:\n\n![Liability Life Cycle](./images/testing-neon-with-robonomics/step-by-step-3.jpg)\n\nThe figure above shows that the Robonomics network provider calls the Lighthouse contract, which in turn calls the [contract factory](https://github.com/airalab/robonomics_contracts/blob/master/contracts/robonomics/Factory.sol) to create the Liability contract. The Liability contract contains data about the transaction, such as the terms of reference, payment for the service, validator address and the deadline.\n\nTo learn more about the possible use cases for Robonomics, check out the Robonomics [R&D](https://wiki.robonomics.network/docs/en/r-and-d-based-on-robonomics-network/#launching-a-drone-under-the-control-of-a-decentralized-computer) page!\n\nTo replicate the entire Robonomics infrastructure on the Neon network, we will implement a robot launch scenario through a Liability contract similar to this [example](https://wiki.robonomics.network/docs/en/kuka/). If the script can be repeated, then all functions will work.\n\n## Deliverables\n\nThe source code for the Robonomics contracts is available [here](https://github.com/airalab/robonomics_contracts).\nThe contracts use many features of the Ethereum VM which includes:\n\n- ERC20 [XRT](https://github.com/airalab/robonomics_contracts/blob/master/contracts/robonomics/XRT.sol) Token\n- [Factory](https://github.com/airalab/robonomics_contracts/blob/master/contracts/robonomics/Factory.sol)\n- Own contract for [ENS](https://github.com/airalab/robonomics_contracts/blob/master/contracts/ens/ENS.sol)\n- [Proxy](https://github.com/airalab/robonomics_contracts/blob/master/contracts/misc/SharedCode.sol) for contracts\n- Various modifiers and roles in contracts\n\nAddresses of contracts in the Neon devnet network https://devnet.neonevm.org\n\n| Contract Name  | Address                                    |\n|----------------|--------------------------------------------|\n| Migrations     | 0x1DC538bE2C8572509a571B150f11aB55E52EF12E |\n| ENS            | 0xa7AEa12F60D0278F01e14DBC7cc459d04d051406 |\n| DutchAuction   | 0xF44F8803548D72Dbc3E28340EFD7b5328aa4F058 |\n| Liability      | 0xA694196351dc1488e3884eCc6b650F0d8D55346a |\n| Lighthouse     | 0x80FB5CC4c396E272b56700E6ffF5DBf4661013A8 |\n| XRT            | 0x3322d7D99cF65Cab5A92073c928b5E9674af3c29 |\n| PublicAmbix    | 0x85c03bE5ccFf11E79a0A776D183eF067590549d1 |\n| Factory        | 0xCFa833bF0D46369D9024f95c9C8dFa1E4a07806C |\n| PublicResolver | 0xAC9E9AA8A4cB524FE87f2b14489F1D6bE68dc46e |\n\n[Source code](https://github.com/Multi-Agent-io/neon-kuka-demo) for the scenario\n\n## Changes Made to Original Contracts\n\nThe contracts are written for Solidity 0.5.0. As such, no changes were required when deploying and using the contracts.\n\n## Testing Workflow\n\nIn general, the test consists of sending corresponding messages from one agent to another.\n\nNext, the Promisor finds a new liability contract in the network and begins to execute it. Upon completion of the work, a message is sent with the result, which is then recorded in the contract.\n\nStep-by-step instructions for launching are in [README.md](https://github.com/Multi-Agent-io/neon-kuka-demo/blob/main/README.md)\n\n## Testing Results in Detail\n\nScreencast of the process\n\nhttps://youtu.be/fYJVF7KrNnI\n\n![Liability](./images/testing-neon-with-robonomics/liability.jpg)\n\nWhen the simulation starts, an offer message is created, and a demand message comes from the Promisee, after which a Liability contract is created using the createLiability function of the Lighthouse contract. With the help of the XRT contract, tokens are transferred from the Promisee’s address to the address of the Liability contract.\n\nAfter a new Liability contract has been discovered on the Neon devnet, the agent starts working. The result of the work (telemetry) is written to a file and sent to IPFS, the hash from the file is saved as a result.\n\nAfter the work is completed, the Liability contract is finalized using the finalizeLiability() function of the Lighthouse contract and the tokens are transferred from the Liability address to the addresses of the Promisor and Validator.\n\nThe successful execution of the simulation showed that all contracts worked correctly and the Neon platform works.\n\n## Neon Platform Drawbacks\n\n### Truffle fails if it doesn't get a response from the network\n\nDuring the process of deploying contracts, it turned out that the proxy does not always return a response on time, which is why Truffle ends with an error:\n\n```\nTypeError: Cannot read properties of null (reading 'from')                                    \n    at Web3InterfaceAdapter.<anonymous> (/usr/lib/node_modules/truffle/build/webpack:/packages\n/interface-adapter/dist/adapter/web3/index.js:71:1)                                           \n    at Generator.next (<anonymous>)                                                           \n    at fulfilled (/usr/lib/node_modules/truffle/build/webpack:/packages/interface-adapter/dist\n/adapter/web3/index.js:5:43)                                                                  \n    at runMicrotasks (<anonymous>)\n    at processTicksAndRejections (node:internal/process/task_queues:96:5)\nTruffle v5.5.23 (core: 5.5.23)\nNode v16.14.0\n```\n\nIt was not possible to find a relationship between the test conditions and the occurrence of an error, but most likely Neon EVM cannot send a transaction receipt, and Truffle cannot process a Null response.\n\nIf we add timeout and retry here [index.ts#L75](https://github.com/trufflesuite/truffle/blob/develop/packages/interface-adapter/lib/adapter/web3/index.ts#L75), then the deployment should proceed without errors.\n\n### No WS/WSS Endpoint\n\nNeon EVM does not have a WS/WSS endpoint unlike Ethereum, which makes it impossible to subscribe to events from the network. Therefore, during testing, we monitored the events manually.\n\n### No Event Names\n\nNeon EVM returns rather poor descriptions of events after a transaction, for example:\n\n```\n events: {\n    '0': {\n      address: '0xCFa833bF0D46369D9024f95c9C8dFa1E4a07806C',\n      transactionHash: '0x9894a984e6b3f6ce469c8837e11739f6e50d00216cf7c5bc3d32da106a58d50a',\n      transactionLogIndex: '0x1',\n      blockHash: '0x72040f317d3a469d30327d4e1def903790b70dbede46b4f0ea4f28f30a679a80',\n      blockNumber: 156073183,\n      transactionIndex: 0,\n      logIndex: 1,\n      id: 'log_e51e2f9f',\n      returnValues: Result {},\n      event: undefined,\n      signature: null,\n      raw: [Object]\n    },\n...\n```\n\nInstead of 0, 1, etc. we expected to see named events.\n\n## Conclusion\n\nUsing the Neon EVM platform, a scenario was successfully tested whereby a liability contract between a Promisee and a Promisor is concluded with subsequent validation of the result of the work done by a third party. Additionally, a Provider participated, who checked the coincidence of supply and demand between the parties, and received a commission for this work.\n\nThe demonstration used a simulation of a robotic arm that was hired to perform a sequence of actions. As a result of the work, the robot sent a file with telemetry received during the task.\n\nDespite some peculiarities in the operation of the network, in the end, all participating contracts showed their operability in the Neon environment.\n\n\n\n","cover_image":{"type":"image","mimeType":"image/jpeg","src":"/assets/static/blog_cover_neon_multi-agent.62c183a.6231caf624da0ea84dd55d0582533702.jpg","size":{"width":1500,"height":675},"sizes":"(max-width: 1500px) 100vw, 1500px","srcset":["/assets/static/blog_cover_neon_multi-agent.9ea8d39.6231caf624da0ea84dd55d0582533702.jpg 480w","/assets/static/blog_cover_neon_multi-agent.6b2ed88.6231caf624da0ea84dd55d0582533702.jpg 1024w","/assets/static/blog_cover_neon_multi-agent.62c183a.6231caf624da0ea84dd55d0582533702.jpg 1500w"],"dataUri":"data:image/svg+xml,%3csvg fill='none' viewBox='0 0 1500 675' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'%3e%3cdefs%3e%3cfilter id='__svg-blur-6955165ddd4a470810755efcfe6cef5d'%3e%3cfeGaussianBlur in='SourceGraphic' stdDeviation='40'/%3e%3c/filter%3e%3c/defs%3e%3cimage x='0' y='0' filter='url(%23__svg-blur-6955165ddd4a470810755efcfe6cef5d)' width='1500' height='675' xlink:href='data:image/jpeg%3bbase64%2c/9j/2wBDAAYEBQYFBAYGBQYHBwYIChAKCgkJChQODwwQFxQYGBcUFhYaHSUfGhsjHBYWICwgIyYnKSopGR8tMC0oMCUoKSj/2wBDAQcHBwoIChMKChMoGhYaKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCj/wAARCAAdAEADASIAAhEBAxEB/8QAHAAAAQQDAQAAAAAAAAAAAAAABQIDBAYAAQcI/8QAJxAAAgIBAwQCAgMBAAAAAAAAAQIDEQQABTESEyFBBiJRsTJxgfD/xAAYAQADAQEAAAAAAAAAAAAAAAABAgMABP/EAB0RAAIDAAMBAQAAAAAAAAAAAAECAAMREiExQXH/2gAMAwEAAhEDEQA/APL6xdUDSdX8TVUf3/mmtb62CFQfqfWr/wDKvgMOxxZDR7gJ6EUkRJC0kjKv3HqiSLHjj%2btddVD2glB4NMtVRZaGZRoHc5/p7DiWadY26z1EABF6mJPAA1dF%2bARSQ96L5FtckZkKKik9xqu6W%2bbBoX5Au/WgW%2b7OuyZMKQbhiZ7Pas0B%2bqsKuieR9hTe/P41EEbItpHUCyhVkIQkr6sUdZ2ZfrUbnqXqFC7H51JxExp5HOVM0THwqqtgn%2b/Wuhr8Y7ewyjGDGWAMsUwnKO63bMAFocGlJPHIsWDMPJzF0aM06sp/DCtOTRdtEbqvqF8Ef9xolv8AtuVgSMNwmeTJ7hWyxYFfPmzzehTyM4AY2BxoiY7E6l5ORlZMQlycuabx26kkZiBzXn17rUTSu43b6L%2bvNaIOdQ63gMT/AINWX4JtsGZuGXl56scDb8WTImK0DYWlAv2T%2btVrVr2N0HwbfAYlMgdemSyCtgA%2b64/Oo2ozoVT0ytLIjhn8EGb1LsuRDDNtkOVjZMtmeFyGjiI9IeSDz5quPOimF8rnkx5cWeFCsg6mAmkRZGAFkgMALCiwKBrVT1mmROAzd/YjtzPIybumTkZ8pzcuVXllJJparzZ/eoWltIzIqE/UcDSNPEG/Z//Z' /%3e%3c/svg%3e"},"locale":"pt"}},{"node":{"title":"Testing Neon EVM with Robonomics Smart Contracts","path":"/blog/zh/testing-neon-with-robonomics/","date":"October 3, 2022","description":"The purpose of these tests were to validate the readiness of the Neon platform to move to the production stage using Robonomics smart contracts, which allow cyber-physical systems (robots) to make technical-economic transactions.","content":"\n## TL;DR\n\nThe purpose of these tests were to validate the readiness of the [Neon](https://neon-labs.org/) platform to move to the production stage using Robonomics smart contracts, which allow cyber-physical systems (robots) to make technical-economic transactions.\n\nIn the Robonomics network, interaction is established between two parties: Promisee - the one who orders the service, sends a description of technical task and transfers funds for its execution; Promisor - one who performs a service. A typical scenario was tested, whereby a liability contract is concluded between a Promisee and a Promisor - this was followed by validation of the resulting work by a third party, and a commission payment to the node that accompanied the contract between the parties.\n\nFor this example, a simulation of a robotic arm was used, which was asked to perform a sequence of actions. The tests were successful.\n\n## Scope and Goals of Testing\n\nEngineers of [Multi-Agent Systems](https://multi-agent.io/) have been working with [Robonomics Network](https://robonomics.network/) for several years. The first implementation of the Robonomics Network was created for the Ethereum network. It is a set of smart contracts for machine-to-machine communication.\n\nThe core of the Robonomics Network is the [Liability](https://github.com/airalab/robonomics_contracts/blob/master/contracts/robonomics/Liability.sol) contract, a smart contract that reproduces the typical relationship between the customer of a service (Promisee) and the service provider (Promisor), and includes the technical and economic parameters of the transaction between them. The parties can be either an autonomous agent and a person (human-to-machine interaction), or purely two autonomous agents (machine-to-machine interaction). The Promisee and Promisor broadcast messages with the parameters of their technical-economic transaction, and then the conclusion of the transaction is provided by a special node - the Provider - which looks for matches of these parameters. Providers are controlled by [Lighthouse](https://github.com/airalab/robonomics_contracts/blob/master/contracts/robonomics/Lighthouse.sol), which is a special smart contract that executes a transaction when the provider establishes a market match between the parties.\n\nThere are three scenarios in which the fulfillment of an obligation can take place:\n\n1. A simple commitment (with no verification of the final result, and no commission paid to Provider nodes)\n2. Obligation with a commission paid to the Provider\n3. Commitment with a commission to the Provider and validation of the results with the help of a third party - observing network.\n\nThe purpose of this test is to test the most complex, third Robonomics scenario on the Neon EVM platform.\n\n## Testing Scenarios Description\n\nAs we develop the industrial zones and the infrastructure of modern cities, the emergence of fully automated enterprises and services that are controlled by cyber-physical systems (CPS) and which provide their services as autonomous agents is highly likely. In this regard, we can also expect the formation of networks of autonomous CPS in order to increase the speed and quality of communication in the process of production and provision of services.\n\nIn order to take full advantage of the possibilities of smart contracts, a scenario of interaction between two autonomous economic agents was chosen. Consider the liability life cycle in the Robonomics network:\n\n![Liability Life Cycle](./images/testing-neon-with-robonomics/step-by-step-3.jpg)\n\nThe figure above shows that the Robonomics network provider calls the Lighthouse contract, which in turn calls the [contract factory](https://github.com/airalab/robonomics_contracts/blob/master/contracts/robonomics/Factory.sol) to create the Liability contract. The Liability contract contains data about the transaction, such as the terms of reference, payment for the service, validator address and the deadline.\n\nTo learn more about the possible use cases for Robonomics, check out the Robonomics [R&D](https://wiki.robonomics.network/docs/en/r-and-d-based-on-robonomics-network/#launching-a-drone-under-the-control-of-a-decentralized-computer) page!\n\nTo replicate the entire Robonomics infrastructure on the Neon network, we will implement a robot launch scenario through a Liability contract similar to this [example](https://wiki.robonomics.network/docs/en/kuka/). If the script can be repeated, then all functions will work.\n\n## Deliverables\n\nThe source code for the Robonomics contracts is available [here](https://github.com/airalab/robonomics_contracts).\nThe contracts use many features of the Ethereum VM which includes:\n\n- ERC20 [XRT](https://github.com/airalab/robonomics_contracts/blob/master/contracts/robonomics/XRT.sol) Token\n- [Factory](https://github.com/airalab/robonomics_contracts/blob/master/contracts/robonomics/Factory.sol)\n- Own contract for [ENS](https://github.com/airalab/robonomics_contracts/blob/master/contracts/ens/ENS.sol)\n- [Proxy](https://github.com/airalab/robonomics_contracts/blob/master/contracts/misc/SharedCode.sol) for contracts\n- Various modifiers and roles in contracts\n\nAddresses of contracts in the Neon devnet network https://devnet.neonevm.org\n\n| Contract Name  | Address                                    |\n|----------------|--------------------------------------------|\n| Migrations     | 0x1DC538bE2C8572509a571B150f11aB55E52EF12E |\n| ENS            | 0xa7AEa12F60D0278F01e14DBC7cc459d04d051406 |\n| DutchAuction   | 0xF44F8803548D72Dbc3E28340EFD7b5328aa4F058 |\n| Liability      | 0xA694196351dc1488e3884eCc6b650F0d8D55346a |\n| Lighthouse     | 0x80FB5CC4c396E272b56700E6ffF5DBf4661013A8 |\n| XRT            | 0x3322d7D99cF65Cab5A92073c928b5E9674af3c29 |\n| PublicAmbix    | 0x85c03bE5ccFf11E79a0A776D183eF067590549d1 |\n| Factory        | 0xCFa833bF0D46369D9024f95c9C8dFa1E4a07806C |\n| PublicResolver | 0xAC9E9AA8A4cB524FE87f2b14489F1D6bE68dc46e |\n\n[Source code](https://github.com/Multi-Agent-io/neon-kuka-demo) for the scenario\n\n## Changes Made to Original Contracts\n\nThe contracts are written for Solidity 0.5.0. As such, no changes were required when deploying and using the contracts.\n\n## Testing Workflow\n\nIn general, the test consists of sending corresponding messages from one agent to another.\n\nNext, the Promisor finds a new liability contract in the network and begins to execute it. Upon completion of the work, a message is sent with the result, which is then recorded in the contract.\n\nStep-by-step instructions for launching are in [README.md](https://github.com/Multi-Agent-io/neon-kuka-demo/blob/main/README.md)\n\n## Testing Results in Detail\n\nScreencast of the process\n\nhttps://youtu.be/fYJVF7KrNnI\n\n![Liability](./images/testing-neon-with-robonomics/liability.jpg)\n\nWhen the simulation starts, an offer message is created, and a demand message comes from the Promisee, after which a Liability contract is created using the createLiability function of the Lighthouse contract. With the help of the XRT contract, tokens are transferred from the Promisee’s address to the address of the Liability contract.\n\nAfter a new Liability contract has been discovered on the Neon devnet, the agent starts working. The result of the work (telemetry) is written to a file and sent to IPFS, the hash from the file is saved as a result.\n\nAfter the work is completed, the Liability contract is finalized using the finalizeLiability() function of the Lighthouse contract and the tokens are transferred from the Liability address to the addresses of the Promisor and Validator.\n\nThe successful execution of the simulation showed that all contracts worked correctly and the Neon platform works.\n\n## Neon Platform Drawbacks\n\n### Truffle fails if it doesn't get a response from the network\n\nDuring the process of deploying contracts, it turned out that the proxy does not always return a response on time, which is why Truffle ends with an error:\n\n```\nTypeError: Cannot read properties of null (reading 'from')                                    \n    at Web3InterfaceAdapter.<anonymous> (/usr/lib/node_modules/truffle/build/webpack:/packages\n/interface-adapter/dist/adapter/web3/index.js:71:1)                                           \n    at Generator.next (<anonymous>)                                                           \n    at fulfilled (/usr/lib/node_modules/truffle/build/webpack:/packages/interface-adapter/dist\n/adapter/web3/index.js:5:43)                                                                  \n    at runMicrotasks (<anonymous>)\n    at processTicksAndRejections (node:internal/process/task_queues:96:5)\nTruffle v5.5.23 (core: 5.5.23)\nNode v16.14.0\n```\n\nIt was not possible to find a relationship between the test conditions and the occurrence of an error, but most likely Neon EVM cannot send a transaction receipt, and Truffle cannot process a Null response.\n\nIf we add timeout and retry here [index.ts#L75](https://github.com/trufflesuite/truffle/blob/develop/packages/interface-adapter/lib/adapter/web3/index.ts#L75), then the deployment should proceed without errors.\n\n### No WS/WSS Endpoint\n\nNeon EVM does not have a WS/WSS endpoint unlike Ethereum, which makes it impossible to subscribe to events from the network. Therefore, during testing, we monitored the events manually.\n\n### No Event Names\n\nNeon EVM returns rather poor descriptions of events after a transaction, for example:\n\n```\n events: {\n    '0': {\n      address: '0xCFa833bF0D46369D9024f95c9C8dFa1E4a07806C',\n      transactionHash: '0x9894a984e6b3f6ce469c8837e11739f6e50d00216cf7c5bc3d32da106a58d50a',\n      transactionLogIndex: '0x1',\n      blockHash: '0x72040f317d3a469d30327d4e1def903790b70dbede46b4f0ea4f28f30a679a80',\n      blockNumber: 156073183,\n      transactionIndex: 0,\n      logIndex: 1,\n      id: 'log_e51e2f9f',\n      returnValues: Result {},\n      event: undefined,\n      signature: null,\n      raw: [Object]\n    },\n...\n```\n\nInstead of 0, 1, etc. we expected to see named events.\n\n## Conclusion\n\nUsing the Neon EVM platform, a scenario was successfully tested whereby a liability contract between a Promisee and a Promisor is concluded with subsequent validation of the result of the work done by a third party. Additionally, a Provider participated, who checked the coincidence of supply and demand between the parties, and received a commission for this work.\n\nThe demonstration used a simulation of a robotic arm that was hired to perform a sequence of actions. As a result of the work, the robot sent a file with telemetry received during the task.\n\nDespite some peculiarities in the operation of the network, in the end, all participating contracts showed their operability in the Neon environment.\n\n\n\n","cover_image":{"type":"image","mimeType":"image/jpeg","src":"/assets/static/blog_cover_neon_multi-agent.62c183a.6231caf624da0ea84dd55d0582533702.jpg","size":{"width":1500,"height":675},"sizes":"(max-width: 1500px) 100vw, 1500px","srcset":["/assets/static/blog_cover_neon_multi-agent.9ea8d39.6231caf624da0ea84dd55d0582533702.jpg 480w","/assets/static/blog_cover_neon_multi-agent.6b2ed88.6231caf624da0ea84dd55d0582533702.jpg 1024w","/assets/static/blog_cover_neon_multi-agent.62c183a.6231caf624da0ea84dd55d0582533702.jpg 1500w"],"dataUri":"data:image/svg+xml,%3csvg fill='none' viewBox='0 0 1500 675' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'%3e%3cdefs%3e%3cfilter id='__svg-blur-6955165ddd4a470810755efcfe6cef5d'%3e%3cfeGaussianBlur in='SourceGraphic' stdDeviation='40'/%3e%3c/filter%3e%3c/defs%3e%3cimage x='0' y='0' filter='url(%23__svg-blur-6955165ddd4a470810755efcfe6cef5d)' width='1500' height='675' xlink:href='data:image/jpeg%3bbase64%2c/9j/2wBDAAYEBQYFBAYGBQYHBwYIChAKCgkJChQODwwQFxQYGBcUFhYaHSUfGhsjHBYWICwgIyYnKSopGR8tMC0oMCUoKSj/2wBDAQcHBwoIChMKChMoGhYaKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCj/wAARCAAdAEADASIAAhEBAxEB/8QAHAAAAQQDAQAAAAAAAAAAAAAABQIDBAYAAQcI/8QAJxAAAgIBAwQCAgMBAAAAAAAAAQIDEQQABTESEyFBBiJRsTJxgfD/xAAYAQADAQEAAAAAAAAAAAAAAAABAgMABP/EAB0RAAIDAAMBAQAAAAAAAAAAAAECAAMREiExQXH/2gAMAwEAAhEDEQA/APL6xdUDSdX8TVUf3/mmtb62CFQfqfWr/wDKvgMOxxZDR7gJ6EUkRJC0kjKv3HqiSLHjj%2btddVD2glB4NMtVRZaGZRoHc5/p7DiWadY26z1EABF6mJPAA1dF%2bARSQ96L5FtckZkKKik9xqu6W%2bbBoX5Au/WgW%2b7OuyZMKQbhiZ7Pas0B%2bqsKuieR9hTe/P41EEbItpHUCyhVkIQkr6sUdZ2ZfrUbnqXqFC7H51JxExp5HOVM0THwqqtgn%2b/Wuhr8Y7ewyjGDGWAMsUwnKO63bMAFocGlJPHIsWDMPJzF0aM06sp/DCtOTRdtEbqvqF8Ef9xolv8AtuVgSMNwmeTJ7hWyxYFfPmzzehTyM4AY2BxoiY7E6l5ORlZMQlycuabx26kkZiBzXn17rUTSu43b6L%2bvNaIOdQ63gMT/AINWX4JtsGZuGXl56scDb8WTImK0DYWlAv2T%2btVrVr2N0HwbfAYlMgdemSyCtgA%2b64/Oo2ozoVT0ytLIjhn8EGb1LsuRDDNtkOVjZMtmeFyGjiI9IeSDz5quPOimF8rnkx5cWeFCsg6mAmkRZGAFkgMALCiwKBrVT1mmROAzd/YjtzPIybumTkZ8pzcuVXllJJparzZ/eoWltIzIqE/UcDSNPEG/Z//Z' /%3e%3c/svg%3e"},"locale":"zh"}},{"node":{"title":"Robonomics & Crust Networks Strategic Partnership!","path":"/blog/robonomics-and-crust-networks-strategic-partnership/","date":"July 22, 2022","description":" This partnership means there will be much deeper integration between the Crust and Robonomics parachains on Kusama, as well as an interesting new approach for cross-chain collaboration to simplify the user experience.","content":"\nimport RoboList from '~/components/blocks/List.vue'\nimport RoboListItem from '~/components/blocks/ListItem.vue'\n\nWe are happy to announce that Crust and Robonomics have started collaborating to bring resilient data storage infrastructure to robotics and smart devices. This partnership means there will be much deeper integration between the Crust and Robonomics parachains on Kusama, as well as an interesting new approach for cross-chain collaboration to simplify the user experience.\n\nThere are two main objectives that we are looking to achieve together:\n\n<robo-list>\n    <robo-list-item>\n        The resilient storage of data that comes from Internet of Things (IoT) and robotics devices. Currently, the Robonomics parachain uses IPFS both on our robotics controllers and centralized pinning services to make it persistent. Having access to Crust’s decentralized pinning service will offer users cryptographic proofs of storage in many redundant storage locations.\n    </robo-list-item>\n    <robo-list-item>\n        Decentralized hosting of dApps. This is something that was not available before, and as a result, Robonomics dApps had to be hosted by traditional cloud providers or using owned hardware. With Crust, dApps can have decentralized hosting, which guarantees that services will remain available. The fact that developers can create services with no single point of failure, that will remain available for users globally, is extremely important for robotics and any physical world deployments in general.\n    </robo-list-item>\n</robo-list>\n\n<p align=\"center\">\n  <img src=\"./images/robonomics-and-crust-networks-strategic-partnership/spot.gif\">\n</p>\n\nRobonomics team has already started exploring Crust Network and has been impressed by the diligent approach to documentation. You can already launch a [Boston Dynamics robot in Bay Area lab](https://spot.merklebot.com) via a Robonomics parachain transaction, whilst the data will be recorded on Crust. Feel free to try it out for yourself on [spot.merklebot.com](https://spot.merklebot.com).\n\n![Demo web app](./images/robonomics-and-crust-networks-strategic-partnership/demo.png)\n\nNow, we will focus on XCM integration between the Crust Shadow and Robonomics parachains. This will allow us to send transactions for storage directly from smart devices in a fully decentralized way. It should be noted that there is an interesting set of questions related to transaction fees when services are delivered by one parachain to another, which needs to be answered.\n\nWe believe that the user should only pay for a transaction within the parachain they were using. In our case, when a Robonomics parachain user wants to save the data from robotics and smart devices to the Crust Network - they will only have to pay for services in XRT.\n\nThe Robonomics parachain is working on deploying a special pallet that would be able to send a transaction to Crust Shadow with the requirement to save the data and pay from the Robonomics parachain account directly in CSM tokens.  The user will be charged some XRT to compensate for the storage cost automatically.\n\nEventually, parachains will automatically sell native tokens on a DEX to replenish the balance of other parachain tokens that offer additional services. It is mindblowing to realize that this fully decentralized and autonomous scenario is already realistic!\n\nWe are looking forward to an exciting future collaborating on truly decentralized solutions in the field of robotics, IoT and smart devices.\n\n## About Crust\n\nCrust Network is a versatile, purpose-built storage blockchain that delivers truly decentralized file storage and hosting capabilities for the entire Web3 ecosystem, empowering privacy and data ownership. Crust Network enables dApp hosting, NFT metadata storage and encrypted file storage across a wide range of blockchains as well as business cases.\n\nJoin Crust Network now and enjoy access to around 1,000Pb storage across more than 2,300 nodes!\n\n[Website](https://crust.network/) | [Twitter](https://twitter.com/CommunityCrust) |[Wiki](https://wiki.crust.network/) | [Telegram](https://t.me/CrustNetwork) |[GitHub](https://github.com/crustio) | [Facebook](https://www.facebook.com/CrustNetwork/) | [Discord](https://discord.gg/wjDDpb5)\n\n[Decentralized Cloud Foundation](https://decloudf.com/) | [Uniswap](https://medium.com/crustnetwork/decentralized-uniswap-interface-hosting-on-ipfs-18a78d1209ac) | [Polkadot](https://dotapps.io/) | [NFTs](https://medium.com/@bluna.io/bluna-future-of-metaverse-b7fc96fcff6a)\n\n## About Robonomics\n\nRobonomics is an open-source platform for IoT applications. We support a new generation of internet technologies (web3) that implements the exchange of technical and economic information in the form of atomic transactions between user applications, IoT services, and complex robotics.\n\nRobonomics contains a complete set of tools for developing IoT applications, both on the robotics and the user interface sides. Communication between the user and device happens using the most successful technologies from the Web3 world – IPFS, Ethereum, and Polkadot. Thus, developers can create modern and secure applications from Smart Home to Industry 4.0.\n\n[Website](https://robonomics.network) | [Twitter](https://twitter.com/AIRA_Robonomics) | [GitHub](https://github.com/airalab/) | [Wiki](https://wiki.robonomics.network/en/) | [Discord](https://discord.gg/PuBEDkTzSx) | [Blog](https://robonomics.network/blog/)\n","cover_image":{"type":"image","mimeType":"image/png","src":"/assets/static/cover.62c183a.1ab2ecde50db774cf2a9561594cc3e16.png","size":{"width":1500,"height":676},"sizes":"(max-width: 1500px) 100vw, 1500px","srcset":["/assets/static/cover.9ea8d39.1ab2ecde50db774cf2a9561594cc3e16.png 480w","/assets/static/cover.6b2ed88.1ab2ecde50db774cf2a9561594cc3e16.png 1024w","/assets/static/cover.62c183a.1ab2ecde50db774cf2a9561594cc3e16.png 1500w"],"dataUri":"data:image/svg+xml,%3csvg fill='none' viewBox='0 0 1500 676' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'%3e%3cdefs%3e%3cfilter id='__svg-blur-1eca63c1d8492d6fa97b2bdbe715f8ea'%3e%3cfeGaussianBlur in='SourceGraphic' stdDeviation='40'/%3e%3c/filter%3e%3c/defs%3e%3cimage x='0' y='0' filter='url(%23__svg-blur-1eca63c1d8492d6fa97b2bdbe715f8ea)' width='1500' height='676' xlink:href='data:image/png%3bbase64%2ciVBORw0KGgoAAAANSUhEUgAAAEAAAAAdCAYAAAAaeWr3AAAACXBIWXMAAAsTAAALEwEAmpwYAAAGZElEQVRYhe1Ya0yTVxjuNucFodAL0Avt169F5OK46Iw6cS6Zyfgxt%2biyzQmUAkVFmTcEVBBBQKAUQZ0OEx0OYXO6ZF6i07lkGHROE4dsM5mKm8mWmMz9mH%2bU79I%2byzltoYXCYFkYXn48Ofev533O877nPZUYFdkYfWSBkWUjXm1Gd7EBaFCgpy4MvH30IXlKgOKpAjBSElhSyrNoySqtffUnxgXkLoONIZkwBab5EPLYE8B6TjrEAka/Guo51TAGZ4yQhEeUANZjpNIKU1A6IuI2Q7GkFcZgSy8xjz0BrIeE0BzoTevBhi%2bnJVHE8FXwCBLA%2bvi%2bhRrNROTBFGKBLqoABtVyGGWZw1SBmwBNBm6XsIMSwNWFDtkeXQXI3cbLMmFQraBGEyIMQWYY1H3t4akgC4zcitjQpbhZqAEaleixDWJ8vcoFe7j/tj3cPTe8Dz5zvNr1qgEkSkZ8%2brJM6KYW0rYuuhALMtpgCkiFPjIfBu2qIUlg5Vm0NCmzoQ00I2VuCf5qfgNirRSc2yCywd5NknrVJHCVE8BtnwyuTumqVz4PrjoQnE0BrkbqIqE2xA0ZuMrxrjk1wXSctqvINwIG/IZkpNInsifGRk1YgvG5p1DW3oOU6cVQB5nBxBT55ASDERAZloPQ595B3oo2oKseD8rHg69X%2b5w83WRtCIQza%2bD49RsIn7wOvlEP4eQyCKfzILS%2bBn4nC/7gfHDVQeCbEsHvSwK/NxbCyRwIp1eB3z8LfPM8CCesEI5lQPhsETibfGQKYL1IoKcesxEmqRn6hFJIWu5hx8Ue7N5xCZpJqTAY1oIxrPGrAo/xnlLx7NvIsTQDlyvwsHwcuH4%2bTjbq6DoE55834Lh%2bBOKFGjpODBPOrIWj%2bysIZ9fD8UMbuFIJxHMFEDuqIH6/34X2MkoOIcrxy9dw/H4ZwonskRHA9g987FowzGqYJqcioPIyJJ/ex8bWu7hy9SHeWtgA1fglYGI20hvCX3bIhGQiTpeLA3vP4mhbBy5euAXc64LYdQiOH9vA74kBZ5O5iKhXwfHzcfAHZoPbJAFX/gz4D%2bOpocKZdXDcPEWJEDs/ouNEFeL5bRAv2iBeOwjxQjX4llfBlUggHLNQQrgtEqq0YbkA2//aC1sGXXQRTAFLEZ7SBOnO%2b2BTbyNu4Q3klP%2bBuqbbiNXmQq/OpS5CskR/KjAprZgzLR%2bJhpUoyj8CXNuFnkajS77uzfUq4G4nVQExhG9ZQA1x/HYJ4rf1tOQPvgLHnXbwDREQv2ugxvO7IyF8/i4c149C7GymBIjnCiFe%2bQBc1UR3cByOAuRZvZsnSY/euB4GzUqa9ekTajAleheiInfAFN0IDVOPhBl7EG/Kh4HMjSoAG5bj6wpeLkCUIJUsxrKsj4Gr1XhQKgFvkw9wASJhx53zcIo8xPat4JuTIXxhpoFR7NgOvikBYkc1HD8dhtjVQn2exAyqgM5mCK0p4CrGQTj8JoTjmTRw9t0e/0AA65Xy6qZsoFkfNYjIW5oONiQVBlka2JA0mORp0EtTwcgy6VqSE2hnlFPV%2bIsDkWFWqCem4r1FjRC/zHNFeK8g6LnWaD8hYl%2bSK5oTktw%2bTCM8uRXIHBL9ya1ASnIzkJuAzPfcEGRdrWzgLWN3E%2bDzuvMGSXkD06Fc3AzVy3Yw%2bvepvPWRGwaAmbLBPZYPhlkDedphRMRtogGz/3ddiZAVL6jScWuz3m8i5IkDHmP7n5xPXtDb9p7javuoyk8iJRmSAM%2bYJ8NTWocNsmawb/ZlgkOnwn0bDv/XGeGwCDB6JTlGaYarDM7oVzdTF%2bite8YISD8B6Q%2b29PWTuaTtvc7tJmPqLcAS40lwi8yHar4d2sStUCfboJ5bC23SVqhfqqHPXs2L22hdM6uKlhHxJdAmlSFi2mYKzxhZr5lZAc3s7S7MrIA6uRaq%2bfXQxRTR9wNJhcceAcZ11FDt9DKo59mgmldHgxkxgBBDDSFkJNfSUpuwhc7VJpZCN7WAGkhII%2b8CAtXLdXSckELII3FEF7sJJpmFxoAxQ4DRxwXMXvLt7wJe/cH%2bXMAteU/fI%2bUC8sGD4H%2bNsfl/gPxJJ0AxmhhDBLDybOdow6jIcjKybGe82uzsLjY40aBw9tSFOXn76ENCTuP/wFhSgDDaMCqyBEaWLcSrzUJ3sUFAg0LoqQsTePvo428c9pO/amv7nAAAAABJRU5ErkJggg==' /%3e%3c/svg%3e"},"locale":"en"}},{"node":{"title":"RMRK x Robonomics Network: Pallet integration and Kanaria rewards","path":"/blog/partnership-with-rmrk-announcement/","date":"December 23, 2021","description":"Robonomics is thrilled to announce we have partnered with RMRK to bring a robotics theme to the Kanaria project and support RMRK2.0 standards! Kanaria is the most advanced NFT project in the world built on the world’s most advanced NFT protocol: RMRK.","content":"\n[Kanaria](https://kanaria.rmrk.app/) is the most advanced NFT project in the world built on the world’s most advanced NFT protocol: [RMRK](https://rmrk.app/).\nKanaria NFTs are birds that can own and even equip other NFTs, building an item economy that can span not only different projects (automatic cross project compatibility) but also different chains due to being launched on Kusama - a “Layer 0” for chains to connect through. Kanaria are also the precursor to RMRK’s upcoming metaverse - [Kanaria: Skybreach](https://url.rmrk.app/meta).\n\nRobonomics has committed to supporting the addition of RMRK’s pallets into their runtime, thereby integrating natively with the world’s most advanced NFT logic (the addition is still subject to community governance vote). This integration allows RMRK 2.0 NFTs to natively exist on Robonomics' upcoming parachain, and has implications for the extension and exploration of how NFTs built on the RMRK standard can be utilized in IoT applications and complex robotics.\n\nAs one of the first projects engaging and building within the Polkadot ecosystem, Robonomics offers a platform to build Web3 robotic solutions and applications for use cases within supply chain, payments systems, production, digital passports, and *robots-as-a-service*.\n\nRMRK on the other hand will reward the top 500 crowdloaners [participating in Robonomics crowdloan](https://robonomics.network/kusama-slot/). These champions will be airdropped a special Kanaria-compatible item - a child NFT that can be equipped onto one’s Kanaria bird, and may bestow advantages in [RMRK’s metaverse](https://url.rmrk.app/meta).\n\nYou do not have to have a Kanaria bird to get this bonus item, but you do have to be in the top 500 contributors.\n\n## About Robonomics\n\nRobonomics is an open-source platform for IoT applications. They support a new generation of internet technologies (web3) that implements the exchange of technical and economic information in the form of atomic transactions between user applications, IoT services, and complex robotics.\n\nThe Robonomics platform provides tools for working with the robot economy network. Robonomics allow designers of smart cities and industry 4.0 zones to build trust among the autonomous robots services, provide direct user access via dapp for ordering products from autonomous factories and services of urban sensor networks. This in turn allows Robonomics and it’s users to put in place a decentralized system that globally monitors the activities of cyber physical systems.\n\n\n## About RMRK\n\n[RMRK](https://rmrk.app/) is a team spearheading the development of the RMRK protocol for creating highly composeable “NFT legos” using NFTs on the [Kusama](https://kusama.network/).\n\nAmong others, RMRK brings the following features to the NFT table:\n\n* emoting to NFTs on chain\n* custom burn messages\n* NFTs owning NFTs\n* NFTs that have conditional rendering (if this, show that)\n* NFTs that have slots for upgrades\n* NFTs that have multi-resources (i.e. contain both code for a game and high-res cover art)\n* NFTs that can be governed as DAOs\n\nIt thereby far exceeds what the current ERC721 / ERC1155 standards and their derivatives can do.","cover_image":{"type":"image","mimeType":"image/png","src":"/assets/static/cover.62c183a.66d3ac0daebfd1e49baa052361ed7534.png","size":{"width":1500,"height":675},"sizes":"(max-width: 1500px) 100vw, 1500px","srcset":["/assets/static/cover.9ea8d39.66d3ac0daebfd1e49baa052361ed7534.png 480w","/assets/static/cover.6b2ed88.66d3ac0daebfd1e49baa052361ed7534.png 1024w","/assets/static/cover.62c183a.66d3ac0daebfd1e49baa052361ed7534.png 1500w"],"dataUri":"data:image/svg+xml,%3csvg fill='none' viewBox='0 0 1500 675' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'%3e%3cdefs%3e%3cfilter id='__svg-blur-f0e05ab11f53c33182702fb70c709aed'%3e%3cfeGaussianBlur in='SourceGraphic' stdDeviation='40'/%3e%3c/filter%3e%3c/defs%3e%3cimage x='0' y='0' filter='url(%23__svg-blur-f0e05ab11f53c33182702fb70c709aed)' width='1500' height='675' xlink:href='data:image/png%3bbase64%2ciVBORw0KGgoAAAANSUhEUgAAAEAAAAAdCAYAAAAaeWr3AAAACXBIWXMAAAsTAAALEwEAmpwYAAAMh0lEQVRYhcWZaVCVV5rH74f5MjVTMzVdUzU9VdPdQdugche4LLIol7vfy6aAEJEdRNsNBASDaBSXSByNa2LUxI2MxpiKitiauESNLHflXi7iBi602Waqu2fyoVOTL7%2bp894VNJnkQ%2buHp855z3nPec/zP/9nOeeVqS1OpmU4ya/px%2ba8Tdeno1zruYfLew%2b7exT7wChOz32ufn6bsxdH6OkfpLbxGlM1LsTYOLMQ1wuRWJNfxBpEOS3DhVwf7PO3BdenDo3zrznYJxONKpOHBKsd8yuXkWuvU7LUwUdnezh%2b8jQnPjzLiY8uUlBzA7nejaHwCsnZvaiM7tBkLwqA4PdVJhczsvopXmzHWtKPyugI9SuNLmJ0zpAIgCJBk8WZ7ahNPaTmXqGkeguV1Y2UVbezcMka6hsaWF5Xz/L6ZuaW/jsqow2FYQCVMTyBf7IXC4BYQ2Kmg7JlNjJL7SgN/k0R69Tk28gsc2EsdmMqdmOZb0NtcYQZkFN2nV0HLnH87a1cvdTFxo4dNDfX0dxYS%2burzbS3b%2bC1taupb2gjzmwLfThMr%2bfBgPHfU0/4pqC33wScKALKS8wwusjI62XrnmF67cN8ePYuRQvtKI3hd2RzKq5yvPsWY32H%2bK/BD/m4%2bxMaWnaRV3qU2iXbaGpqoqKqhPKqRsnmI%2b1K2NnzsvUgCAq9C7kuoLjFhdLgQGFwSHUhol%2bAEByjMLhIzu4nKctO2ux%2b6TnSR8j0BRdYt%2b0c7765ie7dFVy74aKq7gy62cdobV3D2jUtvFLSyKysw8SaBiJ2/XnaflghbaGT2dXCxu1M1diYmTfIrPwhpmfYkOtsZJfbsJSMHxMbYEPwWTBIgBUnOUFTP8mZl1AZb/Jb1RKiY3RULGilfd0qahatR5N9zD/YPBiY9Pns/vj5A87O6GJOhY3OI59z6tyX%2bG5/i9PjxeG2M3TnW85e/JLjpxxkljpQhcZHlv76dK2LqZoAA2LNblTGAeIsPhQZ50nV1jI7L5/y8hKqF21Bk7WLuIxOps3sQm3xjAMh7q8EQqTykeFMeHu1ycncMgctm%2b5z/8G33B/1ceeem/uj/0PrlhHyF/ik3fU76vCuh8zWaCevup/y5TbirTYRBQKdJocEgtpsR5FxBlPeXhqa1rB4SSVNzevJLtxOQtoyVIZe4szuwCKfBuDnMmPi%2bxOVn%2bgHRH2KRijSj2leH7qiQbSFPszFfQg2T5kpzCOSpeOZoDI6ySqzU7TIHjSBSFo7iBUvW3wojQKMPgz5H1JWu4umlq2UlMwjQX%2bEWLOPOHMwlDy9eFEKTys%2bJkoRllSRzwGZaE6RCot3CxfdIilLMDTYH2CC0YW%2byEF6vkPy/NO1DmblOdAV2iMc5kRgw/PH6IQJ%2bNtkISoLIEJ1R0BBNwrjIDE6n1TXWuvJMFUGGBBpX%2bOViLe6SM5xS5KSO0Dq7AGpPiNbPLtDzz%2b040LhGTluNAUeaXwYgPFZnIhKIgQKyou%2biVFqoiMNzuF3gv65ZE%2b9OG43hIgQY0NpGmamdRvGnAUkWS%2bgMnmlvsioEFSg460x9hx6wvb9f2DL3jE27nzMmwf%2bwK73nrB13xjtOx7xTueX1K8bIUYrgA7Hb78iLgkk/TwvmrkeCdAwwGEPP3G3I/t%2bqgnKfvyFsLOLNQ8Qb7qEoWAzCZbPQiExuBAhgupiZ9dtf8TFz/7Ip9f/xIXP/sjVnj9L9Wt9f%2bbEmW%2bksnnjKAtb7jI9w4GpeJCcSl8og0vMdJFVPoTT9xeKFt8hMWu8mUU6Nv9zEITgeoJtfnDD45w/FwCXX/kQsuLMcJ14cx8JIis0OYi3OIm3OFBLJuOUbHbnu0/o/Ohrjp76mhNnv5HkZNd/Ss/vnviK46e/Yd%2bxL1ixboRpGcKWPWgLPRIL4i0u4q1udhx8gHfoIa/vvUfaHD8LIk0hZK5msRGuQClM0%2bFvt3hRW0ToDucuz/I1sp8CQJhWQlEX0Ybb/Er7mKTsQXY21vPx7nYGP9jMhvrdvKz10dR%2bn5UbR1m5cYSWTSM0rL9Py%2bYRGtvvs7pjlBXr7rFh50MqVgyjNAhv7JAOMPFWJ5nlXlJnu8gqc2Kc10NmmYPkXDfW0kEJnPFKDKDS3yBWOFipvCkpHmv2oNCcY3rq%2byh116WNizXZn8kE2f9vAn7lRXgU9cn6uywp3MXhqleYpVmO7a1KvvtkMX85U8bupa8xRTdMTIaNGJ2D6HQXk1I8TE7zEJXskeovJQ8wKdXDb5IGiErxMDXdS3RApmsHMRbfIdboQ2UcQmUaJt46KJlVTuUQicGIIIVsL0rdFV6OyUGlOYoi/QjyWSdRas9Lz3G646TlnkOtO4Da0ofaOvxzTMA5ztsKuk813EJu8vBRlRbnwkmcX5iONWMO%2b1sLuH3AwvenMzm49g1%2bmzFEUqbY0QH0r9ygYsUZSpd3saC5m9qWbqqbuqlqPMfCVeepae6mZmW3VFav7KaqqZvSui4qG85RvLSLsrrTGIuvotC7keuD9izo7Uapd5FbsZvFr7WzpH0nC1ZtJ7dwPSlphcwyzqHu9YM0d%2byneds%2byhs3IE9c8cwzjOzHKC/sWkiUfpTs3DOcrdXyQbkWc%2bZpfq0bI8H0KfPmNrO0opnN9S1UlR8kRu8hMdPOpNRhNux4B9Dxv99n4XLNpLc3lZGRDB4%2b1Er1/v40enpS6etLxWZLw%2bOZhdfrl%2b%2b/zwYyOPD%2bG0xOuyUdd/0KCBbYSNC0Ysopx1J5GWvlBYzzThGn2Y085U0SDHsobTxAw%2bZtFNcdwVxylJiUvT8NgNiARxeKTzP6iDbcYmPJSq4tUlEzZydRulEUJi8JZn/SoTQNIjcOEq3zEqP3X5IkZNqJShmm4629wAxAy6BXia1PzhdPEvjvP83AYZNz724ct4ZU9N6MYcinYmhQxS2fiidj8RJwkMixU5uYlDIsXdgIXyE3%2bDAVdLKyqZYU4wbkWnE69CLXe4m13CbOeo84s5fy5n2UtxxCoXegNHhRW28/MxLInkV9SXmDjyUFO%2bhdGs/bJfNRG/t42XCXREt/RBYYft%2bflASZ40Su85BVcYlXtxyiacMx2rZ20vZGJ60dnby65Rhrt73P6jc6/e1bO6W6kNaOY1IpxrRuOUTBwt8j14c9ubiQ0RZcZ%2bmK7cQar6K2uKULDr%2bDtqHQucms/ID6jh3MKriM0uAJXIBMTJGfAUBsYPfjzTai9GNUWsrZmf8SmsyraDKvoDC6UZo8YQBCyVJkMhROSGJ0wvENMzn1FlEpfpkUkKjkcFuwPbLfP2aYaRnep%2bZVGgaIzrgVOpOEzv56LwmZ11iyYRdzl51AoRNrjUyOnj6/yJ7FgOlGLwvmHkGfqkGXOBnWyvi27e84/zs9ieabKENJ0LOTi5APsTgl6iZYHT9b4qXSPu76anwaHIj3Ed9Lyupj/orD/G79XmZkX5VusNRmcUf4wxmi7CkATA7kptsszcohz9RGgqGHd%2bYV8d0qGWyR8R8LK4g23CNeCouu5ywTdjKCgaJ9Udth2nbspWb1HspbDlK56gDVbUdJnXMDlSFoRj8CQKxEM2HPQ0xJP8UvFGXUzn2djWWraS9ayemyKDbm/gtJxjOoxAVJRKr5YiSgvBS9HNSs2kX9pl0s23KQhm3vsXLHe9Rt7iA9/wxKg8gKg7fFP2oCLgmEJKuPXyfv5EjBP8JrMh6s%2bCWTFRb%2bZvJLTElaitoiEosXAcDEU53f1JRGL6k5H5A7r4acolKsc5eRXvgJM/O6SLReR20Z8DvqwPsR1%2bKuCAaEbVo4wmjzIxotzXw1X8ZXJTI6NP9AnHISivS3pTuDFwFA5LleXI6K663p2gHScj8nffYFFixfy/yKMnIKV5GSdZMZWT1EazzEaJ2Bd/3luB8jcRNBkK6ahS/woDf9nrF5f8t31TKoltFVNEvyEaL/xfwUCd8ZmOf7r7fMxb3sO9TLxcs2Tp2%2bzOmuTzj58WWuXB9gz7t9ZJbayKu2M7vKTn6Nk9lVfkcbO5EB44EQ%2bfYgcm0Xtckvszr9l7Qb/pk8TS5yo93/q%2bkHo8BfFwBB46kaB4dPuBh5MILLM8yAd5jRh2OMPnrC/QdjjDx4zINHYzwc%2b4IHj7/kweOveDj2NbfvjnLpSh%2b6Qpv0l%2biZAPhNwY7aeoeo2Dr%2bfvK/8YtoFf8am8w/TfoVKs1%2b4iQfILLBF%2bEDRC7goajyPVa17aFlzUFaVr9Ny9qT1K%2b1h6SurZ%2bWjT5aN91gZetbNK/ez7KG7VTWvs6MzOuoTAP8H9jp9T2gbPbpAAAAAElFTkSuQmCC' /%3e%3c/svg%3e"},"locale":"en"}},{"node":{"title":"Monetizing Logs of Boston Dynamics Spot with Ocean Datatokens","path":"/blog/monetizing-logs-of-boston-dynamics-spot-with-ocean-datatokens/","date":"September 9, 2021","description":"In the last article, we presented our ROS package - ocean_ros, which connects the Ocean API and ROS, and also partially touched on the use case for selling technical logs from the robots. Today we will dive deeper into this use case and describe a specific example of devices’ data tokenization.","content":"import Card from '~/components/TextCard.vue'\n\nIt is time for a new stage of integration with Ocean Protocol. In the [last article](/blog/ocean-protocol-p-2/), we presented our ROS package - ocean_ros, which connects the Ocean API and ROS, and also partially touched on the use case for selling technical logs from the robots. Today we will dive deeper into this use case and describe a specific example of devices’ data tokenization.\n\nFirst, we need to understand what real practical utility such data and datatokens created from it can bring. It is clear that the service information obtained during the operation of robots and devices is constantly reused to improve algorithms or user experience. But for the most part, this information does not go beyond the device's manufacturer itself. Difficulties begin when devices with a similar principle of operation appear on the market (e.g. robotic vacuum cleaners) or an open platform is released, which is positioned as the basis for other solutions (Raspberry Pi, Arduino, TurtleBot from ROS). For the first case, many of the same types of devices around the world generate gigantic amounts of data dedicated to one specific task. For the second case, developers of open platforms receive unique datasets in their projects in a variety of tasks. However, this experience is not aggregated and shared. It remains unavailable for analysis, which limits the system improvement and makes it hard to find new approaches in the control process.\n\nFor example, for motion planning of manipulators, inverse kinematics is a challenge. The joints’ parameters of the kinematic chain need to be found to move the end of the chain to the desired position and orientation. In other words, in order to move the end of the arm to the right position - we need to calculate the positions of every joint the arm has. Often this problem is solved analytically or numerically, but sometimes these approaches have problems, not least computational ones. With the rise of machine learning, [neural network approaches](https://doi.org/10.1016/j.protcy.2013.12.451) began to be used to solve the inverse kinematics, but they require [datasets](https://mint-lab.github.io/awesome-robotics-datasets/) that have information about the motion of a real device for training the model.\n\nSuch data needs to be collected and provided to interested parties. This is where [Ocean Protocol](https://oceanprotocol.com/) datatokens come in. They allow automating this process and spur the market of robot datasets. Now this niche is occupied mostly by open datasets, but their main drawback is low quality for business use cases. Let’s move on to our example of robotic data tokenization.\n\n##  Meet Boston Dynamics spot selling its telemetry\n\nSpot is a relevant example of a complex multi-purpose platform with a wide variety of application scenarios. The fact is that working with real Spot telemetry is quite difficult, and this can greatly slow down the development of custom modules for the robot, and even more if the developer wants to use machine learning. Examples of operations that the developer could recover and study would be very useful here, but so far there is very little data available on the use of the robot, especially outside the United States. That's why we want our Spot to become a supplier of high-quality logs of the actual telemetry obtained when performing the same operations. This will give developers multiple repeated records of the same scenario, which should help them develop or improve their own solutions.\n\n## Implementation\n\nThe main integration with the Ocean API is provided by our previously written ROS package - [*ocean_ros*](https://github.com/LoSk-p/ocean_ros) To link Spot SDK with ROS abstractions and to work with robot logs inside this operating system, we use [a driver](https://clearpathrobotics.com/assets/guides/melodic/spot-ros/ros_setup.html) created by Clearpath Robotics. You can learn more about how to collect telemetry using the Spot SDK in the [educational program](https://spot-sdk.education/) from our colleagues at Merklebot.\n\nAfter Spot executes any command, we get a file in rosbag format with data from the /tf ROS topic, which describes the position of Spot frames relative to each other. Frames represent parts of robots and surrounding objects that the robot can see with technical vision. The relationship between two frames is described by a three-element translation vector, which describes the difference between the positions of the origin of two frames, and a rotation quaternion, which shows the difference between rotations of the coordinate systems of two frames. The position of each frame is calculated in relation to the parent frame (for example, the hip relative to the body), the initial frame is the position of Spot at the start.\n\nAfter Spot executes any command, we get a file in rosbag format with data from the /tf ROS topic, which describes the position of Spot frames relative to each other. Frames represent parts of robots and surrounding objects that the robot can see with technical vision. The relationship between two frames is described by a three-element translation vector, which describes the difference between the positions of the origin of two frames, and a rotation quaternion, which shows the difference between rotations of the coordinate systems of two frames. The position of each frame is calculated in relation to the parent frame (for example, the hip relative to the body), the initial frame is the position of Spot at the start.\n\n![Different parts of Spot and the diagram of the relationship between frames](./images/monetizing-logs-of-boston-dynamics-spot-with-ocean-datatokens/spot-scheme.png)\n\n*Different parts of Spot and the diagram of the relationship between frames. Source: https://dev.bostondynamics.com/docs/concepts/about_spot.html*\n\nhttps://youtu.be/6i9zYpCMzn8\n\nThe video shows the sequence of commands for creating, selling and buying Spot telemetry datatokens (for more details on how the ocean_ros package works, [see here](https://www.youtube.com/watch?v=Ssit8-u6dZY)). It should be noted that the rosbag file is pre-loaded into the IPFS file system to access it via a hash link, which is used when minting datatokens.\n\n![Spot on a 3D robot model](./images/monetizing-logs-of-boston-dynamics-spot-with-ocean-datatokens/Spot-on-a-3D-robot-model.jpg)\n\nThe video also demonstrates the purchase of these datatokens and an example of restoring the entire sequence of commands executed by Spot on a 3D robot model. To do this, we use the [rviz](http://wiki.ros.org/rviz) visualization tool for ROS. Thus, developers can work with any real Spot telemetry, even without having access to the robot.","cover_image":{"type":"image","mimeType":"image/jpeg","src":"/assets/static/Robonomics_Ocean_p3_blog.62c183a.886ec03470834bc488dbc058e44e348f.jpg","size":{"width":1500,"height":675},"sizes":"(max-width: 1500px) 100vw, 1500px","srcset":["/assets/static/Robonomics_Ocean_p3_blog.9ea8d39.886ec03470834bc488dbc058e44e348f.jpg 480w","/assets/static/Robonomics_Ocean_p3_blog.6b2ed88.886ec03470834bc488dbc058e44e348f.jpg 1024w","/assets/static/Robonomics_Ocean_p3_blog.62c183a.886ec03470834bc488dbc058e44e348f.jpg 1500w"],"dataUri":"data:image/svg+xml,%3csvg fill='none' viewBox='0 0 1500 675' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'%3e%3cdefs%3e%3cfilter id='__svg-blur-3a7eb8ab450c25a9f129c1fa3db41865'%3e%3cfeGaussianBlur in='SourceGraphic' stdDeviation='40'/%3e%3c/filter%3e%3c/defs%3e%3cimage x='0' y='0' filter='url(%23__svg-blur-3a7eb8ab450c25a9f129c1fa3db41865)' width='1500' height='675' xlink:href='data:image/jpeg%3bbase64%2c/9j/2wBDAAYEBQYFBAYGBQYHBwYIChAKCgkJChQODwwQFxQYGBcUFhYaHSUfGhsjHBYWICwgIyYnKSopGR8tMC0oMCUoKSj/2wBDAQcHBwoIChMKChMoGhYaKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCj/wAARCAAdAEADASIAAhEBAxEB/8QAGgAAAgMBAQAAAAAAAAAAAAAAAgMBBAYFB//EADAQAAEEAAQEBgECBwAAAAAAAAECAwQRAAUSIQYTMUEUIiNRYXGBFtEyRJGSobHw/8QAGQEAAgMBAAAAAAAAAAAAAAAAAwQBAgUG/8QAJhEAAQQCAAUEAwAAAAAAAAAAAQACAxEEMRIhQYGhBRQiYXGRsf/aAAwDAQACEQMRAD8A8kmz2W1rCEoNHvgIEpyXzG6pCRdp7fGFSMoFlTigD1oGzhEl0QoCW2BpLh3Ortjr3Ag2dLBjiAHIn9pGZzXGXyGX16QN6V0P3ig5msttRt%2bShQ6jmHb8HDGGC%2bsqUPTRRUTv1O23/bA4niViOZLj%2bXuvPRwEhS3k6V2R399wRftWFXOrmtWBo0UDPEk1CgknnDsFbE/0wWYZ/mjL7sZ1rwj7aihaFoIWgjYghXQ/jA8LZ0nJpD61JSS4jSFad0%2bVQ2PUXqrYi%2b9jbFrjXiFnNylhlCNLTiilQSLCdS6ANdPNdCk/F4UdM%2b6TBiZulzXc3lPvN1LfaRQCjrI%2bzhiM2mt69Et9dHylRBFfOOdlzrbUhK3AKA2sXR98WhKdDry0afUsEpG1YlrieqAQNAL0tvKsuhsNLz3NUxpDnm8LHTznEoIsFdbI37WT8YCRknDk2HJmIzuSmHEWhL61sUSpQNIQCkalGul7AEnFB3KGnSfUWlYFBYqx%2b%2bIXkyFMloyHuRZXy9q1VWr7rbAp8PJlPEMhwN6AbVdQAWk/iye%2bkKGSOMcJjFd7/teFlZEmnCllLamwSlBW0nURe17dawhbU3TrTHbKexDKSP8AWNQeGI6qIkPA/j9sLc4RQv8An5A/Aw3Ix5HwV45Wt2sc2JUQuHkt%2bbZXMQDX1fTrgo8xifPjN5soRoWv1HIzCdaRvuB3641f6MaPWfI/tGAPA8VIsy3zXbSMLPx5XNIPhF9wy1cm8M8IZa1E8fxFLKZDIfYcZjlSXEEmiPLsdiCCbBBGOfmmRQWsrcm8M5yjMY4QTJYcHKfbRq2VoP8AEnpZTdewxbe4RQ6y20vMJBaavlI0jSi9zQ%2bTiEcJRG0lHiJBBoncC/8AGEcf03LiIc6Yk314aI7AHX3tXflQvFBg82v/2Q==' /%3e%3c/svg%3e"},"locale":"en"}},{"node":{"title":"Polkadot for the IoT market: Robonomics is ready for real world use cases on Kusama!","path":"/blog/polkadot-for-iot-with-robonomics/","date":"August 31, 2021","description":"The Robonomics team wants to impact the Kusama network development with four scenarios from the real world. These use cases describe unique opportunities for the crypto audience and all participants of the IoT market.","content":"import Card from '~/components/TextCard.vue'\n\nOur team already has various business cases that are ready to leverage the parachain technology. But before we can roll out these use cases we need to obtain a parachain in the [Kusama Parachain Auctions](https://kusama.network/auctions/). So, let’s talk about each of these current use cases.\n\n## Meet Spot, our Robodog\n\nhttps://youtu.be/_xBLkszEwWk\n\nThis summer, the first group of engineers learned to work with our own Spot as part of the [spot-sdk.education](https://spot-sdk.education) course. By the end of September, anyone, anywhere in the world can take our course and get his hands on with the robodog from [Boston Dynamics](https://www.bostondynamics.com/spot). The course is developed by robotics specialists from the [ITMO University](https://en.itmo.ru/) in St. Petersburg and [Merklebot](https://merklebot.com/) acting as the local operator in the San Francisco Bay Area lab, the home of our Spot. \n\nAccessing Spot is organized through the use of two parachains - the Robonomics and Statemine parachains. Logs of the students passing the course will be recorded on the Robonomics Parachain where the [Statemine parachain](https://polkadot.network/statemine-upgrade-launches-new-phase-of-parachain-functionality/) is being used to replace user accounts with unique access tokens that students will receive after payment of their course.\n\n## An Urban Sensor Network on the Volga river\n\nOne experiment that is leveraging the power of [IPFS](https://ipfs.io/) and [Substrate](https://www.substrate.io/) based Blockchain technologies is currently taking place in Tolyatti. The focus here is creating an alarm network detecting high levels of air pollution without a commercial focus and being dependent on a government, but solely being supported by the citizens of Tolyatti and the Russian Airalab organization. The automatically collected information on exceeding the level of air pollution will be used for a quick response of the mobile laboratory, which is already capable of conducting a detailed analysis of particles in the air.\n\nAll data collected by the Urban Sensor Network will be securely recorded in the Robonomics parachain to avoid any possibility of intervention in the measurement history and provide security from disabling the network during attacks of the main server. \n\nIt is an example of the social impact the Robonomics project can have in these times where [90% of the world's population breathes dirty air](https://www.bloomberg.org/blog/accelerating-clean-air-action-one-data-point-at-a-time/). Thus, with the help of Kusama we can have a trustable, immutable way of storing pollution data which can be used for science to create a better world for all [protected against corrupted actors on both corporate and government level](https://www.brookings.edu/blog/up-front/2020/06/05/corruption-is-a-threat-to-planet-earth/).\n\n<Card>\n\nWatch **a step-by-step process** of how to connect an SDS011 Air Quality Sensor to the Robonomics Decentalized Sensor Network from our Community member\n\nhttps://youtu.be/AQ7ZzgbN7jU\n\n</Card>\n\n## Digital Twins for Smart Leasing\n\nThere is an interesting new use case in Robonomics. For four months already, an industrial manipulator has been operating in a manufacturing facility in the United States with an hourly wage. At the end of each shift, the manipulator updates its digital twin instance stored in the parachain. Based on the changes in the digital twin, an invoice is issued for the use of the manipulator structured as IoT-enabled leasing. \n\nThus, we can say that Kusama will be an example of a fintech solution from web3 for the new industry 4.0. [Someday the public will understand the significance of this use case](https://www2.deloitte.com/content/dam/Deloitte/us/Documents/manufacturing/us-supply-chain-of-the-autonomous-robots.pdf), and we will see a boom of DeFi for this modern industry!\n\n## Digital Passports for IoT systems\n\nTwo projects — one is from New Zealand — are using parachains for recording data about production manufacturing. In one case, data about the content of substances in the ground on farms is collected, in the second — data about the final assembling of medical equipment. \n\nBoth scenarios would help the Kusama network to expose itself as a registry for global production distributors.\n\n<Card>\n\n**Project 1** New Zealand’s premier industry is considered to be Agriculture. Climate change and clean water in our rivers are also at the forefront of New Zealand’s concerns. Luckily, with the advances in precision agriculture and the efficiency of our world-leading practices, our sheep and beef farmers can claim to produce less Greenhouse Gas Emissions to get a piece of meat to a dinner table in London than the comparable farmers in Wales:\n\nhttps://www.youtube.com/watch?v=vZGMeYKInAk\n\n</Card>\n\n<Card>\n\n**Project 2** Demonstration of the work of an automated workstation for video recording of the assembly process and testing of complex technical products.\n\nhttps://youtu.be/wmeBIbNaBlQ\n\n</Card>\n\n## Second Wave of Kusama Crowdloans\n\nWe would love to see your support for [Robonomics during its crowdloan](https://robonomics.network/kusama-slot/) for the 6-10th parachain slot on the Kusama network so we can implement each use case as soon as possible!\n\nWhile these use cases are just scratching the surface of the potential that the Robonomics Network will bring to the industry 4.0 after obtaining a parachain slot on [Kusama](https://kusama.network/), they demonstrate the numerous capabilities of Web3 that are not yet being explored or utilized. \n\n*This is only the beginning of Robonomics' Web3 journey, and ultimately we plan to enable millions of interoperable IoT devices in the Polkadot ecosystem, including many of which have not yet been conceived, but are already possible with [the technology of Robonomics](https://blog.aira.life/a-brief-introduction-to-robonomics-9b7884172e77)!*\n\n<Card :icon=\"'/icons/icon-future.png'\">\n\n### Want to be a part of the future?\n\nHead over to the [Robonomics Crowdloan page](https://robonomics.network/kusama-slot/) or the [Kusama Portal](https://polkadot.js.org/apps/?rpc=wss%3A%2F%2Fkusama-rpc.polkadot.io#/parachains/crowdloan) and support us building the infrastructure for the Smart Robotic grid of tomorrow!🦾\n\n</Card>\n","cover_image":{"type":"image","mimeType":"image/jpeg","src":"/assets/static/cover.62c183a.f40e47ee35e5c8b8f2fdd58d0788c762.jpg","size":{"width":1500,"height":675},"sizes":"(max-width: 1500px) 100vw, 1500px","srcset":["/assets/static/cover.9ea8d39.f40e47ee35e5c8b8f2fdd58d0788c762.jpg 480w","/assets/static/cover.6b2ed88.f40e47ee35e5c8b8f2fdd58d0788c762.jpg 1024w","/assets/static/cover.62c183a.f40e47ee35e5c8b8f2fdd58d0788c762.jpg 1500w"],"dataUri":"data:image/svg+xml,%3csvg fill='none' viewBox='0 0 1500 675' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'%3e%3cdefs%3e%3cfilter id='__svg-blur-ab82f7b91d70eeb1933e82d3d64ef8a1'%3e%3cfeGaussianBlur in='SourceGraphic' stdDeviation='40'/%3e%3c/filter%3e%3c/defs%3e%3cimage x='0' y='0' filter='url(%23__svg-blur-ab82f7b91d70eeb1933e82d3d64ef8a1)' width='1500' height='675' xlink:href='data:image/jpeg%3bbase64%2c/9j/2wBDAAYEBQYFBAYGBQYHBwYIChAKCgkJChQODwwQFxQYGBcUFhYaHSUfGhsjHBYWICwgIyYnKSopGR8tMC0oMCUoKSj/2wBDAQcHBwoIChMKChMoGhYaKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCj/wAARCAAdAEADASIAAhEBAxEB/8QAGwAAAgMAAwAAAAAAAAAAAAAABQYABAcBAwj/xAA0EAABAwIEBAQFAQkAAAAAAAABAgMEBREAEiExBhMiQQcVUYEUI2FxkUMkQkVSgrHR8PH/xAAaAQABBQEAAAAAAAAAAAAAAAACAAMEBQcG/8QALREAAQMDAgMGBwEAAAAAAAAAAQIDEQAEMSFBBVFhIjJxkbHRBhITI2KhwfD/2gAMAwEAAhEDEQA/AFGjUVmsZWY0pDMpDTjrxkqCG7A6BJ3JtqcBgkX6gTgjSoJnSnEOPNR47KVOOurBORIG9hvckAD69hc4YfDZ/h41%2bqxKvH%2bPY5H7MtyOVZVg3CsqF6pKb36u2Oicuw3JUcCa0l%2b%2bZt1qQSpR2AGogmdZE/wA9aVITcZS1CUpaRbpKR3wCq9YjwHOQ2lUiYrRLLepv9fT%2b%2bN3VUvD3UfDU8b/AMNf9v1ccNzPDFtpARTqehaVApKac8AD3/Uvr98MLvlkdkEU0/e3Ckw0wsE7lMx4CfXyrPaJCgu8KvSqghlEtJUlwZ1ZgcnRywDqAogHMP3txbAiLGadvzpCWQP5kk3/ABjXfNPDkJQDEhZgDmPl79ibaW%2bb64iKp4c85JXEhFq/UlNPfCiL7A83Q%2b2EL1Q2NGi7cTP2HDP4j3rJ240NE9hEiSVRSRzHGk6pF9dDitJbaTIcEdSlMhRyFQ1I7Xwa4qjtO1SpSqBH5NNW6oxS42oISknpB/7gLGadRHbS%2bUqdCQFlJuL99cSQ%2bcmrG2CX3ZQSRGuogGcGNQobjlTJ4SUabV%2bKVKcQyqCwzmlpd1StC1BvLr3Ocn%2bnGpcUcBUXhutcOz49Tg0ZpL6lPIfuFyG02UbK16gNMvodDgTwA2mn1J2K2AWZqUhwWsQUHMkg%2bu498OHjTSo0qj0Z%2by0kOKASpZWACm/f7YZ4ghm64kLVYjs8tlAj1BHOsgavHktl1Kz5nr6yZ8TXnr5Tzq5NUqiWXJLi3UR47HNcSgkkFewTuNLk/QYvsyk0dk1OnSmZTjgWyyxMp6FhRBF1FJ0SOwO5N7euDK%2bH4iiSb30tYWsR3GIaBF5ocuoKuPx6fbFieEguBf1D8oPdhERy7pPLWZzjIkK%2bI7tbZaUskERlXvH6obw9KkcT1p1ufGgJqa45bpsVlhMeO%2b/e4S4U6gkE22BIAJAwtSplRdddVI5YcUrqyMoFiNCLCwHtjQ6bCTTZ8ebEUEyI7gcbUUBQChsbHfHS5SGFqUVbqUVGw7nFim1YSskIEabf7pUYccvEpCUuqEdTikunzKxNaXBfqbceKLKSHUHIEg3OgBudj%2bcVqtIqkaWmMwqFIaaCQX22coULA%2b%2b%2b51w9%2bSx9P8Ynksf/AEYBVkytwqWJTGIEe9AOLPhBQlZAJkwYknJMZJ55r//Z' /%3e%3c/svg%3e"},"locale":"en"}},{"node":{"title":"Robonomics Network x Ocean Protocol p. 2&#58; Monetizing Data from Robots and IoT Devices","path":"/blog/ocean-protocol-p-2/","date":"July 1, 2021","description":"First results of collaboration between Robonomics Network and OCEAN Protocol","content":"import Card from '~/components/TextCard.vue'\n\n## Introduction\n\nThis article [expands the integration](/blog/article-ocean-p1/) between Robonomics Network and Ocean Protocol. There will be described specifically how to connect robotic devices to the protocol, as well as possible use-cases where such integration will add value to the operation of the autonomous system.\n\nFor those who are not familiar with Ocean Protocol: the idea is to transform any data into a full-fledged asset by tokenization, with the ability of buying / selling and transferring ownership. In short, when tokenizing data, you deploy and mint an ERC20 token (datatokens), the ownership of which allows you to have access to the data assigned with it (1 datatoken = access the dataset). The protocol allows you to flexibly manage access, for example, organize temporary access to data or give access to their analytics without violating privacy. Thus, it becomes possible to monetize tokenized data, create markets for them and use the full power of decentralized finance tools.\n\nThe Robonomics team is well aware of the value of monetization through tokenization, but even better, we understand the value of automation. We have already learned how to automatically monetize the useful activities of robots and IoT devices, so why not automate the monetization of the results (logs and data) of this activity? With Ocean Protocol, almost any robotic device that generates valuable data can be turned into a simple source of income for its owner. Or the device can become a consumer of useful data to finish its task.\n\n## Aspects of integration for ROS-devices\n\nIn order for Robonomics to work with many different types of devices, we use the Robot Operating System, a middleware suite that allows us to conveniently deploy software for robotic devices. Thanks to ROS, it is quite easy to connect a new type of device to the network. The active ROS community has developed hundreds of ready-to-use packages for various robots and IoT devices over the years.\n\nThe three main abstractions in the ROS environment are nodes, topics, and messages. A node is a process / program that performs a certain task and communicates with other nodes through topics. A node subscribes to a topic, waiting for messages, or publishes its own messages to them. In this implementation, the different-type components of the robotic system are able to interact with each other at the same level.\n\nThe figure below depicts a typical process for accepting and completing a task by a robotic device (promisor) in Robonomics v1 running on the Ethereum network. The AIRA сlient block is a deployed image of the required software for the device, including ROS. The figure shows (in blue frames) that the device communicates with the decentralized network through the AIRA client by receiving and sending messages in the corresponding ROS topics. The mission of the device ends with the final sending of the resulting message to the IPFS network, which contains a link to data potentially acceptable for monetization.\n\n![\"The process of Robonomics v2\"](./images/ocean-protocol-p-2/uml-robonomics-ver1.png)\n\nIn Robonomics v2, which is being developed as a [parachain](https://parachain.robonomics.network/) of the Polkadot ecosystem, the process is slightly different. Currently, the `launch()` and `datalog()`&nbsp;[functions](https://wiki.robonomics.network/docs/en/rio-overview/) are available for device control; the first function allows you to perform transactions to turn the device on / off, and the second one sends datastring to the blockchain. But logs and device data are still collected using ROS topics. They can then be passed either directly to `datalog()`, or sent to IPFS first.\n\nTherefore, the first task in integrating Ocean Protocol with Robonomics Network is to bring the protocol API to the ROS environment. Further, such a package for ROS can be integrated into the AIRA client and automatically deploy the creation of datatokens.\n\n## Example of Ocean integration with ROS\n\nThis section provides a description of the ocean_ros repository, created by Robonomics engineers, which is a ROS package that implements the integration of Ocean Protocol API and ROS. Ocean Protocol offers several API options for working with it, in this case the [ocean.py](https://github.com/oceanprotocol/ocean.py) Python library is used, since ROS has the Python client library [rospy](http://wiki.ros.org/rospy). The main purpose of the package is to create three ROS nodes, through which a robotic device can deploy and mint datatokens, create a pool for placement on the market, or buy datatokens for the use. Let's go through the installation and launch of the package.\n\nThis example is also available as a screencast on YouTube:\n\nhttps://youtu.be/Ssit8-u6dZY\n\n<Card orientation=\"vertical\" alignContent=\"left\">\n\n### Requirements & Installation\n\nThe package requires:\n\n* Ubuntu\n* Python 3.8.5 or later\n* ROS, Melodic ver. (installation instructions [here](http://wiki.ros.org/melodic/Installation/Ubuntu))\n\nInstalling the package:\n\n```sh\ngit clone https://github.com/LoSk-p/ocean_ros\ncd ..\ncatkin_make\nsource devel/setup.bash\n```\n\n</Card>\n\n<Card orientation=\"vertical\" alignContent=\"left\">\n\n### Setting Ethereum network & node\n\nIn the example, the Infura provider is used to set up the connection. Infura allows you to remotely use the Ethereum infrastructure without the need to launch a full node, which is very convenient for a compact robotic device with limited computing power.\n\nNote that for the example, a connection to Rinkeby, the Ethereum testnet, is being configured. If you need to switch to the mainnet or another, refer to the Ocean [documentation](https://docs.oceanprotocol.com/concepts/networks/).\n\nThe steps to set up are as follows:\n\n* Go to https://infura.io and sign up.\n* At the Infura site, create a new project.\n* Within the project settings page, note your Infura project ID value. This will be used in the next step.\n* Create `config.ini` file in the config directory (example of configuration you can find in `config_template.ini` file).\n* Write your Infura project ID for the network in the config file.\n\n</Card>\n\n<Card orientation=\"vertical\" alignContent=\"left\">\n\n### Setting Ethereum account and getting Rinkeby ETH tokens\n\n* Install Metamask wallet to your browser and generate an Ethereum account. Instructions are [here](https://docs.oceanprotocol.com/tutorials/metamask-setup/).\n* Get Rinkeby ETH tokens from a [faucet](https://faucet.rinkeby.io/).\n* [Export](https://metamask.zendesk.com/hc/en-us/articles/360015289632-How-to-Export-an-Account-Private-Key) the private key from Metamask and create a file with your private key:\n\n```sh\necho <private_key> > private_ocean\n```\n\n</Card>\n\n<Card orientation=\"vertical\" alignContent=\"left\">\n\n### Installing Python libraries\n\nInstall Python module venv for creating virtual environments:\n\n```sh\nsudo apt-get install python3.8-venv\n```\n\nCreate Python virtual environment and install necessary libraries:\n\n```sh\npython3.8 -m venv venv\nsource venv/bin/activate \npip install ocean-lib rospkg catkin_pkg\n```\n\n</Card>\n\n<Card orientation=\"vertical\" alignContent=\"left\">\n\n### Getting Rinkeby test OCEAN tokens\n\nGet Rinkeby OCEAN via this [faucet](https://faucet.rinkeby.oceanprotocol.com/).\n\n</Card>\n\n<Card orientation=\"vertical\" alignContent=\"left\">\n\n### Running ocean_ros\n\nIn the terminal with Python virtual environment run ROS launch file:\n```sh\nroslaunch ocean_ros datatokens.launch\n```\n\nNow you can access ROS topics to work with datatokens.\n\n</Card>\n\n<Card orientation=\"vertical\" alignContent=\"left\">\n\n### Creating datatoken\n\nTo create a datatoken, you need to publish a message to the topic `/ocean/create_datatoken`. The message should contain the path to the private key file from your Metamask account, IPFS URL to data from device, OCEAN and datatoken liquidity. Message example:\n\n```sh\nrostopic pub /ocean/create_datatoken ocean_ros/Metadata \"private_key_path: '/home/user/private_ocean'                     \ndata_created: '2021-12-28T10:55:11Z'\ntype: 'dataset' \nname: 'test_ros'\nauthor: 'author'             \nlicense: 'CC0: Public Domain'    \nfiles_content_type: ['text/text']\nfiles_url: ['https://gateway.ipfs.io/ipfs/QmWRjFcQi4Xcisqi8FP3AbGS3PB3gNHgtnfzbcpodKKCBP']                 \ntokens_nomber: 100.0\nocean_amount: 10.0\"\n```\n\nThe corresponding ROS node will create a datatoken and it will become available for sale. You can see information about datatoken in `/ocean/token_response` topic:\n\n```sh\nrostopic echo /ocean/token_response\n```\n\n</Card>\n\n<Card orientation=\"vertical\" alignContent=\"left\">\n\n### Buying datatoken\n\nTo buy a datatoken, you need to publish a message to the topic `/ocean/get_datatoken`. The message should contain the path to the private key file from your Metamask account and information about the datatoken you want to buy (you can find it on the [market](https://market.oceanprotocol.com/) or from the `/ocean/token_response` topic). Message example (don't forget to change `destination` in the message):\n\n```sh\nrostopic pub /ocean/get_datatoken ocean_ros/BuyDatatoken \"{private_key_path: '/home/user/private_ocean', destination: '/home/user/', token_address: '0x9fb21F68257F1d718d764B68b1430B6460796e42', did: 'did:op:9fb21F68257F1d718d764B68b1430B6460796e42', pool_address: '0xcF295B85ef5ADd0E513B789477C6d14eA6Bc718a'}\"\n```\n\nYou can see path to the downloaded datafile in `/ocean/buying_response` topic:\n\n```sh\nrostopic echo /ocean/buying_response\n```\n\n</Card>\n\n## Use-cases\n\nThis section will describe potential examples of the application of automatic tokenization of data received by robotic devices.\n\n### Environmental data\n\nPerhaps the most interesting illustration of application would be the tokenization of environmental data. The value of such data is only growing, taking into account the increasing interest of the population, companies and regulators in the problems of environmental management. The main problems here are the scale of ecology (air, water, soil multiplied by the enormous and often inaccessible territories of the Earth) and the issue of trust in the collected data. A mobile automatic device (air or water drone) or a network of stationary sensors perfectly solve the first problem, and blockchain and decentralized technologies mitigate the second. With the ability to tokenize this data using the Ocean Protocol, completely new markets are opening up where concepts such as citizen science and carbon credits fit perfectly. \n\nRobonomics has been working with devices for ecology for a long time. For example, the package [sensors-connectivity](https://github.com/airalab/sensors-connectivity) was developed, which allows you to turn ROS-compatible sensors into telemetry agents. Robonomics engineers are developing various models of [water drones](https://blog.aira.life/water-drone-2-0-first-stage-of-development-db8ad6c81d3c) to collect chemical indicators in rivers and lakes, and are also exploring the possibility of using [UAVs](http://www.ijeetc.com/uploadfile/2019/1009/20191009035041545.pdf) to assess air quality.\n\n```\n1556199372.384576 <=>\\x86##5E1567057C105409#DOV01SW#0#WT:6.53#PH:8.89#DO:90.4#COND:348.9#\n```\n\nExample of collected water data: temperature, PH value, dissolved oxygen, conductivity\nIn each case, the devices generate sensor and GPS logs, which are then [published](https://gateway.ipfs.io/ipfs/QmWRjFcQi4Xcisqi8FP3AbGS3PB3gNHgtnfzbcpodKKCBP) to IPFS and provided by the device as a result. This is where we can add value to this data by creating a datatoken by Ocean Protocol. Robonomics Network will ensure that the data was collected by a specific robot for a specific task, and Ocean Protocol will ensure that only those who own the datatoken can access it.\n\n### Marketing data\n\nThe trend of robotics in everyday life is growing and it is easy enough to find examples of robot promoters or a robot for customer service. The experience of interaction of such robots with people can be used for marketing research, similar to sites that collect data about users. Moreover, the value of this data will be even higher, because the interaction with the person occurs at a closer level.\n\nWe can imagine a robotic device that, in the process of performing its specific task (for example, a robotic waiter), simultaneously collects visual, sound or other information about the client. In this case, machine learning tools can be used for creating a completely new type of data about customer reaction to a particular type of service or product. This is a great scope for using datatokens, both for raw data from robots and for those analyzed by algorithms. Moreover, Ocean Protocol has a Compute-to-data function that allows us to provide private data for analytics without violating confidentiality.\n\n### Technical logs\n\nImproving the algorithms of robots also requires the analysis of their operating data. This primarily concerns machine learning, which requires datasets, but we can also talk about sharing three-dimensional maps (for example, for simultaneous localization and mapping) between devices operating in the same or similar environment. Monetization of such technical logs will be more field-specific, but the value will lie in their uniqueness and rarity.\n\nExamples include the tokenization of data generated by robotic vacuum cleaners for the improvement of their performance (bypassing obstacles, better recognition of the environment in apartments). Another example is service data of a production line, whose processing will optimize operating or production costs.\n\n## Conclusion\n\nThe examples show that the combination of Robonomics Network and  Ocean Protocol creates a fundamentally new type of assets, previously unavailable due to poor automation of technical processes and the impossibility of secure control and exchange of their results. Moreover, these are only obvious ideas, and in the future, with the proliferation of IoT and robots, completely new markets for cyber-physical data may appear.","cover_image":{"type":"image","mimeType":"image/jpeg","src":"/assets/static/Robonomics_Ocean_p_2.62c183a.b0cdd904f46ec8194690b17a224c64f9.jpg","size":{"width":1500,"height":675},"sizes":"(max-width: 1500px) 100vw, 1500px","srcset":["/assets/static/Robonomics_Ocean_p_2.9ea8d39.b0cdd904f46ec8194690b17a224c64f9.jpg 480w","/assets/static/Robonomics_Ocean_p_2.6b2ed88.b0cdd904f46ec8194690b17a224c64f9.jpg 1024w","/assets/static/Robonomics_Ocean_p_2.62c183a.b0cdd904f46ec8194690b17a224c64f9.jpg 1500w"],"dataUri":"data:image/svg+xml,%3csvg fill='none' viewBox='0 0 1500 675' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'%3e%3cdefs%3e%3cfilter id='__svg-blur-866be46a1eb78922fd10c7e46f03d691'%3e%3cfeGaussianBlur in='SourceGraphic' stdDeviation='40'/%3e%3c/filter%3e%3c/defs%3e%3cimage x='0' y='0' filter='url(%23__svg-blur-866be46a1eb78922fd10c7e46f03d691)' width='1500' height='675' xlink:href='data:image/jpeg%3bbase64%2c/9j/2wBDAAYEBQYFBAYGBQYHBwYIChAKCgkJChQODwwQFxQYGBcUFhYaHSUfGhsjHBYWICwgIyYnKSopGR8tMC0oMCUoKSj/2wBDAQcHBwoIChMKChMoGhYaKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCj/wAARCAAdAEADASIAAhEBAxEB/8QAGgAAAgMBAQAAAAAAAAAAAAAAAgQBAwUGB//EACwQAAIBAwMBBgYDAAAAAAAAAAECAwAEEQUSITEGEyJBUXEUI2GRobFigcH/xAAaAQACAgMAAAAAAAAAAAAAAAADBAEFAAIG/8QAHhEBAAICAwADAAAAAAAAAAAAAQACAxEEITESQYH/2gAMAwEAAhEDEQA/APKLq4VHckQqg5JOc1XHdC40ya4t2%2bQsmxS2V3Hqdo88Vn3Wp6Z3i/EFpQeAuGAz9SOa17fTLrVLe3ks1jisgpEQZiByckgehrrxreyVRlFj49im7L8v2c5cahcKciRh7MRSzavcg7luLgH6S5/dMS2jG7midMrE2HYZx1wAT6E/7Vfaa1jju3ltLk3kOF3TCMryR5gjg5BH9D1pWy1lngqdDBj7TXkZw2JR/Lg/ioue0t%2bXKALAQcNwSw%2b9F2U1K0065ne7gikZkxGzrkp4Wzj0zkU7281iz1OXbBFGZ1lYmbGXK7pOC3n1B5pS2a%2b9RhxU91M651O5luo0hvZlUgAt3vHvQpq19FvAu5nIPhJORjzyDSOmNCJiZlVuPCH6E0W1n3yLHtQHnaOFzWFl%2b4HR5NXsr2dl1i7dRIYbeLBmlGCWz0VfzzXba5r0GjCPT7TYZ441XDHOwY8PHmcUrpJaCWVrRu4RQdsagbQME46c9K86kmkur9pp3LyySbmY9Sc1Ygcauq%2bsiw2mxPeszMxjiZmPiYg5Y%2bpwaSeaVwcW8br5ggkfuplPWkJmOep%2b9KZnqTjUOpKS/DlzJbxybuAJAePagvLtbgKEtYIMc/KBBP3NUOSepJ96A9aTXfsMrruNC4aWOGN%2bI4%2bOPT1phnVWdIWbuiehPWlbS5kt0lWPGJF2tkeVSp4rarAz/9k=' /%3e%3c/svg%3e"},"locale":"en"}},{"node":{"title":"Robonomics Network x Ocean Protocol Collaboration p.1","path":"/blog/article-ocean-p1/","date":"January 12, 2021","description":"Announcement of the collaboration between OCEAN Protocol and Robonomics Network","content":"import Card from '~/components/TextCard.vue'\n\nWe’re glad to announce that Robonomics Network enters into a partnership with OCEAN protocol.\n\n> Robonomics.network - is a tool that allows developers and engineers to connect IoT & all ROS compatible devices to the digital economy.\n\nWith Robonomics, robots and IoT devices can become autonomous economic agents, meaning they can enter into legal obligations, own things, and do whatever humans can do on the open labor market and even more!\n\nRobots are producing a lot of data daily; some pieces of that data are quite valuable and could be monetized by a robot or its developer. Here comes the OCEAN protocol.\n\n> OCEAN - is a protocol that allows monetizing any kind of data. Participants of the protocol can earn by selling and curating/staking on data.\n\nThe integration aims to create a sandbox for testing collaboration of both technologies for further development of pilot projects and products in 2021.\n\n<Card :image=\"'/avatars/Sergei-Lonshakov.jpg'\" :back=\"'transparent'\">\n\n### Sergei Lonshakov - Software architect at Robonomics.Network - \n\n\"Joint experiments of Robonomics and OCEAN teams on the crossing subjects, specifically launch of the cyber-physical-systems and processing produced data will allow merging teams knowledge and could lead to marvelous discoveries within 1 year.\"\n\n</Card>\n\n<Card :image=\"'/avatars/Manan-Patel.jpg'\" :back=\"'transparent'\">\n\n### Manan Patel - Growth Accelerator at Ocean Protocol -\n\n\"With this collaboration Ocean Protocol will help Robonomics to leverage their technology and discover new use cases in securely monetising plethora of data generated by robots and helping robots and related IoT devices become revenue generating machines.\"\n\n</Card>\n\nOne of the first milestones for this collaboration will be creating a course.\nIt’ll explain how to launch a device on Robonomics Network then store and monetize data on OCEAN protocol in virtual environment.\n\nWe’ll release 2nd part of this article to dive deeper into the possible use-cases of this integration.\n","cover_image":{"type":"image","mimeType":"image/jpeg","src":"/assets/static/Robonomics_Ocean_1.62c183a.d9c64314843892a205d7c12282e59ca2.jpg","size":{"width":1500,"height":676},"sizes":"(max-width: 1500px) 100vw, 1500px","srcset":["/assets/static/Robonomics_Ocean_1.9ea8d39.d9c64314843892a205d7c12282e59ca2.jpg 480w","/assets/static/Robonomics_Ocean_1.6b2ed88.d9c64314843892a205d7c12282e59ca2.jpg 1024w","/assets/static/Robonomics_Ocean_1.62c183a.d9c64314843892a205d7c12282e59ca2.jpg 1500w"],"dataUri":"data:image/svg+xml,%3csvg fill='none' viewBox='0 0 1500 676' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'%3e%3cdefs%3e%3cfilter id='__svg-blur-1eb3e02e108b027f48ca0ffbdea9227a'%3e%3cfeGaussianBlur in='SourceGraphic' stdDeviation='40'/%3e%3c/filter%3e%3c/defs%3e%3cimage x='0' y='0' filter='url(%23__svg-blur-1eb3e02e108b027f48ca0ffbdea9227a)' width='1500' height='676' xlink:href='data:image/jpeg%3bbase64%2c/9j/2wBDAAYEBQYFBAYGBQYHBwYIChAKCgkJChQODwwQFxQYGBcUFhYaHSUfGhsjHBYWICwgIyYnKSopGR8tMC0oMCUoKSj/2wBDAQcHBwoIChMKChMoGhYaKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCj/wAARCAAdAEADASIAAhEBAxEB/8QAGwAAAgMBAQEAAAAAAAAAAAAAAwQAAgUBBgf/xAAqEAACAQMCBAYCAwAAAAAAAAABAgMABBESIQUTMVEGIkFhcYGRsRSh4f/EABkBAQADAQEAAAAAAAAAAAAAAAQBAgMFBv/EAB4RAAICAgIDAAAAAAAAAAAAAAABAhEDIRJBBAVR/9oADAMBAAIRAxEAPwD52/EQPQCkOIcWwgGcAjb80rwhI%2bIXhjnnEUSrqbcAt7DNDurGK9aSNJihRTysvkYya9VzV0cbB6iDdzRk3d8XJ81ZU0uTvUhR5pWGGKoNTld8DOP3t9074kt4kdJbO5N2qwpzXEbLoPTG46A4APYijZJ9j148cT4ozNYrsqtG5SVGRx1Vhgj6NPeE%2bKW/DeKc%2b5ijkGkaS650kOpyOxwCPTrWx4z47a8StkhiiQzKUIlIywGGyNXbcbbdB1ocsm6NEeduOSXiSHAGN3LZz89qE4RGkXJYjZWG35q1g0azBpwCuNtQ8uapNmWSWSOMBFOToHlWobvZC06H%2bdhgTvigzyeTB3yP771RjQpDmlzno6rxpE/kmNAoiiPuV3oaTyyNiOCJj20/7QpK5OgiYDdiR1oU5Bc3wJFzbZ3kkt42DDGHGQPirXN6J0Ci2toveNME0izEnc7VAaxsNT7HDcO8EcJzoTJ2/dWleMO627MIyANz1%2baHaXMlszmEgFlKnI9KD6VblorWz//Z' /%3e%3c/svg%3e"},"locale":"en"}}]}},"allPostsTags":{"edges":[{"node":{"locale":"zh","tags":[{"id":"Robonomics in Ethereum","title":"Robonomics in Ethereum","path":"/blog/tag/Robonomics%20in%20Ethereum/"},{"id":"Collaborations","title":"Collaborations","path":"/blog/tag/Collaborations/"},{"id":"Smart Contracts","title":"Smart Contracts","path":"/blog/tag/Smart%20Contracts/"},{"id":"Neon","title":"Neon","path":"/blog/tag/Neon/"}]}},{"node":{"locale":"ru","tags":[{"id":"Robonomics в Ethereum","title":"Robonomics в Ethereum","path":"/blog/tag/Robonomics%20%D0%B2%20Ethereum/"},{"id":"Сотрудничество","title":"Сотрудничество","path":"/blog/tag/%D0%A1%D0%BE%D1%82%D1%80%D1%83%D0%B4%D0%BD%D0%B8%D1%87%D0%B5%D1%81%D1%82%D0%B2%D0%BE/"},{"id":"Умные контракты","title":"Умные контракты","path":"/blog/tag/%D0%A3%D0%BC%D0%BD%D1%8B%D0%B5%20%D0%BA%D0%BE%D0%BD%D1%82%D1%80%D0%B0%D0%BA%D1%82%D1%8B/"},{"id":"Neon","title":"Neon","path":"/blog/tag/Neon/"}]}},{"node":{"locale":"pt","tags":[{"id":"Robonomics in Ethereum","title":"Robonomics in Ethereum","path":"/blog/tag/Robonomics%20in%20Ethereum/"},{"id":"Collaborations","title":"Collaborations","path":"/blog/tag/Collaborations/"},{"id":"Smart Contracts","title":"Smart Contracts","path":"/blog/tag/Smart%20Contracts/"},{"id":"Neon","title":"Neon","path":"/blog/tag/Neon/"}]}},{"node":{"locale":"ko","tags":[{"id":"Robonomics in Ethereum","title":"Robonomics in Ethereum","path":"/blog/tag/Robonomics%20in%20Ethereum/"},{"id":"Collaborations","title":"Collaborations","path":"/blog/tag/Collaborations/"},{"id":"Smart Contracts","title":"Smart Contracts","path":"/blog/tag/Smart%20Contracts/"},{"id":"Neon","title":"Neon","path":"/blog/tag/Neon/"}]}},{"node":{"locale":"ja","tags":[{"id":"Robonomics in Ethereum","title":"Robonomics in Ethereum","path":"/blog/tag/Robonomics%20in%20Ethereum/"},{"id":"Collaborations","title":"Collaborations","path":"/blog/tag/Collaborations/"},{"id":"Smart Contracts","title":"Smart Contracts","path":"/blog/tag/Smart%20Contracts/"},{"id":"Neon","title":"Neon","path":"/blog/tag/Neon/"}]}},{"node":{"locale":"it","tags":[{"id":"Robonomics in Ethereum","title":"Robonomics in Ethereum","path":"/blog/tag/Robonomics%20in%20Ethereum/"},{"id":"Collaborations","title":"Collaborations","path":"/blog/tag/Collaborations/"},{"id":"Smart Contracts","title":"Smart Contracts","path":"/blog/tag/Smart%20Contracts/"},{"id":"Neon","title":"Neon","path":"/blog/tag/Neon/"}]}},{"node":{"locale":"fr","tags":[{"id":"Robonomics in Ethereum","title":"Robonomics in Ethereum","path":"/blog/tag/Robonomics%20in%20Ethereum/"},{"id":"Collaborations","title":"Collaborations","path":"/blog/tag/Collaborations/"},{"id":"Smart Contracts","title":"Smart Contracts","path":"/blog/tag/Smart%20Contracts/"},{"id":"Neon","title":"Neon","path":"/blog/tag/Neon/"}]}},{"node":{"locale":"es","tags":[{"id":"Robonomics in Ethereum","title":"Robonomics in Ethereum","path":"/blog/tag/Robonomics%20in%20Ethereum/"},{"id":"Collaborations","title":"Collaborations","path":"/blog/tag/Collaborations/"},{"id":"Smart Contracts","title":"Smart Contracts","path":"/blog/tag/Smart%20Contracts/"},{"id":"Neon","title":"Neon","path":"/blog/tag/Neon/"}]}},{"node":{"locale":"de","tags":[{"id":"Robonomics in Ethereum","title":"Robonomics in Ethereum","path":"/blog/tag/Robonomics%20in%20Ethereum/"},{"id":"Collaborations","title":"Collaborations","path":"/blog/tag/Collaborations/"},{"id":"Smart Contracts","title":"Smart Contracts","path":"/blog/tag/Smart%20Contracts/"},{"id":"Neon","title":"Neon","path":"/blog/tag/Neon/"}]}},{"node":{"locale":"az","tags":[{"id":"Robonomics in Ethereum","title":"Robonomics in Ethereum","path":"/blog/tag/Robonomics%20in%20Ethereum/"},{"id":"Collaborations","title":"Collaborations","path":"/blog/tag/Collaborations/"},{"id":"Smart Contracts","title":"Smart Contracts","path":"/blog/tag/Smart%20Contracts/"},{"id":"Neon","title":"Neon","path":"/blog/tag/Neon/"}]}},{"node":{"locale":"en","tags":[{"id":"Robonomics in Ethereum","title":"Robonomics in Ethereum","path":"/blog/tag/Robonomics%20in%20Ethereum/"},{"id":"Collaborations","title":"Collaborations","path":"/blog/tag/Collaborations/"},{"id":"Smart Contracts","title":"Smart Contracts","path":"/blog/tag/Smart%20Contracts/"},{"id":"Neon","title":"Neon","path":"/blog/tag/Neon/"}]}},{"node":{"locale":"ru","tags":[{"id":"События","title":"События","path":"/blog/tag/%D0%A1%D0%BE%D0%B1%D1%8B%D1%82%D0%B8%D1%8F/"},{"id":"Полкадот","title":"Полкадот","path":"/blog/tag/%D0%9F%D0%BE%D0%BB%D0%BA%D0%B0%D0%B4%D0%BE%D1%82/"},{"id":"Умный дом","title":"Умный дом","path":"/blog/tag/%D0%A3%D0%BC%D0%BD%D1%8B%D0%B9%20%D0%B4%D0%BE%D0%BC/"},{"id":"Интернет вещей","title":"Интернет вещей","path":"/blog/tag/%D0%98%D0%BD%D1%82%D0%B5%D1%80%D0%BD%D0%B5%D1%82%20%D0%B2%D0%B5%D1%89%D0%B5%D0%B9/"}]}},{"node":{"locale":"en","tags":[{"id":"Events","title":"Events","path":"/blog/tag/Events/"},{"id":"Polkadot","title":"Polkadot","path":"/blog/tag/Polkadot/"},{"id":"Smart Home","title":"Smart Home","path":"/blog/tag/Smart%20Home/"},{"id":"Internet of Things","title":"Internet of Things","path":"/blog/tag/Internet%20of%20Things/"}]}},{"node":{"locale":"ru","tags":[{"id":"Философия Робономики","title":"Философия Робономики","path":"/blog/tag/%D0%A4%D0%B8%D0%BB%D0%BE%D1%81%D0%BE%D1%84%D0%B8%D1%8F%20%D0%A0%D0%BE%D0%B1%D0%BE%D0%BD%D0%BE%D0%BC%D0%B8%D0%BA%D0%B8/"}]}},{"node":{"locale":"pt","tags":[{"id":"Filosofia da Robonomia","title":"Filosofia da Robonomia","path":"/blog/tag/Filosofia%20da%20Robonomia/"}]}},{"node":{"locale":"it","tags":[{"id":"Filosofia della Robonomics","title":"Filosofia della Robonomics","path":"/blog/tag/Filosofia%20della%20Robonomics/"}]}},{"node":{"locale":"es","tags":[{"id":"Filosofía de la Robonomía","title":"Filosofía de la Robonomía","path":"/blog/tag/Filosof%C3%ADa%20de%20la%20Robonom%C3%ADa/"}]}},{"node":{"locale":"en","tags":[{"id":"Philosophy of Robonomics","title":"Philosophy of Robonomics","path":"/blog/tag/Philosophy%20of%20Robonomics/"}]}},{"node":{"locale":"ru","tags":[{"id":"Парачейн Робономика","title":"Парачейн Робономика","path":"/blog/tag/%D0%9F%D0%B0%D1%80%D0%B0%D1%87%D0%B5%D0%B9%D0%BD%20%D0%A0%D0%BE%D0%B1%D0%BE%D0%BD%D0%BE%D0%BC%D0%B8%D0%BA%D0%B0/"},{"id":"Сообщество","title":"Сообщество","path":"/blog/tag/%D0%A1%D0%BE%D0%BE%D0%B1%D1%89%D0%B5%D1%81%D1%82%D0%B2%D0%BE/"}]}},{"node":{"locale":"en","tags":[{"id":"Robonomics parachain","title":"Robonomics parachain","path":"/blog/tag/Robonomics%20parachain/"},{"id":"Community","title":"Community","path":"/blog/tag/Community/"}]}},{"node":{"locale":"ru","tags":[{"id":"Парачейн Робономика","title":"Парачейн Робономика","path":"/blog/tag/%D0%9F%D0%B0%D1%80%D0%B0%D1%87%D0%B5%D0%B9%D0%BD%20%D0%A0%D0%BE%D0%B1%D0%BE%D0%BD%D0%BE%D0%BC%D0%B8%D0%BA%D0%B0/"},{"id":"XRT токен","title":"XRT токен","path":"/blog/tag/XRT%20%D1%82%D0%BE%D0%BA%D0%B5%D0%BD/"}]}},{"node":{"locale":"pt","tags":[{"id":"Paracadeia de Robonomics","title":"Paracadeia de Robonomics","path":"/blog/tag/Paracadeia%20de%20Robonomics/"},{"id":"Token XRT","title":"Token XRT","path":"/blog/tag/Token%20XRT/"}]}},{"node":{"locale":"it","tags":[{"id":"Robonomics paracatena","title":"Robonomics paracatena","path":"/blog/tag/Robonomics%20paracatena/"},{"id":"Gettone XRT","title":"Gettone XRT","path":"/blog/tag/Gettone%20XRT/"}]}},{"node":{"locale":"fr","tags":[{"id":"Parachaîne Robonomics","title":"Parachaîne Robonomics","path":"/blog/tag/Paracha%C3%AEne%20Robonomics/"},{"id":"Jeton XRT","title":"Jeton XRT","path":"/blog/tag/Jeton%20XRT/"}]}},{"node":{"locale":"es","tags":[{"id":"Paracaídas Robonomics","title":"Paracaídas Robonomics","path":"/blog/tag/Paraca%C3%ADdas%20Robonomics/"},{"id":"Token XRT","title":"Token XRT","path":"/blog/tag/Token%20XRT/"}]}},{"node":{"locale":"az","tags":[{"id":"Robonimika parachain","title":"Robonimika parachain","path":"/blog/tag/Robonimika%20parachain/"},{"id":"XRT tokeni","title":"XRT tokeni","path":"/blog/tag/XRT%20tokeni/"}]}},{"node":{"locale":"en","tags":[{"id":"Robonomics parachain","title":"Robonomics parachain","path":"/blog/tag/Robonomics%20parachain/"},{"id":"XRT token","title":"XRT token","path":"/blog/tag/XRT%20token/"}]}},{"node":{"locale":"pt","tags":[{"id":"Colaborações","title":"Colaborações","path":"/blog/tag/Colabora%C3%A7%C3%B5es/"},{"id":"Paracadeia de Robonomics","title":"Paracadeia de Robonomics","path":"/blog/tag/Paracadeia%20de%20Robonomics/"}]}},{"node":{"locale":"it","tags":[{"id":"Collaborazioni","title":"Collaborazioni","path":"/blog/tag/Collaborazioni/"},{"id":"Robonomics paracatena","title":"Robonomics paracatena","path":"/blog/tag/Robonomics%20paracatena/"}]}},{"node":{"locale":"az","tags":[{"id":"Əməkdaşlıq","title":"Əməkdaşlıq","path":"/blog/tag/%C6%8Fm%C9%99kda%C5%9Fl%C4%B1q/"},{"id":"Robonimika parachain","title":"Robonimika parachain","path":"/blog/tag/Robonimika%20parachain/"}]}},{"node":{"locale":"en","tags":[{"id":"Collaborations","title":"Collaborations","path":"/blog/tag/Collaborations/"},{"id":"Robonomics parachain","title":"Robonomics parachain","path":"/blog/tag/Robonomics%20parachain/"}]}},{"node":{"locale":"ru","tags":[{"id":"События","title":"События","path":"/blog/tag/%D0%A1%D0%BE%D0%B1%D1%8B%D1%82%D0%B8%D1%8F/"},{"id":"Полкадот","title":"Полкадот","path":"/blog/tag/%D0%9F%D0%BE%D0%BB%D0%BA%D0%B0%D0%B4%D0%BE%D1%82/"}]}},{"node":{"locale":"es","tags":[{"id":"Eventos","title":"Eventos","path":"/blog/tag/Eventos/"},{"id":"Polkadot","title":"Polkadot","path":"/blog/tag/Polkadot/"}]}},{"node":{"locale":"de","tags":[{"id":"Veranstaltungen","title":"Veranstaltungen","path":"/blog/tag/Veranstaltungen/"},{"id":"Polkadot","title":"Polkadot","path":"/blog/tag/Polkadot/"}]}},{"node":{"locale":"en","tags":[{"id":"Events","title":"Events","path":"/blog/tag/Events/"},{"id":"Polkadot","title":"Polkadot","path":"/blog/tag/Polkadot/"}]}},{"node":{"locale":"ru","tags":[{"id":"Парачейн Робономика","title":"Парачейн Робономика","path":"/blog/tag/%D0%9F%D0%B0%D1%80%D0%B0%D1%87%D0%B5%D0%B9%D0%BD%20%D0%A0%D0%BE%D0%B1%D0%BE%D0%BD%D0%BE%D0%BC%D0%B8%D0%BA%D0%B0/"},{"id":"Дорожная карта","title":"Дорожная карта","path":"/blog/tag/%D0%94%D0%BE%D1%80%D0%BE%D0%B6%D0%BD%D0%B0%D1%8F%20%D0%BA%D0%B0%D1%80%D1%82%D0%B0/"},{"id":"Новый релиз","title":"Новый релиз","path":"/blog/tag/%D0%9D%D0%BE%D0%B2%D1%8B%D0%B9%20%D1%80%D0%B5%D0%BB%D0%B8%D0%B7/"}]}},{"node":{"locale":"es","tags":[{"id":"Paracaídas Robonomics","title":"Paracaídas Robonomics","path":"/blog/tag/Paraca%C3%ADdas%20Robonomics/"},{"id":"Mapa ruta","title":"Mapa ruta","path":"/blog/tag/Mapa%20ruta/"},{"id":"Nuevo lanzamiento","title":"Nuevo lanzamiento","path":"/blog/tag/Nuevo%20lanzamiento/"}]}},{"node":{"locale":"de","tags":[{"id":"Robonomics Parachain","title":"Robonomics Parachain","path":"/blog/tag/Robonomics%20Parachain/"},{"id":"Fahrplan","title":"Fahrplan","path":"/blog/tag/Fahrplan/"},{"id":"Neue Version","title":"Neue Version","path":"/blog/tag/Neue%20Version/"}]}},{"node":{"locale":"en","tags":[{"id":"Robonomics parachain","title":"Robonomics parachain","path":"/blog/tag/Robonomics%20parachain/"},{"id":"Roadmap","title":"Roadmap","path":"/blog/tag/Roadmap/"},{"id":"New release","title":"New release","path":"/blog/tag/New%20release/"}]}},{"node":{"locale":"zh","tags":[]}},{"node":{"locale":"ru","tags":[{"id":"Парачейн Робономика","title":"Парачейн Робономика","path":"/blog/tag/%D0%9F%D0%B0%D1%80%D0%B0%D1%87%D0%B5%D0%B9%D0%BD%20%D0%A0%D0%BE%D0%B1%D0%BE%D0%BD%D0%BE%D0%BC%D0%B8%D0%BA%D0%B0/"},{"id":"Сообщество","title":"Сообщество","path":"/blog/tag/%D0%A1%D0%BE%D0%BE%D0%B1%D1%89%D0%B5%D1%81%D1%82%D0%B2%D0%BE/"}]}},{"node":{"locale":"ko","tags":[]}},{"node":{"locale":"ja","tags":[]}},{"node":{"locale":"es","tags":[]}},{"node":{"locale":"de","tags":[{"id":"Robonomics Parachain","title":"Robonomics Parachain","path":"/blog/tag/Robonomics%20Parachain/"},{"id":"Gemeinschaft","title":"Gemeinschaft","path":"/blog/tag/Gemeinschaft/"}]}},{"node":{"locale":"en","tags":[{"id":"Robonomics parachain","title":"Robonomics parachain","path":"/blog/tag/Robonomics%20parachain/"},{"id":"Community","title":"Community","path":"/blog/tag/Community/"}]}},{"node":{"locale":"ru","tags":[{"id":"Парачейн Робономика","title":"Парачейн Робономика","path":"/blog/tag/%D0%9F%D0%B0%D1%80%D0%B0%D1%87%D0%B5%D0%B9%D0%BD%20%D0%A0%D0%BE%D0%B1%D0%BE%D0%BD%D0%BE%D0%BC%D0%B8%D0%BA%D0%B0/"},{"id":"Дорожная карта","title":"Дорожная карта","path":"/blog/tag/%D0%94%D0%BE%D1%80%D0%BE%D0%B6%D0%BD%D0%B0%D1%8F%20%D0%BA%D0%B0%D1%80%D1%82%D0%B0/"},{"id":"Новый релиз","title":"Новый релиз","path":"/blog/tag/%D0%9D%D0%BE%D0%B2%D1%8B%D0%B9%20%D1%80%D0%B5%D0%BB%D0%B8%D0%B7/"}]}},{"node":{"locale":"en","tags":[{"id":"Robonomics parachain","title":"Robonomics parachain","path":"/blog/tag/Robonomics%20parachain/"},{"id":"Roadmap","title":"Roadmap","path":"/blog/tag/Roadmap/"},{"id":"New release","title":"New release","path":"/blog/tag/New%20release/"}]}},{"node":{"locale":"zh","tags":[]}},{"node":{"locale":"ru","tags":[{"id":"Онлайн школа","title":"Онлайн школа","path":"/blog/tag/%D0%9E%D0%BD%D0%BB%D0%B0%D0%B9%D0%BD%20%D1%88%D0%BA%D0%BE%D0%BB%D0%B0/"},{"id":"Сценарии использования","title":"Сценарии использования","path":"/blog/tag/%D0%A1%D1%86%D0%B5%D0%BD%D0%B0%D1%80%D0%B8%D0%B8%20%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F/"}]}},{"node":{"locale":"ko","tags":[]}},{"node":{"locale":"es","tags":[]}},{"node":{"locale":"en","tags":[{"id":"Online school","title":"Online school","path":"/blog/tag/Online%20school/"},{"id":"Use Cases","title":"Use Cases","path":"/blog/tag/Use%20Cases/"}]}},{"node":{"locale":"en","tags":[{"id":"Online school","title":"Online school","path":"/blog/tag/Online%20school/"},{"id":"Philosophy of Robonomics","title":"Philosophy of Robonomics","path":"/blog/tag/Philosophy%20of%20Robonomics/"}]}},{"node":{"locale":"zh","tags":[]}},{"node":{"locale":"ru","tags":[{"id":"Онлайн школа","title":"Онлайн школа","path":"/blog/tag/%D0%9E%D0%BD%D0%BB%D0%B0%D0%B9%D0%BD%20%D1%88%D0%BA%D0%BE%D0%BB%D0%B0/"},{"id":"Философия Робономики","title":"Философия Робономики","path":"/blog/tag/%D0%A4%D0%B8%D0%BB%D0%BE%D1%81%D0%BE%D1%84%D0%B8%D1%8F%20%D0%A0%D0%BE%D0%B1%D0%BE%D0%BD%D0%BE%D0%BC%D0%B8%D0%BA%D0%B8/"}]}},{"node":{"locale":"ko","tags":[]}},{"node":{"locale":"es","tags":[]}},{"node":{"locale":"zh","tags":[]}},{"node":{"locale":"ru","tags":[]}},{"node":{"locale":"ko","tags":[]}},{"node":{"locale":"es","tags":[]}},{"node":{"locale":"en","tags":[{"id":"Online school","title":"Online school","path":"/blog/tag/Online%20school/"},{"id":"Demo","title":"Demo","path":"/blog/tag/Demo/"}]}},{"node":{"locale":"zh","tags":[]}},{"node":{"locale":"ru","tags":[{"id":"Онлайн школа","title":"Онлайн школа","path":"/blog/tag/%D0%9E%D0%BD%D0%BB%D0%B0%D0%B9%D0%BD%20%D1%88%D0%BA%D0%BE%D0%BB%D0%B0/"}]}},{"node":{"locale":"ko","tags":[]}},{"node":{"locale":"es","tags":[]}},{"node":{"locale":"en","tags":[{"id":"Online school","title":"Online school","path":"/blog/tag/Online%20school/"}]}},{"node":{"locale":"ru","tags":[{"id":"Парачейн Робономика","title":"Парачейн Робономика","path":"/blog/tag/%D0%9F%D0%B0%D1%80%D0%B0%D1%87%D0%B5%D0%B9%D0%BD%20%D0%A0%D0%BE%D0%B1%D0%BE%D0%BD%D0%BE%D0%BC%D0%B8%D0%BA%D0%B0/"}]}},{"node":{"locale":"en","tags":[{"id":"Robonomics parachain","title":"Robonomics parachain","path":"/blog/tag/Robonomics%20parachain/"}]}},{"node":{"locale":"ru","tags":[{"id":"Дорожная карта","title":"Дорожная карта","path":"/blog/tag/%D0%94%D0%BE%D1%80%D0%BE%D0%B6%D0%BD%D0%B0%D1%8F%20%D0%BA%D0%B0%D1%80%D1%82%D0%B0/"},{"id":"Сценарии использования","title":"Сценарии использования","path":"/blog/tag/%D0%A1%D1%86%D0%B5%D0%BD%D0%B0%D1%80%D0%B8%D0%B8%20%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F/"}]}},{"node":{"locale":"en","tags":[{"id":"Roadmap","title":"Roadmap","path":"/blog/tag/Roadmap/"},{"id":"Use Cases","title":"Use Cases","path":"/blog/tag/Use%20Cases/"}]}},{"node":{"locale":"en","tags":[{"id":"Robonomics parachain","title":"Robonomics parachain","path":"/blog/tag/Robonomics%20parachain/"},{"id":"Collaborations","title":"Collaborations","path":"/blog/tag/Collaborations/"}]}},{"node":{"locale":"zh","tags":[{"id":"Robonomics 平行链","title":"Robonomics 平行链","path":"/blog/tag/Robonomics%20%E5%B9%B3%E8%A1%8C%E9%93%BE/"}]}},{"node":{"locale":"ru","tags":[{"id":"Парачейн Робономика","title":"Парачейн Робономика","path":"/blog/tag/%D0%9F%D0%B0%D1%80%D0%B0%D1%87%D0%B5%D0%B9%D0%BD%20%D0%A0%D0%BE%D0%B1%D0%BE%D0%BD%D0%BE%D0%BC%D0%B8%D0%BA%D0%B0/"}]}},{"node":{"locale":"ko","tags":[{"id":"로봇공학 파라체인","title":"로봇공학 파라체인","path":"/blog/tag/%EB%A1%9C%EB%B4%87%EA%B3%B5%ED%95%99%20%ED%8C%8C%EB%9D%BC%EC%B2%B4%EC%9D%B8/"}]}},{"node":{"locale":"es","tags":[{"id":"Paracaídas Robonomics","title":"Paracaídas Robonomics","path":"/blog/tag/Paraca%C3%ADdas%20Robonomics/"}]}},{"node":{"locale":"en","tags":[{"id":"Robonomics parachain","title":"Robonomics parachain","path":"/blog/tag/Robonomics%20parachain/"}]}},{"node":{"locale":"zh","tags":[{"id":"Robonomics 平行链","title":"Robonomics 平行链","path":"/blog/tag/Robonomics%20%E5%B9%B3%E8%A1%8C%E9%93%BE/"}]}},{"node":{"locale":"ru","tags":[{"id":"Токен XRT","title":"Токен XRT","path":"/blog/tag/%D0%A2%D0%BE%D0%BA%D0%B5%D0%BD%20XRT/"},{"id":"Парачейн Робономика","title":"Парачейн Робономика","path":"/blog/tag/%D0%9F%D0%B0%D1%80%D0%B0%D1%87%D0%B5%D0%B9%D0%BD%20%D0%A0%D0%BE%D0%B1%D0%BE%D0%BD%D0%BE%D0%BC%D0%B8%D0%BA%D0%B0/"}]}},{"node":{"locale":"en","tags":[{"id":"Robonomics parachain","title":"Robonomics parachain","path":"/blog/tag/Robonomics%20parachain/"}]}},{"node":{"locale":"zh","tags":[{"id":"Robonomics 平行链","title":"Robonomics 平行链","path":"/blog/tag/Robonomics%20%E5%B9%B3%E8%A1%8C%E9%93%BE/"},{"id":"XRT 代币","title":"XRT 代币","path":"/blog/tag/XRT%20%E4%BB%A3%E5%B8%81/"},{"id":"RWS 令牌","title":"RWS 令牌","path":"/blog/tag/RWS%20%E4%BB%A4%E7%89%8C/"},{"id":"质押","title":"质押","path":"/blog/tag/%E8%B4%A8%E6%8A%BC/"},{"id":"新版本","title":"新版本","path":"/blog/tag/%E6%96%B0%E7%89%88%E6%9C%AC/"}]}},{"node":{"locale":"ru","tags":[{"id":"Токен XRT","title":"Токен XRT","path":"/blog/tag/%D0%A2%D0%BE%D0%BA%D0%B5%D0%BD%20XRT/"},{"id":"Токен RWS","title":"Токен RWS","path":"/blog/tag/%D0%A2%D0%BE%D0%BA%D0%B5%D0%BD%20RWS/"},{"id":"Парачейн Робономика","title":"Парачейн Робономика","path":"/blog/tag/%D0%9F%D0%B0%D1%80%D0%B0%D1%87%D0%B5%D0%B9%D0%BD%20%D0%A0%D0%BE%D0%B1%D0%BE%D0%BD%D0%BE%D0%BC%D0%B8%D0%BA%D0%B0/"},{"id":"Новый релиз","title":"Новый релиз","path":"/blog/tag/%D0%9D%D0%BE%D0%B2%D1%8B%D0%B9%20%D1%80%D0%B5%D0%BB%D0%B8%D0%B7/"},{"id":"Стейкинг","title":"Стейкинг","path":"/blog/tag/%D0%A1%D1%82%D0%B5%D0%B9%D0%BA%D0%B8%D0%BD%D0%B3/"}]}},{"node":{"locale":"en","tags":[{"id":"Robonomics parachain","title":"Robonomics parachain","path":"/blog/tag/Robonomics%20parachain/"},{"id":"XRT token","title":"XRT token","path":"/blog/tag/XRT%20token/"},{"id":"RWS token","title":"RWS token","path":"/blog/tag/RWS%20token/"},{"id":"Staking","title":"Staking","path":"/blog/tag/Staking/"},{"id":"New release","title":"New release","path":"/blog/tag/New%20release/"}]}},{"node":{"locale":"en","tags":[{"id":"Collaborations","title":"Collaborations","path":"/blog/tag/Collaborations/"},{"id":"Use Cases","title":"Use Cases","path":"/blog/tag/Use%20Cases/"}]}},{"node":{"locale":"zh","tags":[]}},{"node":{"locale":"ru","tags":[]}},{"node":{"locale":"en","tags":[{"id":"Robonomics parachain","title":"Robonomics parachain","path":"/blog/tag/Robonomics%20parachain/"},{"id":"Internet of Things","title":"Internet of Things","path":"/blog/tag/Internet%20of%20Things/"},{"id":"Collaborations","title":"Collaborations","path":"/blog/tag/Collaborations/"},{"id":"Use Cases","title":"Use Cases","path":"/blog/tag/Use%20Cases/"}]}},{"node":{"locale":"en","tags":[{"id":"Robonomics parachain","title":"Robonomics parachain","path":"/blog/tag/Robonomics%20parachain/"}]}},{"node":{"locale":"en","tags":[{"id":"Robonomics parachain","title":"Robonomics parachain","path":"/blog/tag/Robonomics%20parachain/"},{"id":"XRT token","title":"XRT token","path":"/blog/tag/XRT%20token/"},{"id":"Staking","title":"Staking","path":"/blog/tag/Staking/"},{"id":"Talk with team","title":"Talk with team","path":"/blog/tag/Talk%20with%20team/"}]}},{"node":{"locale":"en","tags":[{"id":"Robonomics parachain","title":"Robonomics parachain","path":"/blog/tag/Robonomics%20parachain/"},{"id":"XRT token","title":"XRT token","path":"/blog/tag/XRT%20token/"},{"id":"Staking","title":"Staking","path":"/blog/tag/Staking/"},{"id":"Roadmap","title":"Roadmap","path":"/blog/tag/Roadmap/"}]}},{"node":{"locale":"en","tags":[{"id":"Robonomics parachain","title":"Robonomics parachain","path":"/blog/tag/Robonomics%20parachain/"}]}},{"node":{"locale":"en","tags":[{"id":"Collaborations","title":"Collaborations","path":"/blog/tag/Collaborations/"}]}},{"node":{"locale":"en","tags":[{"id":"Robonomics parachain","title":"Robonomics parachain","path":"/blog/tag/Robonomics%20parachain/"}]}},{"node":{"locale":"en","tags":[{"id":"Robonomics parachain","title":"Robonomics parachain","path":"/blog/tag/Robonomics%20parachain/"},{"id":"Talk with team","title":"Talk with team","path":"/blog/tag/Talk%20with%20team/"}]}},{"node":{"locale":"en","tags":[{"id":"Robonomics parachain","title":"Robonomics parachain","path":"/blog/tag/Robonomics%20parachain/"}]}},{"node":{"locale":"en","tags":[{"id":"Robonomics parachain","title":"Robonomics parachain","path":"/blog/tag/Robonomics%20parachain/"}]}},{"node":{"locale":"en","tags":[{"id":"Events","title":"Events","path":"/blog/tag/Events/"}]}},{"node":{"locale":"en","tags":[{"id":"Robonomics parachain","title":"Robonomics parachain","path":"/blog/tag/Robonomics%20parachain/"},{"id":"XRT token","title":"XRT token","path":"/blog/tag/XRT%20token/"},{"id":"Use Cases","title":"Use Cases","path":"/blog/tag/Use%20Cases/"}]}},{"node":{"locale":"en","tags":[{"id":"Robonomics parachain","title":"Robonomics parachain","path":"/blog/tag/Robonomics%20parachain/"},{"id":"XRT token","title":"XRT token","path":"/blog/tag/XRT%20token/"},{"id":"Robonomics in Ethereum","title":"Robonomics in Ethereum","path":"/blog/tag/Robonomics%20in%20Ethereum/"}]}},{"node":{"locale":"en","tags":[{"id":"Robonomics parachain","title":"Robonomics parachain","path":"/blog/tag/Robonomics%20parachain/"},{"id":"RWS token","title":"RWS token","path":"/blog/tag/RWS%20token/"},{"id":"Subscription","title":"Subscription","path":"/blog/tag/Subscription/"}]}},{"node":{"locale":"en","tags":[{"id":"Robonomics parachain","title":"Robonomics parachain","path":"/blog/tag/Robonomics%20parachain/"},{"id":"RWS token","title":"RWS token","path":"/blog/tag/RWS%20token/"},{"id":"Subscription","title":"Subscription","path":"/blog/tag/Subscription/"}]}},{"node":{"locale":"en","tags":[{"id":"Roadmap","title":"Roadmap","path":"/blog/tag/Roadmap/"},{"id":"Robonomics parachain","title":"Robonomics parachain","path":"/blog/tag/Robonomics%20parachain/"}]}},{"node":{"locale":"en","tags":[{"id":"Online school","title":"Online school","path":"/blog/tag/Online%20school/"}]}},{"node":{"locale":"en","tags":[{"id":"Collaborations","title":"Collaborations","path":"/blog/tag/Collaborations/"}]}},{"node":{"locale":"en","tags":[{"id":"Use Cases","title":"Use Cases","path":"/blog/tag/Use%20Cases/"}]}},{"node":{"locale":"en","tags":[{"id":"Talk with team","title":"Talk with team","path":"/blog/tag/Talk%20with%20team/"}]}},{"node":{"locale":"en","tags":[]}},{"node":{"locale":"en","tags":[]}},{"node":{"locale":"en","tags":[]}},{"node":{"locale":"en","tags":[{"id":"Robonomics parachain","title":"Robonomics parachain","path":"/blog/tag/Robonomics%20parachain/"}]}}]}},"context":{}}