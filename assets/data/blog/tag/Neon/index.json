{"hash":"ba682612d17231fa937fa58fc3af4342278ec20c","data":{"TagPosts":{"title":"Neon","belongsTo":{"totalCount":11,"pageInfo":{"totalPages":1,"currentPage":1},"edges":[{"node":{"title":"Testing Neon EVM with Robonomics Smart Contracts","path":"/blog/testing-neon-with-robonomics/","date":"October 3, 2022","description":"The purpose of these tests were to validate the readiness of the Neon platform to move to the production stage using Robonomics smart contracts, which allow cyber-physical systems (robots) to make technical-economic transactions.","content":"\n## TL;DR\n\nThe purpose of these tests were to validate the readiness of the [Neon](https://neon-labs.org/) platform to move to the production stage using Robonomics smart contracts, which allow cyber-physical systems (robots) to make technical-economic transactions.\n\nIn the Robonomics network, interaction is established between two parties: Promisee - the one who orders the service, sends a description of technical task and transfers funds for its execution; Promisor - one who performs a service. A typical scenario was tested, whereby a liability contract is concluded between a Promisee and a Promisor - this was followed by validation of the resulting work by a third party, and a commission payment to the node that accompanied the contract between the parties.\n\nFor this example, a simulation of a robotic arm was used, which was asked to perform a sequence of actions. The tests were successful.\n\n## Scope and Goals of Testing\n\nEngineers of [Multi-Agent Systems](https://multi-agent.io/) have been working with [Robonomics Network](https://robonomics.network/) for several years. The first implementation of the Robonomics Network was created for the Ethereum network. It is a set of smart contracts for machine-to-machine communication.\n\nThe core of the Robonomics Network is the [Liability](https://github.com/airalab/robonomics_contracts/blob/master/contracts/robonomics/Liability.sol) contract, a smart contract that reproduces the typical relationship between the customer of a service (Promisee) and the service provider (Promisor), and includes the technical and economic parameters of the transaction between them. The parties can be either an autonomous agent and a person (human-to-machine interaction), or purely two autonomous agents (machine-to-machine interaction). The Promisee and Promisor broadcast messages with the parameters of their technical-economic transaction, and then the conclusion of the transaction is provided by a special node - the Provider - which looks for matches of these parameters. Providers are controlled by [Lighthouse](https://github.com/airalab/robonomics_contracts/blob/master/contracts/robonomics/Lighthouse.sol), which is a special smart contract that executes a transaction when the provider establishes a market match between the parties.\n\nThere are three scenarios in which the fulfillment of an obligation can take place:\n\n1. A simple commitment (with no verification of the final result, and no commission paid to Provider nodes)\n2. Obligation with a commission paid to the Provider\n3. Commitment with a commission to the Provider and validation of the results with the help of a third party - observing network.\n\nThe purpose of this test is to test the most complex, third Robonomics scenario on the Neon EVM platform.\n\n## Testing Scenarios Description\n\nAs we develop the industrial zones and the infrastructure of modern cities, the emergence of fully automated enterprises and services that are controlled by cyber-physical systems (CPS) and which provide their services as autonomous agents is highly likely. In this regard, we can also expect the formation of networks of autonomous CPS in order to increase the speed and quality of communication in the process of production and provision of services.\n\nIn order to take full advantage of the possibilities of smart contracts, a scenario of interaction between two autonomous economic agents was chosen. Consider the liability life cycle in the Robonomics network:\n\n![Liability Life Cycle](./images/testing-neon-with-robonomics/step-by-step-3.jpg)\n\nThe figure above shows that the Robonomics network provider calls the Lighthouse contract, which in turn calls the [contract factory](https://github.com/airalab/robonomics_contracts/blob/master/contracts/robonomics/Factory.sol) to create the Liability contract. The Liability contract contains data about the transaction, such as the terms of reference, payment for the service, validator address and the deadline.\n\nTo learn more about the possible use cases for Robonomics, check out the Robonomics [R&D](https://wiki.robonomics.network/docs/en/r-and-d-based-on-robonomics-network/#launching-a-drone-under-the-control-of-a-decentralized-computer) page!\n\nTo replicate the entire Robonomics infrastructure on the Neon network, we will implement a robot launch scenario through a Liability contract similar to this [example](https://wiki.robonomics.network/docs/en/kuka/). If the script can be repeated, then all functions will work.\n\n## Deliverables\n\nThe source code for the Robonomics contracts is available [here](https://github.com/airalab/robonomics_contracts).\nThe contracts use many features of the Ethereum VM which includes:\n\n- ERC20 [XRT](https://github.com/airalab/robonomics_contracts/blob/master/contracts/robonomics/XRT.sol) Token\n- [Factory](https://github.com/airalab/robonomics_contracts/blob/master/contracts/robonomics/Factory.sol)\n- Own contract for [ENS](https://github.com/airalab/robonomics_contracts/blob/master/contracts/ens/ENS.sol)\n- [Proxy](https://github.com/airalab/robonomics_contracts/blob/master/contracts/misc/SharedCode.sol) for contracts\n- Various modifiers and roles in contracts\n\nAddresses of contracts in the Neon devnet network https://devnet.neonevm.org\n\n| Contract Name  | Address                                    |\n|----------------|--------------------------------------------|\n| Migrations     | 0x1DC538bE2C8572509a571B150f11aB55E52EF12E |\n| ENS            | 0xa7AEa12F60D0278F01e14DBC7cc459d04d051406 |\n| DutchAuction   | 0xF44F8803548D72Dbc3E28340EFD7b5328aa4F058 |\n| Liability      | 0xA694196351dc1488e3884eCc6b650F0d8D55346a |\n| Lighthouse     | 0x80FB5CC4c396E272b56700E6ffF5DBf4661013A8 |\n| XRT            | 0x3322d7D99cF65Cab5A92073c928b5E9674af3c29 |\n| PublicAmbix    | 0x85c03bE5ccFf11E79a0A776D183eF067590549d1 |\n| Factory        | 0xCFa833bF0D46369D9024f95c9C8dFa1E4a07806C |\n| PublicResolver | 0xAC9E9AA8A4cB524FE87f2b14489F1D6bE68dc46e |\n\n[Source code](https://github.com/Multi-Agent-io/neon-kuka-demo) for the scenario\n\n## Changes Made to Original Contracts\n\nThe contracts are written for Solidity 0.5.0. As such, no changes were required when deploying and using the contracts.\n\n## Testing Workflow\n\nIn general, the test consists of sending corresponding messages from one agent to another.\n\nNext, the Promisor finds a new liability contract in the network and begins to execute it. Upon completion of the work, a message is sent with the result, which is then recorded in the contract.\n\nStep-by-step instructions for launching are in [README.md](https://github.com/Multi-Agent-io/neon-kuka-demo/blob/main/README.md)\n\n## Testing Results in Detail\n\nScreencast of the process\n\nhttps://youtu.be/fYJVF7KrNnI\n\n![Liability](./images/testing-neon-with-robonomics/liability.jpg)\n\nWhen the simulation starts, an offer message is created, and a demand message comes from the Promisee, after which a Liability contract is created using the createLiability function of the Lighthouse contract. With the help of the XRT contract, tokens are transferred from the Promisee’s address to the address of the Liability contract.\n\nAfter a new Liability contract has been discovered on the Neon devnet, the agent starts working. The result of the work (telemetry) is written to a file and sent to IPFS, the hash from the file is saved as a result.\n\nAfter the work is completed, the Liability contract is finalized using the finalizeLiability() function of the Lighthouse contract and the tokens are transferred from the Liability address to the addresses of the Promisor and Validator.\n\nThe successful execution of the simulation showed that all contracts worked correctly and the Neon platform works.\n\n## Neon Platform Drawbacks\n\n### Truffle fails if it doesn't get a response from the network\n\nDuring the process of deploying contracts, it turned out that the proxy does not always return a response on time, which is why Truffle ends with an error:\n\n```\nTypeError: Cannot read properties of null (reading 'from')                                    \n    at Web3InterfaceAdapter.<anonymous> (/usr/lib/node_modules/truffle/build/webpack:/packages\n/interface-adapter/dist/adapter/web3/index.js:71:1)                                           \n    at Generator.next (<anonymous>)                                                           \n    at fulfilled (/usr/lib/node_modules/truffle/build/webpack:/packages/interface-adapter/dist\n/adapter/web3/index.js:5:43)                                                                  \n    at runMicrotasks (<anonymous>)\n    at processTicksAndRejections (node:internal/process/task_queues:96:5)\nTruffle v5.5.23 (core: 5.5.23)\nNode v16.14.0\n```\n\nIt was not possible to find a relationship between the test conditions and the occurrence of an error, but most likely Neon EVM cannot send a transaction receipt, and Truffle cannot process a Null response.\n\nIf we add timeout and retry here [index.ts#L75](https://github.com/trufflesuite/truffle/blob/develop/packages/interface-adapter/lib/adapter/web3/index.ts#L75), then the deployment should proceed without errors.\n\n### No WS/WSS Endpoint\n\nNeon EVM does not have a WS/WSS endpoint unlike Ethereum, which makes it impossible to subscribe to events from the network. Therefore, during testing, we monitored the events manually.\n\n### No Event Names\n\nNeon EVM returns rather poor descriptions of events after a transaction, for example:\n\n```\n events: {\n    '0': {\n      address: '0xCFa833bF0D46369D9024f95c9C8dFa1E4a07806C',\n      transactionHash: '0x9894a984e6b3f6ce469c8837e11739f6e50d00216cf7c5bc3d32da106a58d50a',\n      transactionLogIndex: '0x1',\n      blockHash: '0x72040f317d3a469d30327d4e1def903790b70dbede46b4f0ea4f28f30a679a80',\n      blockNumber: 156073183,\n      transactionIndex: 0,\n      logIndex: 1,\n      id: 'log_e51e2f9f',\n      returnValues: Result {},\n      event: undefined,\n      signature: null,\n      raw: [Object]\n    },\n...\n```\n\nInstead of 0, 1, etc. we expected to see named events.\n\n## Conclusion\n\nUsing the Neon EVM platform, a scenario was successfully tested whereby a liability contract between a Promisee and a Promisor is concluded with subsequent validation of the result of the work done by a third party. Additionally, a Provider participated, who checked the coincidence of supply and demand between the parties, and received a commission for this work.\n\nThe demonstration used a simulation of a robotic arm that was hired to perform a sequence of actions. As a result of the work, the robot sent a file with telemetry received during the task.\n\nDespite some peculiarities in the operation of the network, in the end, all participating contracts showed their operability in the Neon environment.\n\n\n\n","cover_image":{"type":"image","mimeType":"image/jpeg","src":"/assets/static/blog_cover_neon_multi-agent.62c183a.6231caf624da0ea84dd55d0582533702.jpg","size":{"width":1500,"height":675},"sizes":"(max-width: 1500px) 100vw, 1500px","srcset":["/assets/static/blog_cover_neon_multi-agent.9ea8d39.6231caf624da0ea84dd55d0582533702.jpg 480w","/assets/static/blog_cover_neon_multi-agent.6b2ed88.6231caf624da0ea84dd55d0582533702.jpg 1024w","/assets/static/blog_cover_neon_multi-agent.62c183a.6231caf624da0ea84dd55d0582533702.jpg 1500w"],"dataUri":"data:image/svg+xml,%3csvg fill='none' viewBox='0 0 1500 675' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'%3e%3cdefs%3e%3cfilter id='__svg-blur-6809607028734338a4644390df615667'%3e%3cfeGaussianBlur in='SourceGraphic' stdDeviation='40'/%3e%3c/filter%3e%3c/defs%3e%3cimage x='0' y='0' filter='url(%23__svg-blur-6809607028734338a4644390df615667)' width='1500' height='675' xlink:href='data:image/jpeg%3bbase64%2c/9j/2wBDAAYEBQYFBAYGBQYHBwYIChAKCgkJChQODwwQFxQYGBcUFhYaHSUfGhsjHBYWICwgIyYnKSopGR8tMC0oMCUoKSj/2wBDAQcHBwoIChMKChMoGhYaKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCj/wAARCAAdAEADASIAAhEBAxEB/8QAGwAAAgMAAwAAAAAAAAAAAAAAAgUDBAYBBwj/xAAuEAACAQMDAgQFBAMAAAAAAAABAgMABBEFEiEGMRRBQlETUnGBkQciMkNyobH/xAAYAQADAQEAAAAAAAAAAAAAAAAAAQMCBP/EACARAAIDAAICAwEAAAAAAAAAAAECAAMREjEhQTJxofD/2gAMAwEAAhEDEQA/APL0UXxFc7gNoz2qOiSRkBCnAPettddCi36et9V8aJI7jTxepGAAysFyykHuO2CPI11VUvccQdStNFlpPAbkw9HAqvIFclVPcgZP4rZWv6fz3Ns08Ws6WVXYGUu27ceSoGMk8gD5jwOaVa/09JoAhdr20u3ZtrJCTlDjIzke34PB5qIMkevESXMaxTMiljtJB3DBB9iKAxuApKNhslTjv5cVahWG4uH8ZN8A/wCJbLfXyrfab0zjRJjbiSSWJC8Mwm%2bGWZkDEKApwBkDk4J9qZgNzzOtSCO4I%2boqSSLZEj7gd3lg021/T721LvqM8ksgYBCxLZX3z%2bP90naRmUKT%2b0dqBA76g1ea8vp7SNZL2ZobcFI42kOEBGCFHkCOKo0ayMsbIP4t3pgkR6w%2bJkf2FP8AobSU1jqW1t5wfCJumuGHpjUZJ/4PvSGtV0W6JpfUG6PcwtgyMGKlSA3PHfv2NStV2QqnZlaWRbA1nQ/v2UtZk0G6txcaet3b3juVeB8MgA/sBA9Xy44Oe4q/o3VEqW62MkT7ZI1hYpOyBsKEHHpO0YJGM45rJDtXNCJwGbv3MO3M8iIx1i%2buNUl8ZdOmTwqKMbR7UuozKxiEfpBzQVSYG%2b5//9k=' /%3e%3c/svg%3e"},"locale":"en"}},{"node":{"title":"Testing Neon EVM with Robonomics Smart Contracts","path":"/blog/az/testing-neon-with-robonomics/","date":"October 3, 2022","description":"The purpose of these tests were to validate the readiness of the Neon platform to move to the production stage using Robonomics smart contracts, which allow cyber-physical systems (robots) to make technical-economic transactions.","content":"\n## TL;DR\n\nThe purpose of these tests were to validate the readiness of the [Neon](https://neon-labs.org/) platform to move to the production stage using Robonomics smart contracts, which allow cyber-physical systems (robots) to make technical-economic transactions.\n\nIn the Robonomics network, interaction is established between two parties: Promisee - the one who orders the service, sends a description of technical task and transfers funds for its execution; Promisor - one who performs a service. A typical scenario was tested, whereby a liability contract is concluded between a Promisee and a Promisor - this was followed by validation of the resulting work by a third party, and a commission payment to the node that accompanied the contract between the parties.\n\nFor this example, a simulation of a robotic arm was used, which was asked to perform a sequence of actions. The tests were successful.\n\n## Scope and Goals of Testing\n\nEngineers of [Multi-Agent Systems](https://multi-agent.io/) have been working with [Robonomics Network](https://robonomics.network/) for several years. The first implementation of the Robonomics Network was created for the Ethereum network. It is a set of smart contracts for machine-to-machine communication.\n\nThe core of the Robonomics Network is the [Liability](https://github.com/airalab/robonomics_contracts/blob/master/contracts/robonomics/Liability.sol) contract, a smart contract that reproduces the typical relationship between the customer of a service (Promisee) and the service provider (Promisor), and includes the technical and economic parameters of the transaction between them. The parties can be either an autonomous agent and a person (human-to-machine interaction), or purely two autonomous agents (machine-to-machine interaction). The Promisee and Promisor broadcast messages with the parameters of their technical-economic transaction, and then the conclusion of the transaction is provided by a special node - the Provider - which looks for matches of these parameters. Providers are controlled by [Lighthouse](https://github.com/airalab/robonomics_contracts/blob/master/contracts/robonomics/Lighthouse.sol), which is a special smart contract that executes a transaction when the provider establishes a market match between the parties.\n\nThere are three scenarios in which the fulfillment of an obligation can take place:\n\n1. A simple commitment (with no verification of the final result, and no commission paid to Provider nodes)\n2. Obligation with a commission paid to the Provider\n3. Commitment with a commission to the Provider and validation of the results with the help of a third party - observing network.\n\nThe purpose of this test is to test the most complex, third Robonomics scenario on the Neon EVM platform.\n\n## Testing Scenarios Description\n\nAs we develop the industrial zones and the infrastructure of modern cities, the emergence of fully automated enterprises and services that are controlled by cyber-physical systems (CPS) and which provide their services as autonomous agents is highly likely. In this regard, we can also expect the formation of networks of autonomous CPS in order to increase the speed and quality of communication in the process of production and provision of services.\n\nIn order to take full advantage of the possibilities of smart contracts, a scenario of interaction between two autonomous economic agents was chosen. Consider the liability life cycle in the Robonomics network:\n\n![Liability Life Cycle](./images/testing-neon-with-robonomics/step-by-step-3.jpg)\n\nThe figure above shows that the Robonomics network provider calls the Lighthouse contract, which in turn calls the [contract factory](https://github.com/airalab/robonomics_contracts/blob/master/contracts/robonomics/Factory.sol) to create the Liability contract. The Liability contract contains data about the transaction, such as the terms of reference, payment for the service, validator address and the deadline.\n\nTo learn more about the possible use cases for Robonomics, check out the Robonomics [R&D](https://wiki.robonomics.network/docs/en/r-and-d-based-on-robonomics-network/#launching-a-drone-under-the-control-of-a-decentralized-computer) page!\n\nTo replicate the entire Robonomics infrastructure on the Neon network, we will implement a robot launch scenario through a Liability contract similar to this [example](https://wiki.robonomics.network/docs/en/kuka/). If the script can be repeated, then all functions will work.\n\n## Deliverables\n\nThe source code for the Robonomics contracts is available [here](https://github.com/airalab/robonomics_contracts).\nThe contracts use many features of the Ethereum VM which includes:\n\n- ERC20 [XRT](https://github.com/airalab/robonomics_contracts/blob/master/contracts/robonomics/XRT.sol) Token\n- [Factory](https://github.com/airalab/robonomics_contracts/blob/master/contracts/robonomics/Factory.sol)\n- Own contract for [ENS](https://github.com/airalab/robonomics_contracts/blob/master/contracts/ens/ENS.sol)\n- [Proxy](https://github.com/airalab/robonomics_contracts/blob/master/contracts/misc/SharedCode.sol) for contracts\n- Various modifiers and roles in contracts\n\nAddresses of contracts in the Neon devnet network https://devnet.neonevm.org\n\n| Contract Name  | Address                                    |\n|----------------|--------------------------------------------|\n| Migrations     | 0x1DC538bE2C8572509a571B150f11aB55E52EF12E |\n| ENS            | 0xa7AEa12F60D0278F01e14DBC7cc459d04d051406 |\n| DutchAuction   | 0xF44F8803548D72Dbc3E28340EFD7b5328aa4F058 |\n| Liability      | 0xA694196351dc1488e3884eCc6b650F0d8D55346a |\n| Lighthouse     | 0x80FB5CC4c396E272b56700E6ffF5DBf4661013A8 |\n| XRT            | 0x3322d7D99cF65Cab5A92073c928b5E9674af3c29 |\n| PublicAmbix    | 0x85c03bE5ccFf11E79a0A776D183eF067590549d1 |\n| Factory        | 0xCFa833bF0D46369D9024f95c9C8dFa1E4a07806C |\n| PublicResolver | 0xAC9E9AA8A4cB524FE87f2b14489F1D6bE68dc46e |\n\n[Source code](https://github.com/Multi-Agent-io/neon-kuka-demo) for the scenario\n\n## Changes Made to Original Contracts\n\nThe contracts are written for Solidity 0.5.0. As such, no changes were required when deploying and using the contracts.\n\n## Testing Workflow\n\nIn general, the test consists of sending corresponding messages from one agent to another.\n\nNext, the Promisor finds a new liability contract in the network and begins to execute it. Upon completion of the work, a message is sent with the result, which is then recorded in the contract.\n\nStep-by-step instructions for launching are in [README.md](https://github.com/Multi-Agent-io/neon-kuka-demo/blob/main/README.md)\n\n## Testing Results in Detail\n\nScreencast of the process\n\nhttps://youtu.be/fYJVF7KrNnI\n\n![Liability](./images/testing-neon-with-robonomics/liability.jpg)\n\nWhen the simulation starts, an offer message is created, and a demand message comes from the Promisee, after which a Liability contract is created using the createLiability function of the Lighthouse contract. With the help of the XRT contract, tokens are transferred from the Promisee’s address to the address of the Liability contract.\n\nAfter a new Liability contract has been discovered on the Neon devnet, the agent starts working. The result of the work (telemetry) is written to a file and sent to IPFS, the hash from the file is saved as a result.\n\nAfter the work is completed, the Liability contract is finalized using the finalizeLiability() function of the Lighthouse contract and the tokens are transferred from the Liability address to the addresses of the Promisor and Validator.\n\nThe successful execution of the simulation showed that all contracts worked correctly and the Neon platform works.\n\n## Neon Platform Drawbacks\n\n### Truffle fails if it doesn't get a response from the network\n\nDuring the process of deploying contracts, it turned out that the proxy does not always return a response on time, which is why Truffle ends with an error:\n\n```\nTypeError: Cannot read properties of null (reading 'from')                                    \n    at Web3InterfaceAdapter.<anonymous> (/usr/lib/node_modules/truffle/build/webpack:/packages\n/interface-adapter/dist/adapter/web3/index.js:71:1)                                           \n    at Generator.next (<anonymous>)                                                           \n    at fulfilled (/usr/lib/node_modules/truffle/build/webpack:/packages/interface-adapter/dist\n/adapter/web3/index.js:5:43)                                                                  \n    at runMicrotasks (<anonymous>)\n    at processTicksAndRejections (node:internal/process/task_queues:96:5)\nTruffle v5.5.23 (core: 5.5.23)\nNode v16.14.0\n```\n\nIt was not possible to find a relationship between the test conditions and the occurrence of an error, but most likely Neon EVM cannot send a transaction receipt, and Truffle cannot process a Null response.\n\nIf we add timeout and retry here [index.ts#L75](https://github.com/trufflesuite/truffle/blob/develop/packages/interface-adapter/lib/adapter/web3/index.ts#L75), then the deployment should proceed without errors.\n\n### No WS/WSS Endpoint\n\nNeon EVM does not have a WS/WSS endpoint unlike Ethereum, which makes it impossible to subscribe to events from the network. Therefore, during testing, we monitored the events manually.\n\n### No Event Names\n\nNeon EVM returns rather poor descriptions of events after a transaction, for example:\n\n```\n events: {\n    '0': {\n      address: '0xCFa833bF0D46369D9024f95c9C8dFa1E4a07806C',\n      transactionHash: '0x9894a984e6b3f6ce469c8837e11739f6e50d00216cf7c5bc3d32da106a58d50a',\n      transactionLogIndex: '0x1',\n      blockHash: '0x72040f317d3a469d30327d4e1def903790b70dbede46b4f0ea4f28f30a679a80',\n      blockNumber: 156073183,\n      transactionIndex: 0,\n      logIndex: 1,\n      id: 'log_e51e2f9f',\n      returnValues: Result {},\n      event: undefined,\n      signature: null,\n      raw: [Object]\n    },\n...\n```\n\nInstead of 0, 1, etc. we expected to see named events.\n\n## Conclusion\n\nUsing the Neon EVM platform, a scenario was successfully tested whereby a liability contract between a Promisee and a Promisor is concluded with subsequent validation of the result of the work done by a third party. Additionally, a Provider participated, who checked the coincidence of supply and demand between the parties, and received a commission for this work.\n\nThe demonstration used a simulation of a robotic arm that was hired to perform a sequence of actions. As a result of the work, the robot sent a file with telemetry received during the task.\n\nDespite some peculiarities in the operation of the network, in the end, all participating contracts showed their operability in the Neon environment.\n\n\n\n","cover_image":{"type":"image","mimeType":"image/jpeg","src":"/assets/static/blog_cover_neon_multi-agent.62c183a.6231caf624da0ea84dd55d0582533702.jpg","size":{"width":1500,"height":675},"sizes":"(max-width: 1500px) 100vw, 1500px","srcset":["/assets/static/blog_cover_neon_multi-agent.9ea8d39.6231caf624da0ea84dd55d0582533702.jpg 480w","/assets/static/blog_cover_neon_multi-agent.6b2ed88.6231caf624da0ea84dd55d0582533702.jpg 1024w","/assets/static/blog_cover_neon_multi-agent.62c183a.6231caf624da0ea84dd55d0582533702.jpg 1500w"],"dataUri":"data:image/svg+xml,%3csvg fill='none' viewBox='0 0 1500 675' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'%3e%3cdefs%3e%3cfilter id='__svg-blur-6809607028734338a4644390df615667'%3e%3cfeGaussianBlur in='SourceGraphic' stdDeviation='40'/%3e%3c/filter%3e%3c/defs%3e%3cimage x='0' y='0' filter='url(%23__svg-blur-6809607028734338a4644390df615667)' width='1500' height='675' xlink:href='data:image/jpeg%3bbase64%2c/9j/2wBDAAYEBQYFBAYGBQYHBwYIChAKCgkJChQODwwQFxQYGBcUFhYaHSUfGhsjHBYWICwgIyYnKSopGR8tMC0oMCUoKSj/2wBDAQcHBwoIChMKChMoGhYaKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCj/wAARCAAdAEADASIAAhEBAxEB/8QAGwAAAgMAAwAAAAAAAAAAAAAAAgUDBAYBBwj/xAAuEAACAQMDAgQFBAMAAAAAAAABAgMABBEFEiEGMRRBQlETUnGBkQciMkNyobH/xAAYAQADAQEAAAAAAAAAAAAAAAAAAQMCBP/EACARAAIDAAICAwEAAAAAAAAAAAECAAMREjEhQTJxofD/2gAMAwEAAhEDEQA/APL0UXxFc7gNoz2qOiSRkBCnAPettddCi36et9V8aJI7jTxepGAAysFyykHuO2CPI11VUvccQdStNFlpPAbkw9HAqvIFclVPcgZP4rZWv6fz3Ns08Ws6WVXYGUu27ceSoGMk8gD5jwOaVa/09JoAhdr20u3ZtrJCTlDjIzke34PB5qIMkevESXMaxTMiljtJB3DBB9iKAxuApKNhslTjv5cVahWG4uH8ZN8A/wCJbLfXyrfab0zjRJjbiSSWJC8Mwm%2bGWZkDEKApwBkDk4J9qZgNzzOtSCO4I%2boqSSLZEj7gd3lg021/T721LvqM8ksgYBCxLZX3z%2bP90naRmUKT%2b0dqBA76g1ea8vp7SNZL2ZobcFI42kOEBGCFHkCOKo0ayMsbIP4t3pgkR6w%2bJkf2FP8AobSU1jqW1t5wfCJumuGHpjUZJ/4PvSGtV0W6JpfUG6PcwtgyMGKlSA3PHfv2NStV2QqnZlaWRbA1nQ/v2UtZk0G6txcaet3b3juVeB8MgA/sBA9Xy44Oe4q/o3VEqW62MkT7ZI1hYpOyBsKEHHpO0YJGM45rJDtXNCJwGbv3MO3M8iIx1i%2buNUl8ZdOmTwqKMbR7UuozKxiEfpBzQVSYG%2b5//9k=' /%3e%3c/svg%3e"},"locale":"az"}},{"node":{"title":"Testing Neon EVM with Robonomics Smart Contracts","path":"/blog/de/testing-neon-with-robonomics/","date":"October 3, 2022","description":"The purpose of these tests were to validate the readiness of the Neon platform to move to the production stage using Robonomics smart contracts, which allow cyber-physical systems (robots) to make technical-economic transactions.","content":"\n## TL;DR\n\nThe purpose of these tests were to validate the readiness of the [Neon](https://neon-labs.org/) platform to move to the production stage using Robonomics smart contracts, which allow cyber-physical systems (robots) to make technical-economic transactions.\n\nIn the Robonomics network, interaction is established between two parties: Promisee - the one who orders the service, sends a description of technical task and transfers funds for its execution; Promisor - one who performs a service. A typical scenario was tested, whereby a liability contract is concluded between a Promisee and a Promisor - this was followed by validation of the resulting work by a third party, and a commission payment to the node that accompanied the contract between the parties.\n\nFor this example, a simulation of a robotic arm was used, which was asked to perform a sequence of actions. The tests were successful.\n\n## Scope and Goals of Testing\n\nEngineers of [Multi-Agent Systems](https://multi-agent.io/) have been working with [Robonomics Network](https://robonomics.network/) for several years. The first implementation of the Robonomics Network was created for the Ethereum network. It is a set of smart contracts for machine-to-machine communication.\n\nThe core of the Robonomics Network is the [Liability](https://github.com/airalab/robonomics_contracts/blob/master/contracts/robonomics/Liability.sol) contract, a smart contract that reproduces the typical relationship between the customer of a service (Promisee) and the service provider (Promisor), and includes the technical and economic parameters of the transaction between them. The parties can be either an autonomous agent and a person (human-to-machine interaction), or purely two autonomous agents (machine-to-machine interaction). The Promisee and Promisor broadcast messages with the parameters of their technical-economic transaction, and then the conclusion of the transaction is provided by a special node - the Provider - which looks for matches of these parameters. Providers are controlled by [Lighthouse](https://github.com/airalab/robonomics_contracts/blob/master/contracts/robonomics/Lighthouse.sol), which is a special smart contract that executes a transaction when the provider establishes a market match between the parties.\n\nThere are three scenarios in which the fulfillment of an obligation can take place:\n\n1. A simple commitment (with no verification of the final result, and no commission paid to Provider nodes)\n2. Obligation with a commission paid to the Provider\n3. Commitment with a commission to the Provider and validation of the results with the help of a third party - observing network.\n\nThe purpose of this test is to test the most complex, third Robonomics scenario on the Neon EVM platform.\n\n## Testing Scenarios Description\n\nAs we develop the industrial zones and the infrastructure of modern cities, the emergence of fully automated enterprises and services that are controlled by cyber-physical systems (CPS) and which provide their services as autonomous agents is highly likely. In this regard, we can also expect the formation of networks of autonomous CPS in order to increase the speed and quality of communication in the process of production and provision of services.\n\nIn order to take full advantage of the possibilities of smart contracts, a scenario of interaction between two autonomous economic agents was chosen. Consider the liability life cycle in the Robonomics network:\n\n![Liability Life Cycle](./images/testing-neon-with-robonomics/step-by-step-3.jpg)\n\nThe figure above shows that the Robonomics network provider calls the Lighthouse contract, which in turn calls the [contract factory](https://github.com/airalab/robonomics_contracts/blob/master/contracts/robonomics/Factory.sol) to create the Liability contract. The Liability contract contains data about the transaction, such as the terms of reference, payment for the service, validator address and the deadline.\n\nTo learn more about the possible use cases for Robonomics, check out the Robonomics [R&D](https://wiki.robonomics.network/docs/en/r-and-d-based-on-robonomics-network/#launching-a-drone-under-the-control-of-a-decentralized-computer) page!\n\nTo replicate the entire Robonomics infrastructure on the Neon network, we will implement a robot launch scenario through a Liability contract similar to this [example](https://wiki.robonomics.network/docs/en/kuka/). If the script can be repeated, then all functions will work.\n\n## Deliverables\n\nThe source code for the Robonomics contracts is available [here](https://github.com/airalab/robonomics_contracts).\nThe contracts use many features of the Ethereum VM which includes:\n\n- ERC20 [XRT](https://github.com/airalab/robonomics_contracts/blob/master/contracts/robonomics/XRT.sol) Token\n- [Factory](https://github.com/airalab/robonomics_contracts/blob/master/contracts/robonomics/Factory.sol)\n- Own contract for [ENS](https://github.com/airalab/robonomics_contracts/blob/master/contracts/ens/ENS.sol)\n- [Proxy](https://github.com/airalab/robonomics_contracts/blob/master/contracts/misc/SharedCode.sol) for contracts\n- Various modifiers and roles in contracts\n\nAddresses of contracts in the Neon devnet network https://devnet.neonevm.org\n\n| Contract Name  | Address                                    |\n|----------------|--------------------------------------------|\n| Migrations     | 0x1DC538bE2C8572509a571B150f11aB55E52EF12E |\n| ENS            | 0xa7AEa12F60D0278F01e14DBC7cc459d04d051406 |\n| DutchAuction   | 0xF44F8803548D72Dbc3E28340EFD7b5328aa4F058 |\n| Liability      | 0xA694196351dc1488e3884eCc6b650F0d8D55346a |\n| Lighthouse     | 0x80FB5CC4c396E272b56700E6ffF5DBf4661013A8 |\n| XRT            | 0x3322d7D99cF65Cab5A92073c928b5E9674af3c29 |\n| PublicAmbix    | 0x85c03bE5ccFf11E79a0A776D183eF067590549d1 |\n| Factory        | 0xCFa833bF0D46369D9024f95c9C8dFa1E4a07806C |\n| PublicResolver | 0xAC9E9AA8A4cB524FE87f2b14489F1D6bE68dc46e |\n\n[Source code](https://github.com/Multi-Agent-io/neon-kuka-demo) for the scenario\n\n## Changes Made to Original Contracts\n\nThe contracts are written for Solidity 0.5.0. As such, no changes were required when deploying and using the contracts.\n\n## Testing Workflow\n\nIn general, the test consists of sending corresponding messages from one agent to another.\n\nNext, the Promisor finds a new liability contract in the network and begins to execute it. Upon completion of the work, a message is sent with the result, which is then recorded in the contract.\n\nStep-by-step instructions for launching are in [README.md](https://github.com/Multi-Agent-io/neon-kuka-demo/blob/main/README.md)\n\n## Testing Results in Detail\n\nScreencast of the process\n\nhttps://youtu.be/fYJVF7KrNnI\n\n![Liability](./images/testing-neon-with-robonomics/liability.jpg)\n\nWhen the simulation starts, an offer message is created, and a demand message comes from the Promisee, after which a Liability contract is created using the createLiability function of the Lighthouse contract. With the help of the XRT contract, tokens are transferred from the Promisee’s address to the address of the Liability contract.\n\nAfter a new Liability contract has been discovered on the Neon devnet, the agent starts working. The result of the work (telemetry) is written to a file and sent to IPFS, the hash from the file is saved as a result.\n\nAfter the work is completed, the Liability contract is finalized using the finalizeLiability() function of the Lighthouse contract and the tokens are transferred from the Liability address to the addresses of the Promisor and Validator.\n\nThe successful execution of the simulation showed that all contracts worked correctly and the Neon platform works.\n\n## Neon Platform Drawbacks\n\n### Truffle fails if it doesn't get a response from the network\n\nDuring the process of deploying contracts, it turned out that the proxy does not always return a response on time, which is why Truffle ends with an error:\n\n```\nTypeError: Cannot read properties of null (reading 'from')                                    \n    at Web3InterfaceAdapter.<anonymous> (/usr/lib/node_modules/truffle/build/webpack:/packages\n/interface-adapter/dist/adapter/web3/index.js:71:1)                                           \n    at Generator.next (<anonymous>)                                                           \n    at fulfilled (/usr/lib/node_modules/truffle/build/webpack:/packages/interface-adapter/dist\n/adapter/web3/index.js:5:43)                                                                  \n    at runMicrotasks (<anonymous>)\n    at processTicksAndRejections (node:internal/process/task_queues:96:5)\nTruffle v5.5.23 (core: 5.5.23)\nNode v16.14.0\n```\n\nIt was not possible to find a relationship between the test conditions and the occurrence of an error, but most likely Neon EVM cannot send a transaction receipt, and Truffle cannot process a Null response.\n\nIf we add timeout and retry here [index.ts#L75](https://github.com/trufflesuite/truffle/blob/develop/packages/interface-adapter/lib/adapter/web3/index.ts#L75), then the deployment should proceed without errors.\n\n### No WS/WSS Endpoint\n\nNeon EVM does not have a WS/WSS endpoint unlike Ethereum, which makes it impossible to subscribe to events from the network. Therefore, during testing, we monitored the events manually.\n\n### No Event Names\n\nNeon EVM returns rather poor descriptions of events after a transaction, for example:\n\n```\n events: {\n    '0': {\n      address: '0xCFa833bF0D46369D9024f95c9C8dFa1E4a07806C',\n      transactionHash: '0x9894a984e6b3f6ce469c8837e11739f6e50d00216cf7c5bc3d32da106a58d50a',\n      transactionLogIndex: '0x1',\n      blockHash: '0x72040f317d3a469d30327d4e1def903790b70dbede46b4f0ea4f28f30a679a80',\n      blockNumber: 156073183,\n      transactionIndex: 0,\n      logIndex: 1,\n      id: 'log_e51e2f9f',\n      returnValues: Result {},\n      event: undefined,\n      signature: null,\n      raw: [Object]\n    },\n...\n```\n\nInstead of 0, 1, etc. we expected to see named events.\n\n## Conclusion\n\nUsing the Neon EVM platform, a scenario was successfully tested whereby a liability contract between a Promisee and a Promisor is concluded with subsequent validation of the result of the work done by a third party. Additionally, a Provider participated, who checked the coincidence of supply and demand between the parties, and received a commission for this work.\n\nThe demonstration used a simulation of a robotic arm that was hired to perform a sequence of actions. As a result of the work, the robot sent a file with telemetry received during the task.\n\nDespite some peculiarities in the operation of the network, in the end, all participating contracts showed their operability in the Neon environment.\n\n\n\n","cover_image":{"type":"image","mimeType":"image/jpeg","src":"/assets/static/blog_cover_neon_multi-agent.62c183a.6231caf624da0ea84dd55d0582533702.jpg","size":{"width":1500,"height":675},"sizes":"(max-width: 1500px) 100vw, 1500px","srcset":["/assets/static/blog_cover_neon_multi-agent.9ea8d39.6231caf624da0ea84dd55d0582533702.jpg 480w","/assets/static/blog_cover_neon_multi-agent.6b2ed88.6231caf624da0ea84dd55d0582533702.jpg 1024w","/assets/static/blog_cover_neon_multi-agent.62c183a.6231caf624da0ea84dd55d0582533702.jpg 1500w"],"dataUri":"data:image/svg+xml,%3csvg fill='none' viewBox='0 0 1500 675' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'%3e%3cdefs%3e%3cfilter id='__svg-blur-6809607028734338a4644390df615667'%3e%3cfeGaussianBlur in='SourceGraphic' stdDeviation='40'/%3e%3c/filter%3e%3c/defs%3e%3cimage x='0' y='0' filter='url(%23__svg-blur-6809607028734338a4644390df615667)' width='1500' height='675' xlink:href='data:image/jpeg%3bbase64%2c/9j/2wBDAAYEBQYFBAYGBQYHBwYIChAKCgkJChQODwwQFxQYGBcUFhYaHSUfGhsjHBYWICwgIyYnKSopGR8tMC0oMCUoKSj/2wBDAQcHBwoIChMKChMoGhYaKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCj/wAARCAAdAEADASIAAhEBAxEB/8QAGwAAAgMAAwAAAAAAAAAAAAAAAgUDBAYBBwj/xAAuEAACAQMDAgQFBAMAAAAAAAABAgMABBEFEiEGMRRBQlETUnGBkQciMkNyobH/xAAYAQADAQEAAAAAAAAAAAAAAAAAAQMCBP/EACARAAIDAAICAwEAAAAAAAAAAAECAAMREjEhQTJxofD/2gAMAwEAAhEDEQA/APL0UXxFc7gNoz2qOiSRkBCnAPettddCi36et9V8aJI7jTxepGAAysFyykHuO2CPI11VUvccQdStNFlpPAbkw9HAqvIFclVPcgZP4rZWv6fz3Ns08Ws6WVXYGUu27ceSoGMk8gD5jwOaVa/09JoAhdr20u3ZtrJCTlDjIzke34PB5qIMkevESXMaxTMiljtJB3DBB9iKAxuApKNhslTjv5cVahWG4uH8ZN8A/wCJbLfXyrfab0zjRJjbiSSWJC8Mwm%2bGWZkDEKApwBkDk4J9qZgNzzOtSCO4I%2boqSSLZEj7gd3lg021/T721LvqM8ksgYBCxLZX3z%2bP90naRmUKT%2b0dqBA76g1ea8vp7SNZL2ZobcFI42kOEBGCFHkCOKo0ayMsbIP4t3pgkR6w%2bJkf2FP8AobSU1jqW1t5wfCJumuGHpjUZJ/4PvSGtV0W6JpfUG6PcwtgyMGKlSA3PHfv2NStV2QqnZlaWRbA1nQ/v2UtZk0G6txcaet3b3juVeB8MgA/sBA9Xy44Oe4q/o3VEqW62MkT7ZI1hYpOyBsKEHHpO0YJGM45rJDtXNCJwGbv3MO3M8iIx1i%2buNUl8ZdOmTwqKMbR7UuozKxiEfpBzQVSYG%2b5//9k=' /%3e%3c/svg%3e"},"locale":"de"}},{"node":{"title":"Testing Neon EVM with Robonomics Smart Contracts","path":"/blog/es/testing-neon-with-robonomics/","date":"October 3, 2022","description":"The purpose of these tests were to validate the readiness of the Neon platform to move to the production stage using Robonomics smart contracts, which allow cyber-physical systems (robots) to make technical-economic transactions.","content":"\n## TL;DR\n\nThe purpose of these tests were to validate the readiness of the [Neon](https://neon-labs.org/) platform to move to the production stage using Robonomics smart contracts, which allow cyber-physical systems (robots) to make technical-economic transactions.\n\nIn the Robonomics network, interaction is established between two parties: Promisee - the one who orders the service, sends a description of technical task and transfers funds for its execution; Promisor - one who performs a service. A typical scenario was tested, whereby a liability contract is concluded between a Promisee and a Promisor - this was followed by validation of the resulting work by a third party, and a commission payment to the node that accompanied the contract between the parties.\n\nFor this example, a simulation of a robotic arm was used, which was asked to perform a sequence of actions. The tests were successful.\n\n## Scope and Goals of Testing\n\nEngineers of [Multi-Agent Systems](https://multi-agent.io/) have been working with [Robonomics Network](https://robonomics.network/) for several years. The first implementation of the Robonomics Network was created for the Ethereum network. It is a set of smart contracts for machine-to-machine communication.\n\nThe core of the Robonomics Network is the [Liability](https://github.com/airalab/robonomics_contracts/blob/master/contracts/robonomics/Liability.sol) contract, a smart contract that reproduces the typical relationship between the customer of a service (Promisee) and the service provider (Promisor), and includes the technical and economic parameters of the transaction between them. The parties can be either an autonomous agent and a person (human-to-machine interaction), or purely two autonomous agents (machine-to-machine interaction). The Promisee and Promisor broadcast messages with the parameters of their technical-economic transaction, and then the conclusion of the transaction is provided by a special node - the Provider - which looks for matches of these parameters. Providers are controlled by [Lighthouse](https://github.com/airalab/robonomics_contracts/blob/master/contracts/robonomics/Lighthouse.sol), which is a special smart contract that executes a transaction when the provider establishes a market match between the parties.\n\nThere are three scenarios in which the fulfillment of an obligation can take place:\n\n1. A simple commitment (with no verification of the final result, and no commission paid to Provider nodes)\n2. Obligation with a commission paid to the Provider\n3. Commitment with a commission to the Provider and validation of the results with the help of a third party - observing network.\n\nThe purpose of this test is to test the most complex, third Robonomics scenario on the Neon EVM platform.\n\n## Testing Scenarios Description\n\nAs we develop the industrial zones and the infrastructure of modern cities, the emergence of fully automated enterprises and services that are controlled by cyber-physical systems (CPS) and which provide their services as autonomous agents is highly likely. In this regard, we can also expect the formation of networks of autonomous CPS in order to increase the speed and quality of communication in the process of production and provision of services.\n\nIn order to take full advantage of the possibilities of smart contracts, a scenario of interaction between two autonomous economic agents was chosen. Consider the liability life cycle in the Robonomics network:\n\n![Liability Life Cycle](./images/testing-neon-with-robonomics/step-by-step-3.jpg)\n\nThe figure above shows that the Robonomics network provider calls the Lighthouse contract, which in turn calls the [contract factory](https://github.com/airalab/robonomics_contracts/blob/master/contracts/robonomics/Factory.sol) to create the Liability contract. The Liability contract contains data about the transaction, such as the terms of reference, payment for the service, validator address and the deadline.\n\nTo learn more about the possible use cases for Robonomics, check out the Robonomics [R&D](https://wiki.robonomics.network/docs/en/r-and-d-based-on-robonomics-network/#launching-a-drone-under-the-control-of-a-decentralized-computer) page!\n\nTo replicate the entire Robonomics infrastructure on the Neon network, we will implement a robot launch scenario through a Liability contract similar to this [example](https://wiki.robonomics.network/docs/en/kuka/). If the script can be repeated, then all functions will work.\n\n## Deliverables\n\nThe source code for the Robonomics contracts is available [here](https://github.com/airalab/robonomics_contracts).\nThe contracts use many features of the Ethereum VM which includes:\n\n- ERC20 [XRT](https://github.com/airalab/robonomics_contracts/blob/master/contracts/robonomics/XRT.sol) Token\n- [Factory](https://github.com/airalab/robonomics_contracts/blob/master/contracts/robonomics/Factory.sol)\n- Own contract for [ENS](https://github.com/airalab/robonomics_contracts/blob/master/contracts/ens/ENS.sol)\n- [Proxy](https://github.com/airalab/robonomics_contracts/blob/master/contracts/misc/SharedCode.sol) for contracts\n- Various modifiers and roles in contracts\n\nAddresses of contracts in the Neon devnet network https://devnet.neonevm.org\n\n| Contract Name  | Address                                    |\n|----------------|--------------------------------------------|\n| Migrations     | 0x1DC538bE2C8572509a571B150f11aB55E52EF12E |\n| ENS            | 0xa7AEa12F60D0278F01e14DBC7cc459d04d051406 |\n| DutchAuction   | 0xF44F8803548D72Dbc3E28340EFD7b5328aa4F058 |\n| Liability      | 0xA694196351dc1488e3884eCc6b650F0d8D55346a |\n| Lighthouse     | 0x80FB5CC4c396E272b56700E6ffF5DBf4661013A8 |\n| XRT            | 0x3322d7D99cF65Cab5A92073c928b5E9674af3c29 |\n| PublicAmbix    | 0x85c03bE5ccFf11E79a0A776D183eF067590549d1 |\n| Factory        | 0xCFa833bF0D46369D9024f95c9C8dFa1E4a07806C |\n| PublicResolver | 0xAC9E9AA8A4cB524FE87f2b14489F1D6bE68dc46e |\n\n[Source code](https://github.com/Multi-Agent-io/neon-kuka-demo) for the scenario\n\n## Changes Made to Original Contracts\n\nThe contracts are written for Solidity 0.5.0. As such, no changes were required when deploying and using the contracts.\n\n## Testing Workflow\n\nIn general, the test consists of sending corresponding messages from one agent to another.\n\nNext, the Promisor finds a new liability contract in the network and begins to execute it. Upon completion of the work, a message is sent with the result, which is then recorded in the contract.\n\nStep-by-step instructions for launching are in [README.md](https://github.com/Multi-Agent-io/neon-kuka-demo/blob/main/README.md)\n\n## Testing Results in Detail\n\nScreencast of the process\n\nhttps://youtu.be/fYJVF7KrNnI\n\n![Liability](./images/testing-neon-with-robonomics/liability.jpg)\n\nWhen the simulation starts, an offer message is created, and a demand message comes from the Promisee, after which a Liability contract is created using the createLiability function of the Lighthouse contract. With the help of the XRT contract, tokens are transferred from the Promisee’s address to the address of the Liability contract.\n\nAfter a new Liability contract has been discovered on the Neon devnet, the agent starts working. The result of the work (telemetry) is written to a file and sent to IPFS, the hash from the file is saved as a result.\n\nAfter the work is completed, the Liability contract is finalized using the finalizeLiability() function of the Lighthouse contract and the tokens are transferred from the Liability address to the addresses of the Promisor and Validator.\n\nThe successful execution of the simulation showed that all contracts worked correctly and the Neon platform works.\n\n## Neon Platform Drawbacks\n\n### Truffle fails if it doesn't get a response from the network\n\nDuring the process of deploying contracts, it turned out that the proxy does not always return a response on time, which is why Truffle ends with an error:\n\n```\nTypeError: Cannot read properties of null (reading 'from')                                    \n    at Web3InterfaceAdapter.<anonymous> (/usr/lib/node_modules/truffle/build/webpack:/packages\n/interface-adapter/dist/adapter/web3/index.js:71:1)                                           \n    at Generator.next (<anonymous>)                                                           \n    at fulfilled (/usr/lib/node_modules/truffle/build/webpack:/packages/interface-adapter/dist\n/adapter/web3/index.js:5:43)                                                                  \n    at runMicrotasks (<anonymous>)\n    at processTicksAndRejections (node:internal/process/task_queues:96:5)\nTruffle v5.5.23 (core: 5.5.23)\nNode v16.14.0\n```\n\nIt was not possible to find a relationship between the test conditions and the occurrence of an error, but most likely Neon EVM cannot send a transaction receipt, and Truffle cannot process a Null response.\n\nIf we add timeout and retry here [index.ts#L75](https://github.com/trufflesuite/truffle/blob/develop/packages/interface-adapter/lib/adapter/web3/index.ts#L75), then the deployment should proceed without errors.\n\n### No WS/WSS Endpoint\n\nNeon EVM does not have a WS/WSS endpoint unlike Ethereum, which makes it impossible to subscribe to events from the network. Therefore, during testing, we monitored the events manually.\n\n### No Event Names\n\nNeon EVM returns rather poor descriptions of events after a transaction, for example:\n\n```\n events: {\n    '0': {\n      address: '0xCFa833bF0D46369D9024f95c9C8dFa1E4a07806C',\n      transactionHash: '0x9894a984e6b3f6ce469c8837e11739f6e50d00216cf7c5bc3d32da106a58d50a',\n      transactionLogIndex: '0x1',\n      blockHash: '0x72040f317d3a469d30327d4e1def903790b70dbede46b4f0ea4f28f30a679a80',\n      blockNumber: 156073183,\n      transactionIndex: 0,\n      logIndex: 1,\n      id: 'log_e51e2f9f',\n      returnValues: Result {},\n      event: undefined,\n      signature: null,\n      raw: [Object]\n    },\n...\n```\n\nInstead of 0, 1, etc. we expected to see named events.\n\n## Conclusion\n\nUsing the Neon EVM platform, a scenario was successfully tested whereby a liability contract between a Promisee and a Promisor is concluded with subsequent validation of the result of the work done by a third party. Additionally, a Provider participated, who checked the coincidence of supply and demand between the parties, and received a commission for this work.\n\nThe demonstration used a simulation of a robotic arm that was hired to perform a sequence of actions. As a result of the work, the robot sent a file with telemetry received during the task.\n\nDespite some peculiarities in the operation of the network, in the end, all participating contracts showed their operability in the Neon environment.\n\n\n\n","cover_image":{"type":"image","mimeType":"image/jpeg","src":"/assets/static/blog_cover_neon_multi-agent.62c183a.6231caf624da0ea84dd55d0582533702.jpg","size":{"width":1500,"height":675},"sizes":"(max-width: 1500px) 100vw, 1500px","srcset":["/assets/static/blog_cover_neon_multi-agent.9ea8d39.6231caf624da0ea84dd55d0582533702.jpg 480w","/assets/static/blog_cover_neon_multi-agent.6b2ed88.6231caf624da0ea84dd55d0582533702.jpg 1024w","/assets/static/blog_cover_neon_multi-agent.62c183a.6231caf624da0ea84dd55d0582533702.jpg 1500w"],"dataUri":"data:image/svg+xml,%3csvg fill='none' viewBox='0 0 1500 675' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'%3e%3cdefs%3e%3cfilter id='__svg-blur-6809607028734338a4644390df615667'%3e%3cfeGaussianBlur in='SourceGraphic' stdDeviation='40'/%3e%3c/filter%3e%3c/defs%3e%3cimage x='0' y='0' filter='url(%23__svg-blur-6809607028734338a4644390df615667)' width='1500' height='675' xlink:href='data:image/jpeg%3bbase64%2c/9j/2wBDAAYEBQYFBAYGBQYHBwYIChAKCgkJChQODwwQFxQYGBcUFhYaHSUfGhsjHBYWICwgIyYnKSopGR8tMC0oMCUoKSj/2wBDAQcHBwoIChMKChMoGhYaKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCj/wAARCAAdAEADASIAAhEBAxEB/8QAGwAAAgMAAwAAAAAAAAAAAAAAAgUDBAYBBwj/xAAuEAACAQMDAgQFBAMAAAAAAAABAgMABBEFEiEGMRRBQlETUnGBkQciMkNyobH/xAAYAQADAQEAAAAAAAAAAAAAAAAAAQMCBP/EACARAAIDAAICAwEAAAAAAAAAAAECAAMREjEhQTJxofD/2gAMAwEAAhEDEQA/APL0UXxFc7gNoz2qOiSRkBCnAPettddCi36et9V8aJI7jTxepGAAysFyykHuO2CPI11VUvccQdStNFlpPAbkw9HAqvIFclVPcgZP4rZWv6fz3Ns08Ws6WVXYGUu27ceSoGMk8gD5jwOaVa/09JoAhdr20u3ZtrJCTlDjIzke34PB5qIMkevESXMaxTMiljtJB3DBB9iKAxuApKNhslTjv5cVahWG4uH8ZN8A/wCJbLfXyrfab0zjRJjbiSSWJC8Mwm%2bGWZkDEKApwBkDk4J9qZgNzzOtSCO4I%2boqSSLZEj7gd3lg021/T721LvqM8ksgYBCxLZX3z%2bP90naRmUKT%2b0dqBA76g1ea8vp7SNZL2ZobcFI42kOEBGCFHkCOKo0ayMsbIP4t3pgkR6w%2bJkf2FP8AobSU1jqW1t5wfCJumuGHpjUZJ/4PvSGtV0W6JpfUG6PcwtgyMGKlSA3PHfv2NStV2QqnZlaWRbA1nQ/v2UtZk0G6txcaet3b3juVeB8MgA/sBA9Xy44Oe4q/o3VEqW62MkT7ZI1hYpOyBsKEHHpO0YJGM45rJDtXNCJwGbv3MO3M8iIx1i%2buNUl8ZdOmTwqKMbR7UuozKxiEfpBzQVSYG%2b5//9k=' /%3e%3c/svg%3e"},"locale":"es"}},{"node":{"title":"Testing Neon EVM with Robonomics Smart Contracts","path":"/blog/fr/testing-neon-with-robonomics/","date":"October 3, 2022","description":"The purpose of these tests were to validate the readiness of the Neon platform to move to the production stage using Robonomics smart contracts, which allow cyber-physical systems (robots) to make technical-economic transactions.","content":"\n## TL;DR\n\nThe purpose of these tests were to validate the readiness of the [Neon](https://neon-labs.org/) platform to move to the production stage using Robonomics smart contracts, which allow cyber-physical systems (robots) to make technical-economic transactions.\n\nIn the Robonomics network, interaction is established between two parties: Promisee - the one who orders the service, sends a description of technical task and transfers funds for its execution; Promisor - one who performs a service. A typical scenario was tested, whereby a liability contract is concluded between a Promisee and a Promisor - this was followed by validation of the resulting work by a third party, and a commission payment to the node that accompanied the contract between the parties.\n\nFor this example, a simulation of a robotic arm was used, which was asked to perform a sequence of actions. The tests were successful.\n\n## Scope and Goals of Testing\n\nEngineers of [Multi-Agent Systems](https://multi-agent.io/) have been working with [Robonomics Network](https://robonomics.network/) for several years. The first implementation of the Robonomics Network was created for the Ethereum network. It is a set of smart contracts for machine-to-machine communication.\n\nThe core of the Robonomics Network is the [Liability](https://github.com/airalab/robonomics_contracts/blob/master/contracts/robonomics/Liability.sol) contract, a smart contract that reproduces the typical relationship between the customer of a service (Promisee) and the service provider (Promisor), and includes the technical and economic parameters of the transaction between them. The parties can be either an autonomous agent and a person (human-to-machine interaction), or purely two autonomous agents (machine-to-machine interaction). The Promisee and Promisor broadcast messages with the parameters of their technical-economic transaction, and then the conclusion of the transaction is provided by a special node - the Provider - which looks for matches of these parameters. Providers are controlled by [Lighthouse](https://github.com/airalab/robonomics_contracts/blob/master/contracts/robonomics/Lighthouse.sol), which is a special smart contract that executes a transaction when the provider establishes a market match between the parties.\n\nThere are three scenarios in which the fulfillment of an obligation can take place:\n\n1. A simple commitment (with no verification of the final result, and no commission paid to Provider nodes)\n2. Obligation with a commission paid to the Provider\n3. Commitment with a commission to the Provider and validation of the results with the help of a third party - observing network.\n\nThe purpose of this test is to test the most complex, third Robonomics scenario on the Neon EVM platform.\n\n## Testing Scenarios Description\n\nAs we develop the industrial zones and the infrastructure of modern cities, the emergence of fully automated enterprises and services that are controlled by cyber-physical systems (CPS) and which provide their services as autonomous agents is highly likely. In this regard, we can also expect the formation of networks of autonomous CPS in order to increase the speed and quality of communication in the process of production and provision of services.\n\nIn order to take full advantage of the possibilities of smart contracts, a scenario of interaction between two autonomous economic agents was chosen. Consider the liability life cycle in the Robonomics network:\n\n![Liability Life Cycle](./images/testing-neon-with-robonomics/step-by-step-3.jpg)\n\nThe figure above shows that the Robonomics network provider calls the Lighthouse contract, which in turn calls the [contract factory](https://github.com/airalab/robonomics_contracts/blob/master/contracts/robonomics/Factory.sol) to create the Liability contract. The Liability contract contains data about the transaction, such as the terms of reference, payment for the service, validator address and the deadline.\n\nTo learn more about the possible use cases for Robonomics, check out the Robonomics [R&D](https://wiki.robonomics.network/docs/en/r-and-d-based-on-robonomics-network/#launching-a-drone-under-the-control-of-a-decentralized-computer) page!\n\nTo replicate the entire Robonomics infrastructure on the Neon network, we will implement a robot launch scenario through a Liability contract similar to this [example](https://wiki.robonomics.network/docs/en/kuka/). If the script can be repeated, then all functions will work.\n\n## Deliverables\n\nThe source code for the Robonomics contracts is available [here](https://github.com/airalab/robonomics_contracts).\nThe contracts use many features of the Ethereum VM which includes:\n\n- ERC20 [XRT](https://github.com/airalab/robonomics_contracts/blob/master/contracts/robonomics/XRT.sol) Token\n- [Factory](https://github.com/airalab/robonomics_contracts/blob/master/contracts/robonomics/Factory.sol)\n- Own contract for [ENS](https://github.com/airalab/robonomics_contracts/blob/master/contracts/ens/ENS.sol)\n- [Proxy](https://github.com/airalab/robonomics_contracts/blob/master/contracts/misc/SharedCode.sol) for contracts\n- Various modifiers and roles in contracts\n\nAddresses of contracts in the Neon devnet network https://devnet.neonevm.org\n\n| Contract Name  | Address                                    |\n|----------------|--------------------------------------------|\n| Migrations     | 0x1DC538bE2C8572509a571B150f11aB55E52EF12E |\n| ENS            | 0xa7AEa12F60D0278F01e14DBC7cc459d04d051406 |\n| DutchAuction   | 0xF44F8803548D72Dbc3E28340EFD7b5328aa4F058 |\n| Liability      | 0xA694196351dc1488e3884eCc6b650F0d8D55346a |\n| Lighthouse     | 0x80FB5CC4c396E272b56700E6ffF5DBf4661013A8 |\n| XRT            | 0x3322d7D99cF65Cab5A92073c928b5E9674af3c29 |\n| PublicAmbix    | 0x85c03bE5ccFf11E79a0A776D183eF067590549d1 |\n| Factory        | 0xCFa833bF0D46369D9024f95c9C8dFa1E4a07806C |\n| PublicResolver | 0xAC9E9AA8A4cB524FE87f2b14489F1D6bE68dc46e |\n\n[Source code](https://github.com/Multi-Agent-io/neon-kuka-demo) for the scenario\n\n## Changes Made to Original Contracts\n\nThe contracts are written for Solidity 0.5.0. As such, no changes were required when deploying and using the contracts.\n\n## Testing Workflow\n\nIn general, the test consists of sending corresponding messages from one agent to another.\n\nNext, the Promisor finds a new liability contract in the network and begins to execute it. Upon completion of the work, a message is sent with the result, which is then recorded in the contract.\n\nStep-by-step instructions for launching are in [README.md](https://github.com/Multi-Agent-io/neon-kuka-demo/blob/main/README.md)\n\n## Testing Results in Detail\n\nScreencast of the process\n\nhttps://youtu.be/fYJVF7KrNnI\n\n![Liability](./images/testing-neon-with-robonomics/liability.jpg)\n\nWhen the simulation starts, an offer message is created, and a demand message comes from the Promisee, after which a Liability contract is created using the createLiability function of the Lighthouse contract. With the help of the XRT contract, tokens are transferred from the Promisee’s address to the address of the Liability contract.\n\nAfter a new Liability contract has been discovered on the Neon devnet, the agent starts working. The result of the work (telemetry) is written to a file and sent to IPFS, the hash from the file is saved as a result.\n\nAfter the work is completed, the Liability contract is finalized using the finalizeLiability() function of the Lighthouse contract and the tokens are transferred from the Liability address to the addresses of the Promisor and Validator.\n\nThe successful execution of the simulation showed that all contracts worked correctly and the Neon platform works.\n\n## Neon Platform Drawbacks\n\n### Truffle fails if it doesn't get a response from the network\n\nDuring the process of deploying contracts, it turned out that the proxy does not always return a response on time, which is why Truffle ends with an error:\n\n```\nTypeError: Cannot read properties of null (reading 'from')                                    \n    at Web3InterfaceAdapter.<anonymous> (/usr/lib/node_modules/truffle/build/webpack:/packages\n/interface-adapter/dist/adapter/web3/index.js:71:1)                                           \n    at Generator.next (<anonymous>)                                                           \n    at fulfilled (/usr/lib/node_modules/truffle/build/webpack:/packages/interface-adapter/dist\n/adapter/web3/index.js:5:43)                                                                  \n    at runMicrotasks (<anonymous>)\n    at processTicksAndRejections (node:internal/process/task_queues:96:5)\nTruffle v5.5.23 (core: 5.5.23)\nNode v16.14.0\n```\n\nIt was not possible to find a relationship between the test conditions and the occurrence of an error, but most likely Neon EVM cannot send a transaction receipt, and Truffle cannot process a Null response.\n\nIf we add timeout and retry here [index.ts#L75](https://github.com/trufflesuite/truffle/blob/develop/packages/interface-adapter/lib/adapter/web3/index.ts#L75), then the deployment should proceed without errors.\n\n### No WS/WSS Endpoint\n\nNeon EVM does not have a WS/WSS endpoint unlike Ethereum, which makes it impossible to subscribe to events from the network. Therefore, during testing, we monitored the events manually.\n\n### No Event Names\n\nNeon EVM returns rather poor descriptions of events after a transaction, for example:\n\n```\n events: {\n    '0': {\n      address: '0xCFa833bF0D46369D9024f95c9C8dFa1E4a07806C',\n      transactionHash: '0x9894a984e6b3f6ce469c8837e11739f6e50d00216cf7c5bc3d32da106a58d50a',\n      transactionLogIndex: '0x1',\n      blockHash: '0x72040f317d3a469d30327d4e1def903790b70dbede46b4f0ea4f28f30a679a80',\n      blockNumber: 156073183,\n      transactionIndex: 0,\n      logIndex: 1,\n      id: 'log_e51e2f9f',\n      returnValues: Result {},\n      event: undefined,\n      signature: null,\n      raw: [Object]\n    },\n...\n```\n\nInstead of 0, 1, etc. we expected to see named events.\n\n## Conclusion\n\nUsing the Neon EVM platform, a scenario was successfully tested whereby a liability contract between a Promisee and a Promisor is concluded with subsequent validation of the result of the work done by a third party. Additionally, a Provider participated, who checked the coincidence of supply and demand between the parties, and received a commission for this work.\n\nThe demonstration used a simulation of a robotic arm that was hired to perform a sequence of actions. As a result of the work, the robot sent a file with telemetry received during the task.\n\nDespite some peculiarities in the operation of the network, in the end, all participating contracts showed their operability in the Neon environment.\n\n\n\n","cover_image":{"type":"image","mimeType":"image/jpeg","src":"/assets/static/blog_cover_neon_multi-agent.62c183a.6231caf624da0ea84dd55d0582533702.jpg","size":{"width":1500,"height":675},"sizes":"(max-width: 1500px) 100vw, 1500px","srcset":["/assets/static/blog_cover_neon_multi-agent.9ea8d39.6231caf624da0ea84dd55d0582533702.jpg 480w","/assets/static/blog_cover_neon_multi-agent.6b2ed88.6231caf624da0ea84dd55d0582533702.jpg 1024w","/assets/static/blog_cover_neon_multi-agent.62c183a.6231caf624da0ea84dd55d0582533702.jpg 1500w"],"dataUri":"data:image/svg+xml,%3csvg fill='none' viewBox='0 0 1500 675' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'%3e%3cdefs%3e%3cfilter id='__svg-blur-6809607028734338a4644390df615667'%3e%3cfeGaussianBlur in='SourceGraphic' stdDeviation='40'/%3e%3c/filter%3e%3c/defs%3e%3cimage x='0' y='0' filter='url(%23__svg-blur-6809607028734338a4644390df615667)' width='1500' height='675' xlink:href='data:image/jpeg%3bbase64%2c/9j/2wBDAAYEBQYFBAYGBQYHBwYIChAKCgkJChQODwwQFxQYGBcUFhYaHSUfGhsjHBYWICwgIyYnKSopGR8tMC0oMCUoKSj/2wBDAQcHBwoIChMKChMoGhYaKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCj/wAARCAAdAEADASIAAhEBAxEB/8QAGwAAAgMAAwAAAAAAAAAAAAAAAgUDBAYBBwj/xAAuEAACAQMDAgQFBAMAAAAAAAABAgMABBEFEiEGMRRBQlETUnGBkQciMkNyobH/xAAYAQADAQEAAAAAAAAAAAAAAAAAAQMCBP/EACARAAIDAAICAwEAAAAAAAAAAAECAAMREjEhQTJxofD/2gAMAwEAAhEDEQA/APL0UXxFc7gNoz2qOiSRkBCnAPettddCi36et9V8aJI7jTxepGAAysFyykHuO2CPI11VUvccQdStNFlpPAbkw9HAqvIFclVPcgZP4rZWv6fz3Ns08Ws6WVXYGUu27ceSoGMk8gD5jwOaVa/09JoAhdr20u3ZtrJCTlDjIzke34PB5qIMkevESXMaxTMiljtJB3DBB9iKAxuApKNhslTjv5cVahWG4uH8ZN8A/wCJbLfXyrfab0zjRJjbiSSWJC8Mwm%2bGWZkDEKApwBkDk4J9qZgNzzOtSCO4I%2boqSSLZEj7gd3lg021/T721LvqM8ksgYBCxLZX3z%2bP90naRmUKT%2b0dqBA76g1ea8vp7SNZL2ZobcFI42kOEBGCFHkCOKo0ayMsbIP4t3pgkR6w%2bJkf2FP8AobSU1jqW1t5wfCJumuGHpjUZJ/4PvSGtV0W6JpfUG6PcwtgyMGKlSA3PHfv2NStV2QqnZlaWRbA1nQ/v2UtZk0G6txcaet3b3juVeB8MgA/sBA9Xy44Oe4q/o3VEqW62MkT7ZI1hYpOyBsKEHHpO0YJGM45rJDtXNCJwGbv3MO3M8iIx1i%2buNUl8ZdOmTwqKMbR7UuozKxiEfpBzQVSYG%2b5//9k=' /%3e%3c/svg%3e"},"locale":"fr"}},{"node":{"title":"Testando l’EVM di Neon con gli Smart Contract di Robonomics","path":"/blog/it/testing-neon-with-robonomics/","date":"October 3, 2022","description":"Lo scopo di questi test è stato quello di validare quanto la piattaforma Neon fosse pronta per passare alla fase di produzione utilizzando gli smart contract di Robonomics, che consentono ai sistemi cyber-fisici (robot) di effettuare transazioni tecnico-economiche.","content":"\n## TL;DR\n\nLo scopo di questi test è stato quello di validare quanto la piattaforma  [Neon](https://neon-labs.org/) fosse pronta per passare alla fase di produzione utilizzando gli smart contract di Robonomics, che consentono ai sistemi cyber-fisici (robot) di effettuare transazioni tecnico-economiche.\n\nNel Robonomics Network, l’interazione è stabilita fra due parti: Promisee — chi ordina il servizio, invia una descrizione dell’attività tecnica e trasferisce i fondi per la sua esecuzione; Promisor — chi esegue un servizio. È stato testato un tipico scenario dove un contratto di responsabilità viene concluso fra un Promisee e un Promisor, seguito poi dalla validazione (effettuata da una terza parte) del lavoro conseguente e dal pagamento di una commissione al nodo che ha seguito il contratto fra le parti.\n\nPer questo esempio è stata utilizzata la simulazione di un braccio robotico, a cui è stato chiesto di eseguire una sequenza di azioni. I test hanno avuto esito positivo.\n\n## SCOPO E OBIETTIVI DEL TEST\n\nGli ingegneri di [Multi-Agent Systems](https://multi-agent.io/) lavorano da diversi anni con [Robonomics Network](https://robonomics.network/). La prima implementazione del Robonomics Network è stata creata per la rete Ethereum ed è un insieme di smart contract per la comunicazione da macchina a macchina.\n\nIl fulcro di Robonomics è il contratto di Responsabilità ([Liability](https://github.com/airalab/robonomics_contracts/blob/master/contracts/robonomics/Liability.sol)) uno smart contract che riproduce la tipica relazione fra il cliente di un servizio (Promisee) e il fornitore del servizio stesso (Promisor) e comprende i parametri tecnici ed economici della loro transazione. Le parti possono essere un agente autonomo e una persona (interazione uomo-macchina) o due agenti autonomi (interazione macchina-macchina). Il Promisee e il Promisor trasmettono messaggi con i parametri della loro transazione tecnico-economica, che viene fornita da un apposito nodo — il Provider — che ricerca una corrispondenza nei parametri. I Provider sono controllati da un [Lighthouse](https://github.com/airalab/robonomics_contracts/blob/master/contracts/robonomics/Lighthouse.sol), uno speciale smart contract che esegue una transazione quando il provider stabilisce una corrispondenza di mercato fra le parti.\n\nEsistono tre scenari dove può avvenire l’adempimento di un’obbligo:\n\n1. Un semplice impegno (senza verifica del risultato finale e senza commissioni pagate ai nodi Provider)\n2. Obbligo con una commissione pagata al Provider\n3. Impegno con commissione al Provider e validazione dei risultati con l’aiuto di una terza parte, l’observing network.\n\nLo scopo di questo test è verificare il terzo scenario di Robonomics sulla piattaforma EVM Neon.\n\n## DESCRIZIONE DEGLI SCENARI DI PROVA\n\nMentre sviluppiamo le zone industriali e le infrastrutture delle città moderne, l’emergere di imprese e servizi completamente automatizzati, controllati da sistemi cyber-fisici (CPS) e che forniscono i loro servizi come agenti autonomi è estremamente probabile. In tal senso, possiamo aspettarci anche la creazione di reti di CPS autonomi al fine di aumentare la velocità e la qualità della comunicazione nel processo di produzione e fornitura dei servizi.\n\nPer sfruttare appieno le possibilità degli smart contract, è stato scelto uno scenario di interazione fra due agenti economici autonomi. Considera il ciclo di vita della responsabilità nel Robonomics Network:\n\n![Liability Life Cycle](./images/testing-neon-with-robonomics/step-by-step-3.jpg)\n\nLa figura qui sopra mostra come il provider di Robonomics chiami il contratto Lighthouse, che a sua volta chiama la [contract factory](https://github.com/airalab/robonomics_contracts/blob/master/contracts/robonomics/Factory.sol) per creare il Liability contract. Il contratto di Responsabilità contiene i dati sulla transazione, come i termini di riferimento, il pagamento del servizio, l’indirizzo del validatore e la scadenza.\n\nPer saperne di più sui possibili casi d’uso di Robonomics, dai un’occhiata alla pagina [R&D](https://wiki.robonomics.network/docs/en/r-and-d-based-on-robonomics-network/#launching-a-drone-under-the-control-of-a-decentralized-computer)!\n\nPer replicare tutta infrastruttura Robonomics su rete Neon, implementeremo lo scenario dell’avvio di un robot tramite un contratto di responsabilità simile a quello in [questo](https://wiki.robonomics.network/docs/en/kuka/) esempio. Se lo script può essere ripetuto, tutte le funzioni funzioneranno.\n\n## PRODOTTI FINALI\n\nIl codice sorgente dei contratti Robonomics è disponibile [qui](https://github.com/airalab/robonomics_contracts).\nI contratti utilizzano molte funzionalità della Ethereum VM, che includono:\n\n- Token [XRT](https://github.com/airalab/robonomics_contracts/blob/master/contracts/robonomics/XRT.sol) ERC20\n- [Factory](https://github.com/airalab/robonomics_contracts/blob/master/contracts/robonomics/Factory.sol)\n- Contratto proprietario per [ENS](https://github.com/airalab/robonomics_contracts/blob/master/contracts/ens/ENS.sol)\n- [Proxy](https://github.com/airalab/robonomics_contracts/blob/master/contracts/misc/SharedCode.sol) dei contratti\n- Vari modificatori e ruoli nei contratti\n\nIndirizzi dei contratti nella devnet Neon https://devnet.neonevm.org\n\n| Contract Name  | Address                                    |\n|----------------|--------------------------------------------|\n| Migrations     | 0x1DC538bE2C8572509a571B150f11aB55E52EF12E |\n| ENS            | 0xa7AEa12F60D0278F01e14DBC7cc459d04d051406 |\n| DutchAuction   | 0xF44F8803548D72Dbc3E28340EFD7b5328aa4F058 |\n| Liability      | 0xA694196351dc1488e3884eCc6b650F0d8D55346a |\n| Lighthouse     | 0x80FB5CC4c396E272b56700E6ffF5DBf4661013A8 |\n| XRT            | 0x3322d7D99cF65Cab5A92073c928b5E9674af3c29 |\n| PublicAmbix    | 0x85c03bE5ccFf11E79a0A776D183eF067590549d1 |\n| Factory        | 0xCFa833bF0D46369D9024f95c9C8dFa1E4a07806C |\n| PublicResolver | 0xAC9E9AA8A4cB524FE87f2b14489F1D6bE68dc46e |\n\n[Codice sorgente](https://github.com/Multi-Agent-io/neon-kuka-demo) dello scenario.\n\n## MODIFICHE APPORTATE AI CONTRATTI ORIGINALI\n\nGli smart contract sono scritti per Solidity 0.5.0. e per tanto, non sono state necessarie modifiche durante la distribuzione e l’utilizzo dei contratti.\n\n## WORKFLOW DEL TESTING\n\nIn generale, il test consiste nell’invio di messaggi corrispondenti da un agente all’altro.\n\nSuccessivamente, il Promisor trova un nuovo contratto di responsabilità nella rete e inizia ad eseguirlo. Al termine dei lavori, viene inviato un messaggio con l’esito, che viene poi registrato nel contratto.\n\nTrovate le istruzioni dettagliate per l’avvio nel [README.md](https://github.com/Multi-Agent-io/neon-kuka-demo/blob/main/README.md)\n\n## I RISULTATI DEI TEST IN DETTAGLIO\n\nScreencast del processo\n\nhttps://youtu.be/fYJVF7KrNnI\n\n![Liability](./images/testing-neon-with-robonomics/liability.jpg)\n\nAll’avvio della simulazione viene creato un messaggio di offerta e un messaggio di domanda arriva dal Promisee, dopodiché viene creato un contratto di Responsabilità utilizzando la funzione createLiability del contratto Lighthouse. I token vengono poi trasferiti dall’indirizzo del Promisee all’indirizzo del Liability contract con l’aiuto del contratto XRT.\n\nDopo che un nuovo contratto di responsabilità viene scoperto sulla devnet di Neon l’agente inizia a lavorare. Il risultato del lavoro (telemetria) viene scritto in un file e inviato a IPFS, mentre l’hash del file viene salvato di conseguenza.\n\nQuando il lavoro è completato, il contratto di Responsabilità viene finalizzato utilizzando la funzione finalizeLiability() del Lighthouse contract e i token vengono trasferiti dall’indirizzo di Responsabilità agli indirizzi del Promisor e del Validatore.\n\nLa corretta esecuzione della simulazione ha mostrato che tutti i contratti e la piattaforma Neon funzionavano perfettamente.\n\n## INCONVENIENTI DELLA PIATTAFORMA NEON\n\n### IL TRUFFLE FALLISCE SE NON RICEVE RISPOSTA DALLA RETE\n\nDurante il processo di distribuzione dei contratti, si è scoperto che il proxy non restituisce sempre una risposta in tempo, motivo per cui il Truffle termina con un errore:\n\n\n```\nTypeError: Cannot read properties of null (reading 'from')                                    \n    at Web3InterfaceAdapter.<anonymous> (/usr/lib/node_modules/truffle/build/webpack:/packages\n/interface-adapter/dist/adapter/web3/index.js:71:1)                                           \n    at Generator.next (<anonymous>)                                                           \n    at fulfilled (/usr/lib/node_modules/truffle/build/webpack:/packages/interface-adapter/dist\n/adapter/web3/index.js:5:43)                                                                  \n    at runMicrotasks (<anonymous>)\n    at processTicksAndRejections (node:internal/process/task_queues:96:5)\nTruffle v5.5.23 (core: 5.5.23)\nNode v16.14.0\n```\n\nNon è stato possibile trovare una relazione fra le condizioni del test e il verificarsi di un errore, ma molto probabilmente la Neon EVM non può inviare una ricevuta di transazione e il Truffle non può elaborare una risposta Null.\n\nSe aggiungiamo un timeout e riproviamo qui [index.ts#L75](https://github.com/trufflesuite/truffle/blob/develop/packages/interface-adapter/lib/adapter/web3/index.ts#L75), allora la distribuzione dovrebbe procedere senza errori.\n\n### NESSUN ENDPOINT WS/WSS\n\nA differenza di Ethereum, la Neon EVM non ha un endpoint WS/WSS, il che rende impossibile sottoscrivere gli eventi dalla rete. Durante i test abbiamo quindi monitorato gli eventi manualmente.\n\n### NESSUN EVENT NAMES\n\nLa Neon EVM restituisce descrizioni degli eventi piuttosto scarse dopo una transazione, ad esempio:\n\n```\n events: {\n    '0': {\n      address: '0xCFa833bF0D46369D9024f95c9C8dFa1E4a07806C',\n      transactionHash: '0x9894a984e6b3f6ce469c8837e11739f6e50d00216cf7c5bc3d32da106a58d50a',\n      transactionLogIndex: '0x1',\n      blockHash: '0x72040f317d3a469d30327d4e1def903790b70dbede46b4f0ea4f28f30a679a80',\n      blockNumber: 156073183,\n      transactionIndex: 0,\n      logIndex: 1,\n      id: 'log_e51e2f9f',\n      returnValues: Result {},\n      event: undefined,\n      signature: null,\n      raw: [Object]\n    },\n...\n```\n\n\nInvece di 0, 1, ecc. ci aspettavamo di vedere degli eventi con un nome.\n\n## CONCLUSIONE\n\nUtilizzando la piattaforma Neon EVM, è stato testato con successo uno scenario in base al quale si conclude un contratto di responsabilità fra un Promisee e un Promisor, con con una terza parte che convalida il risultato del lavoro svolto. Con anche un Provider che ha verificato la coincidenza di domanda e offerta tra le parti e ha ricevuto una commissione per il servizio.\n\nLa dimostrazione ha utilizzato la simulazione di un braccio robotico che è stato assunto per eseguire una sequenza di azioni. A seguito del lavoro, il robot ha inviato un file con la telemetria ricevuta durante l’attività.\n\nNonostante alcune particolarità nel funzionamento della rete, alla fine tutti i contratti partecipanti hanno mostrato la loro operatività in ambiente Neon.\n\n\n\n","cover_image":{"type":"image","mimeType":"image/jpeg","src":"/assets/static/blog_cover_neon_multi-agent.62c183a.6231caf624da0ea84dd55d0582533702.jpg","size":{"width":1500,"height":675},"sizes":"(max-width: 1500px) 100vw, 1500px","srcset":["/assets/static/blog_cover_neon_multi-agent.9ea8d39.6231caf624da0ea84dd55d0582533702.jpg 480w","/assets/static/blog_cover_neon_multi-agent.6b2ed88.6231caf624da0ea84dd55d0582533702.jpg 1024w","/assets/static/blog_cover_neon_multi-agent.62c183a.6231caf624da0ea84dd55d0582533702.jpg 1500w"],"dataUri":"data:image/svg+xml,%3csvg fill='none' viewBox='0 0 1500 675' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'%3e%3cdefs%3e%3cfilter id='__svg-blur-6809607028734338a4644390df615667'%3e%3cfeGaussianBlur in='SourceGraphic' stdDeviation='40'/%3e%3c/filter%3e%3c/defs%3e%3cimage x='0' y='0' filter='url(%23__svg-blur-6809607028734338a4644390df615667)' width='1500' height='675' xlink:href='data:image/jpeg%3bbase64%2c/9j/2wBDAAYEBQYFBAYGBQYHBwYIChAKCgkJChQODwwQFxQYGBcUFhYaHSUfGhsjHBYWICwgIyYnKSopGR8tMC0oMCUoKSj/2wBDAQcHBwoIChMKChMoGhYaKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCj/wAARCAAdAEADASIAAhEBAxEB/8QAGwAAAgMAAwAAAAAAAAAAAAAAAgUDBAYBBwj/xAAuEAACAQMDAgQFBAMAAAAAAAABAgMABBEFEiEGMRRBQlETUnGBkQciMkNyobH/xAAYAQADAQEAAAAAAAAAAAAAAAAAAQMCBP/EACARAAIDAAICAwEAAAAAAAAAAAECAAMREjEhQTJxofD/2gAMAwEAAhEDEQA/APL0UXxFc7gNoz2qOiSRkBCnAPettddCi36et9V8aJI7jTxepGAAysFyykHuO2CPI11VUvccQdStNFlpPAbkw9HAqvIFclVPcgZP4rZWv6fz3Ns08Ws6WVXYGUu27ceSoGMk8gD5jwOaVa/09JoAhdr20u3ZtrJCTlDjIzke34PB5qIMkevESXMaxTMiljtJB3DBB9iKAxuApKNhslTjv5cVahWG4uH8ZN8A/wCJbLfXyrfab0zjRJjbiSSWJC8Mwm%2bGWZkDEKApwBkDk4J9qZgNzzOtSCO4I%2boqSSLZEj7gd3lg021/T721LvqM8ksgYBCxLZX3z%2bP90naRmUKT%2b0dqBA76g1ea8vp7SNZL2ZobcFI42kOEBGCFHkCOKo0ayMsbIP4t3pgkR6w%2bJkf2FP8AobSU1jqW1t5wfCJumuGHpjUZJ/4PvSGtV0W6JpfUG6PcwtgyMGKlSA3PHfv2NStV2QqnZlaWRbA1nQ/v2UtZk0G6txcaet3b3juVeB8MgA/sBA9Xy44Oe4q/o3VEqW62MkT7ZI1hYpOyBsKEHHpO0YJGM45rJDtXNCJwGbv3MO3M8iIx1i%2buNUl8ZdOmTwqKMbR7UuozKxiEfpBzQVSYG%2b5//9k=' /%3e%3c/svg%3e"},"locale":"it"}},{"node":{"title":"Testing Neon EVM with Robonomics Smart Contracts","path":"/blog/ja/testing-neon-with-robonomics/","date":"October 3, 2022","description":"The purpose of these tests were to validate the readiness of the Neon platform to move to the production stage using Robonomics smart contracts, which allow cyber-physical systems (robots) to make technical-economic transactions.","content":"\n## TL;DR\n\nThe purpose of these tests were to validate the readiness of the [Neon](https://neon-labs.org/) platform to move to the production stage using Robonomics smart contracts, which allow cyber-physical systems (robots) to make technical-economic transactions.\n\nIn the Robonomics network, interaction is established between two parties: Promisee - the one who orders the service, sends a description of technical task and transfers funds for its execution; Promisor - one who performs a service. A typical scenario was tested, whereby a liability contract is concluded between a Promisee and a Promisor - this was followed by validation of the resulting work by a third party, and a commission payment to the node that accompanied the contract between the parties.\n\nFor this example, a simulation of a robotic arm was used, which was asked to perform a sequence of actions. The tests were successful.\n\n## Scope and Goals of Testing\n\nEngineers of [Multi-Agent Systems](https://multi-agent.io/) have been working with [Robonomics Network](https://robonomics.network/) for several years. The first implementation of the Robonomics Network was created for the Ethereum network. It is a set of smart contracts for machine-to-machine communication.\n\nThe core of the Robonomics Network is the [Liability](https://github.com/airalab/robonomics_contracts/blob/master/contracts/robonomics/Liability.sol) contract, a smart contract that reproduces the typical relationship between the customer of a service (Promisee) and the service provider (Promisor), and includes the technical and economic parameters of the transaction between them. The parties can be either an autonomous agent and a person (human-to-machine interaction), or purely two autonomous agents (machine-to-machine interaction). The Promisee and Promisor broadcast messages with the parameters of their technical-economic transaction, and then the conclusion of the transaction is provided by a special node - the Provider - which looks for matches of these parameters. Providers are controlled by [Lighthouse](https://github.com/airalab/robonomics_contracts/blob/master/contracts/robonomics/Lighthouse.sol), which is a special smart contract that executes a transaction when the provider establishes a market match between the parties.\n\nThere are three scenarios in which the fulfillment of an obligation can take place:\n\n1. A simple commitment (with no verification of the final result, and no commission paid to Provider nodes)\n2. Obligation with a commission paid to the Provider\n3. Commitment with a commission to the Provider and validation of the results with the help of a third party - observing network.\n\nThe purpose of this test is to test the most complex, third Robonomics scenario on the Neon EVM platform.\n\n## Testing Scenarios Description\n\nAs we develop the industrial zones and the infrastructure of modern cities, the emergence of fully automated enterprises and services that are controlled by cyber-physical systems (CPS) and which provide their services as autonomous agents is highly likely. In this regard, we can also expect the formation of networks of autonomous CPS in order to increase the speed and quality of communication in the process of production and provision of services.\n\nIn order to take full advantage of the possibilities of smart contracts, a scenario of interaction between two autonomous economic agents was chosen. Consider the liability life cycle in the Robonomics network:\n\n![Liability Life Cycle](./images/testing-neon-with-robonomics/step-by-step-3.jpg)\n\nThe figure above shows that the Robonomics network provider calls the Lighthouse contract, which in turn calls the [contract factory](https://github.com/airalab/robonomics_contracts/blob/master/contracts/robonomics/Factory.sol) to create the Liability contract. The Liability contract contains data about the transaction, such as the terms of reference, payment for the service, validator address and the deadline.\n\nTo learn more about the possible use cases for Robonomics, check out the Robonomics [R&D](https://wiki.robonomics.network/docs/en/r-and-d-based-on-robonomics-network/#launching-a-drone-under-the-control-of-a-decentralized-computer) page!\n\nTo replicate the entire Robonomics infrastructure on the Neon network, we will implement a robot launch scenario through a Liability contract similar to this [example](https://wiki.robonomics.network/docs/en/kuka/). If the script can be repeated, then all functions will work.\n\n## Deliverables\n\nThe source code for the Robonomics contracts is available [here](https://github.com/airalab/robonomics_contracts).\nThe contracts use many features of the Ethereum VM which includes:\n\n- ERC20 [XRT](https://github.com/airalab/robonomics_contracts/blob/master/contracts/robonomics/XRT.sol) Token\n- [Factory](https://github.com/airalab/robonomics_contracts/blob/master/contracts/robonomics/Factory.sol)\n- Own contract for [ENS](https://github.com/airalab/robonomics_contracts/blob/master/contracts/ens/ENS.sol)\n- [Proxy](https://github.com/airalab/robonomics_contracts/blob/master/contracts/misc/SharedCode.sol) for contracts\n- Various modifiers and roles in contracts\n\nAddresses of contracts in the Neon devnet network https://devnet.neonevm.org\n\n| Contract Name  | Address                                    |\n|----------------|--------------------------------------------|\n| Migrations     | 0x1DC538bE2C8572509a571B150f11aB55E52EF12E |\n| ENS            | 0xa7AEa12F60D0278F01e14DBC7cc459d04d051406 |\n| DutchAuction   | 0xF44F8803548D72Dbc3E28340EFD7b5328aa4F058 |\n| Liability      | 0xA694196351dc1488e3884eCc6b650F0d8D55346a |\n| Lighthouse     | 0x80FB5CC4c396E272b56700E6ffF5DBf4661013A8 |\n| XRT            | 0x3322d7D99cF65Cab5A92073c928b5E9674af3c29 |\n| PublicAmbix    | 0x85c03bE5ccFf11E79a0A776D183eF067590549d1 |\n| Factory        | 0xCFa833bF0D46369D9024f95c9C8dFa1E4a07806C |\n| PublicResolver | 0xAC9E9AA8A4cB524FE87f2b14489F1D6bE68dc46e |\n\n[Source code](https://github.com/Multi-Agent-io/neon-kuka-demo) for the scenario\n\n## Changes Made to Original Contracts\n\nThe contracts are written for Solidity 0.5.0. As such, no changes were required when deploying and using the contracts.\n\n## Testing Workflow\n\nIn general, the test consists of sending corresponding messages from one agent to another.\n\nNext, the Promisor finds a new liability contract in the network and begins to execute it. Upon completion of the work, a message is sent with the result, which is then recorded in the contract.\n\nStep-by-step instructions for launching are in [README.md](https://github.com/Multi-Agent-io/neon-kuka-demo/blob/main/README.md)\n\n## Testing Results in Detail\n\nScreencast of the process\n\nhttps://youtu.be/fYJVF7KrNnI\n\n![Liability](./images/testing-neon-with-robonomics/liability.jpg)\n\nWhen the simulation starts, an offer message is created, and a demand message comes from the Promisee, after which a Liability contract is created using the createLiability function of the Lighthouse contract. With the help of the XRT contract, tokens are transferred from the Promisee’s address to the address of the Liability contract.\n\nAfter a new Liability contract has been discovered on the Neon devnet, the agent starts working. The result of the work (telemetry) is written to a file and sent to IPFS, the hash from the file is saved as a result.\n\nAfter the work is completed, the Liability contract is finalized using the finalizeLiability() function of the Lighthouse contract and the tokens are transferred from the Liability address to the addresses of the Promisor and Validator.\n\nThe successful execution of the simulation showed that all contracts worked correctly and the Neon platform works.\n\n## Neon Platform Drawbacks\n\n### Truffle fails if it doesn't get a response from the network\n\nDuring the process of deploying contracts, it turned out that the proxy does not always return a response on time, which is why Truffle ends with an error:\n\n```\nTypeError: Cannot read properties of null (reading 'from')                                    \n    at Web3InterfaceAdapter.<anonymous> (/usr/lib/node_modules/truffle/build/webpack:/packages\n/interface-adapter/dist/adapter/web3/index.js:71:1)                                           \n    at Generator.next (<anonymous>)                                                           \n    at fulfilled (/usr/lib/node_modules/truffle/build/webpack:/packages/interface-adapter/dist\n/adapter/web3/index.js:5:43)                                                                  \n    at runMicrotasks (<anonymous>)\n    at processTicksAndRejections (node:internal/process/task_queues:96:5)\nTruffle v5.5.23 (core: 5.5.23)\nNode v16.14.0\n```\n\nIt was not possible to find a relationship between the test conditions and the occurrence of an error, but most likely Neon EVM cannot send a transaction receipt, and Truffle cannot process a Null response.\n\nIf we add timeout and retry here [index.ts#L75](https://github.com/trufflesuite/truffle/blob/develop/packages/interface-adapter/lib/adapter/web3/index.ts#L75), then the deployment should proceed without errors.\n\n### No WS/WSS Endpoint\n\nNeon EVM does not have a WS/WSS endpoint unlike Ethereum, which makes it impossible to subscribe to events from the network. Therefore, during testing, we monitored the events manually.\n\n### No Event Names\n\nNeon EVM returns rather poor descriptions of events after a transaction, for example:\n\n```\n events: {\n    '0': {\n      address: '0xCFa833bF0D46369D9024f95c9C8dFa1E4a07806C',\n      transactionHash: '0x9894a984e6b3f6ce469c8837e11739f6e50d00216cf7c5bc3d32da106a58d50a',\n      transactionLogIndex: '0x1',\n      blockHash: '0x72040f317d3a469d30327d4e1def903790b70dbede46b4f0ea4f28f30a679a80',\n      blockNumber: 156073183,\n      transactionIndex: 0,\n      logIndex: 1,\n      id: 'log_e51e2f9f',\n      returnValues: Result {},\n      event: undefined,\n      signature: null,\n      raw: [Object]\n    },\n...\n```\n\nInstead of 0, 1, etc. we expected to see named events.\n\n## Conclusion\n\nUsing the Neon EVM platform, a scenario was successfully tested whereby a liability contract between a Promisee and a Promisor is concluded with subsequent validation of the result of the work done by a third party. Additionally, a Provider participated, who checked the coincidence of supply and demand between the parties, and received a commission for this work.\n\nThe demonstration used a simulation of a robotic arm that was hired to perform a sequence of actions. As a result of the work, the robot sent a file with telemetry received during the task.\n\nDespite some peculiarities in the operation of the network, in the end, all participating contracts showed their operability in the Neon environment.\n\n\n\n","cover_image":{"type":"image","mimeType":"image/jpeg","src":"/assets/static/blog_cover_neon_multi-agent.62c183a.6231caf624da0ea84dd55d0582533702.jpg","size":{"width":1500,"height":675},"sizes":"(max-width: 1500px) 100vw, 1500px","srcset":["/assets/static/blog_cover_neon_multi-agent.9ea8d39.6231caf624da0ea84dd55d0582533702.jpg 480w","/assets/static/blog_cover_neon_multi-agent.6b2ed88.6231caf624da0ea84dd55d0582533702.jpg 1024w","/assets/static/blog_cover_neon_multi-agent.62c183a.6231caf624da0ea84dd55d0582533702.jpg 1500w"],"dataUri":"data:image/svg+xml,%3csvg fill='none' viewBox='0 0 1500 675' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'%3e%3cdefs%3e%3cfilter id='__svg-blur-6809607028734338a4644390df615667'%3e%3cfeGaussianBlur in='SourceGraphic' stdDeviation='40'/%3e%3c/filter%3e%3c/defs%3e%3cimage x='0' y='0' filter='url(%23__svg-blur-6809607028734338a4644390df615667)' width='1500' height='675' xlink:href='data:image/jpeg%3bbase64%2c/9j/2wBDAAYEBQYFBAYGBQYHBwYIChAKCgkJChQODwwQFxQYGBcUFhYaHSUfGhsjHBYWICwgIyYnKSopGR8tMC0oMCUoKSj/2wBDAQcHBwoIChMKChMoGhYaKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCj/wAARCAAdAEADASIAAhEBAxEB/8QAGwAAAgMAAwAAAAAAAAAAAAAAAgUDBAYBBwj/xAAuEAACAQMDAgQFBAMAAAAAAAABAgMABBEFEiEGMRRBQlETUnGBkQciMkNyobH/xAAYAQADAQEAAAAAAAAAAAAAAAAAAQMCBP/EACARAAIDAAICAwEAAAAAAAAAAAECAAMREjEhQTJxofD/2gAMAwEAAhEDEQA/APL0UXxFc7gNoz2qOiSRkBCnAPettddCi36et9V8aJI7jTxepGAAysFyykHuO2CPI11VUvccQdStNFlpPAbkw9HAqvIFclVPcgZP4rZWv6fz3Ns08Ws6WVXYGUu27ceSoGMk8gD5jwOaVa/09JoAhdr20u3ZtrJCTlDjIzke34PB5qIMkevESXMaxTMiljtJB3DBB9iKAxuApKNhslTjv5cVahWG4uH8ZN8A/wCJbLfXyrfab0zjRJjbiSSWJC8Mwm%2bGWZkDEKApwBkDk4J9qZgNzzOtSCO4I%2boqSSLZEj7gd3lg021/T721LvqM8ksgYBCxLZX3z%2bP90naRmUKT%2b0dqBA76g1ea8vp7SNZL2ZobcFI42kOEBGCFHkCOKo0ayMsbIP4t3pgkR6w%2bJkf2FP8AobSU1jqW1t5wfCJumuGHpjUZJ/4PvSGtV0W6JpfUG6PcwtgyMGKlSA3PHfv2NStV2QqnZlaWRbA1nQ/v2UtZk0G6txcaet3b3juVeB8MgA/sBA9Xy44Oe4q/o3VEqW62MkT7ZI1hYpOyBsKEHHpO0YJGM45rJDtXNCJwGbv3MO3M8iIx1i%2buNUl8ZdOmTwqKMbR7UuozKxiEfpBzQVSYG%2b5//9k=' /%3e%3c/svg%3e"},"locale":"ja"}},{"node":{"title":"Testing Neon EVM with Robonomics Smart Contracts","path":"/blog/ko/testing-neon-with-robonomics/","date":"October 3, 2022","description":"The purpose of these tests were to validate the readiness of the Neon platform to move to the production stage using Robonomics smart contracts, which allow cyber-physical systems (robots) to make technical-economic transactions.","content":"\n## TL;DR\n\nThe purpose of these tests were to validate the readiness of the [Neon](https://neon-labs.org/) platform to move to the production stage using Robonomics smart contracts, which allow cyber-physical systems (robots) to make technical-economic transactions.\n\nIn the Robonomics network, interaction is established between two parties: Promisee - the one who orders the service, sends a description of technical task and transfers funds for its execution; Promisor - one who performs a service. A typical scenario was tested, whereby a liability contract is concluded between a Promisee and a Promisor - this was followed by validation of the resulting work by a third party, and a commission payment to the node that accompanied the contract between the parties.\n\nFor this example, a simulation of a robotic arm was used, which was asked to perform a sequence of actions. The tests were successful.\n\n## Scope and Goals of Testing\n\nEngineers of [Multi-Agent Systems](https://multi-agent.io/) have been working with [Robonomics Network](https://robonomics.network/) for several years. The first implementation of the Robonomics Network was created for the Ethereum network. It is a set of smart contracts for machine-to-machine communication.\n\nThe core of the Robonomics Network is the [Liability](https://github.com/airalab/robonomics_contracts/blob/master/contracts/robonomics/Liability.sol) contract, a smart contract that reproduces the typical relationship between the customer of a service (Promisee) and the service provider (Promisor), and includes the technical and economic parameters of the transaction between them. The parties can be either an autonomous agent and a person (human-to-machine interaction), or purely two autonomous agents (machine-to-machine interaction). The Promisee and Promisor broadcast messages with the parameters of their technical-economic transaction, and then the conclusion of the transaction is provided by a special node - the Provider - which looks for matches of these parameters. Providers are controlled by [Lighthouse](https://github.com/airalab/robonomics_contracts/blob/master/contracts/robonomics/Lighthouse.sol), which is a special smart contract that executes a transaction when the provider establishes a market match between the parties.\n\nThere are three scenarios in which the fulfillment of an obligation can take place:\n\n1. A simple commitment (with no verification of the final result, and no commission paid to Provider nodes)\n2. Obligation with a commission paid to the Provider\n3. Commitment with a commission to the Provider and validation of the results with the help of a third party - observing network.\n\nThe purpose of this test is to test the most complex, third Robonomics scenario on the Neon EVM platform.\n\n## Testing Scenarios Description\n\nAs we develop the industrial zones and the infrastructure of modern cities, the emergence of fully automated enterprises and services that are controlled by cyber-physical systems (CPS) and which provide their services as autonomous agents is highly likely. In this regard, we can also expect the formation of networks of autonomous CPS in order to increase the speed and quality of communication in the process of production and provision of services.\n\nIn order to take full advantage of the possibilities of smart contracts, a scenario of interaction between two autonomous economic agents was chosen. Consider the liability life cycle in the Robonomics network:\n\n![Liability Life Cycle](./images/testing-neon-with-robonomics/step-by-step-3.jpg)\n\nThe figure above shows that the Robonomics network provider calls the Lighthouse contract, which in turn calls the [contract factory](https://github.com/airalab/robonomics_contracts/blob/master/contracts/robonomics/Factory.sol) to create the Liability contract. The Liability contract contains data about the transaction, such as the terms of reference, payment for the service, validator address and the deadline.\n\nTo learn more about the possible use cases for Robonomics, check out the Robonomics [R&D](https://wiki.robonomics.network/docs/en/r-and-d-based-on-robonomics-network/#launching-a-drone-under-the-control-of-a-decentralized-computer) page!\n\nTo replicate the entire Robonomics infrastructure on the Neon network, we will implement a robot launch scenario through a Liability contract similar to this [example](https://wiki.robonomics.network/docs/en/kuka/). If the script can be repeated, then all functions will work.\n\n## Deliverables\n\nThe source code for the Robonomics contracts is available [here](https://github.com/airalab/robonomics_contracts).\nThe contracts use many features of the Ethereum VM which includes:\n\n- ERC20 [XRT](https://github.com/airalab/robonomics_contracts/blob/master/contracts/robonomics/XRT.sol) Token\n- [Factory](https://github.com/airalab/robonomics_contracts/blob/master/contracts/robonomics/Factory.sol)\n- Own contract for [ENS](https://github.com/airalab/robonomics_contracts/blob/master/contracts/ens/ENS.sol)\n- [Proxy](https://github.com/airalab/robonomics_contracts/blob/master/contracts/misc/SharedCode.sol) for contracts\n- Various modifiers and roles in contracts\n\nAddresses of contracts in the Neon devnet network https://devnet.neonevm.org\n\n| Contract Name  | Address                                    |\n|----------------|--------------------------------------------|\n| Migrations     | 0x1DC538bE2C8572509a571B150f11aB55E52EF12E |\n| ENS            | 0xa7AEa12F60D0278F01e14DBC7cc459d04d051406 |\n| DutchAuction   | 0xF44F8803548D72Dbc3E28340EFD7b5328aa4F058 |\n| Liability      | 0xA694196351dc1488e3884eCc6b650F0d8D55346a |\n| Lighthouse     | 0x80FB5CC4c396E272b56700E6ffF5DBf4661013A8 |\n| XRT            | 0x3322d7D99cF65Cab5A92073c928b5E9674af3c29 |\n| PublicAmbix    | 0x85c03bE5ccFf11E79a0A776D183eF067590549d1 |\n| Factory        | 0xCFa833bF0D46369D9024f95c9C8dFa1E4a07806C |\n| PublicResolver | 0xAC9E9AA8A4cB524FE87f2b14489F1D6bE68dc46e |\n\n[Source code](https://github.com/Multi-Agent-io/neon-kuka-demo) for the scenario\n\n## Changes Made to Original Contracts\n\nThe contracts are written for Solidity 0.5.0. As such, no changes were required when deploying and using the contracts.\n\n## Testing Workflow\n\nIn general, the test consists of sending corresponding messages from one agent to another.\n\nNext, the Promisor finds a new liability contract in the network and begins to execute it. Upon completion of the work, a message is sent with the result, which is then recorded in the contract.\n\nStep-by-step instructions for launching are in [README.md](https://github.com/Multi-Agent-io/neon-kuka-demo/blob/main/README.md)\n\n## Testing Results in Detail\n\nScreencast of the process\n\nhttps://youtu.be/fYJVF7KrNnI\n\n![Liability](./images/testing-neon-with-robonomics/liability.jpg)\n\nWhen the simulation starts, an offer message is created, and a demand message comes from the Promisee, after which a Liability contract is created using the createLiability function of the Lighthouse contract. With the help of the XRT contract, tokens are transferred from the Promisee’s address to the address of the Liability contract.\n\nAfter a new Liability contract has been discovered on the Neon devnet, the agent starts working. The result of the work (telemetry) is written to a file and sent to IPFS, the hash from the file is saved as a result.\n\nAfter the work is completed, the Liability contract is finalized using the finalizeLiability() function of the Lighthouse contract and the tokens are transferred from the Liability address to the addresses of the Promisor and Validator.\n\nThe successful execution of the simulation showed that all contracts worked correctly and the Neon platform works.\n\n## Neon Platform Drawbacks\n\n### Truffle fails if it doesn't get a response from the network\n\nDuring the process of deploying contracts, it turned out that the proxy does not always return a response on time, which is why Truffle ends with an error:\n\n```\nTypeError: Cannot read properties of null (reading 'from')                                    \n    at Web3InterfaceAdapter.<anonymous> (/usr/lib/node_modules/truffle/build/webpack:/packages\n/interface-adapter/dist/adapter/web3/index.js:71:1)                                           \n    at Generator.next (<anonymous>)                                                           \n    at fulfilled (/usr/lib/node_modules/truffle/build/webpack:/packages/interface-adapter/dist\n/adapter/web3/index.js:5:43)                                                                  \n    at runMicrotasks (<anonymous>)\n    at processTicksAndRejections (node:internal/process/task_queues:96:5)\nTruffle v5.5.23 (core: 5.5.23)\nNode v16.14.0\n```\n\nIt was not possible to find a relationship between the test conditions and the occurrence of an error, but most likely Neon EVM cannot send a transaction receipt, and Truffle cannot process a Null response.\n\nIf we add timeout and retry here [index.ts#L75](https://github.com/trufflesuite/truffle/blob/develop/packages/interface-adapter/lib/adapter/web3/index.ts#L75), then the deployment should proceed without errors.\n\n### No WS/WSS Endpoint\n\nNeon EVM does not have a WS/WSS endpoint unlike Ethereum, which makes it impossible to subscribe to events from the network. Therefore, during testing, we monitored the events manually.\n\n### No Event Names\n\nNeon EVM returns rather poor descriptions of events after a transaction, for example:\n\n```\n events: {\n    '0': {\n      address: '0xCFa833bF0D46369D9024f95c9C8dFa1E4a07806C',\n      transactionHash: '0x9894a984e6b3f6ce469c8837e11739f6e50d00216cf7c5bc3d32da106a58d50a',\n      transactionLogIndex: '0x1',\n      blockHash: '0x72040f317d3a469d30327d4e1def903790b70dbede46b4f0ea4f28f30a679a80',\n      blockNumber: 156073183,\n      transactionIndex: 0,\n      logIndex: 1,\n      id: 'log_e51e2f9f',\n      returnValues: Result {},\n      event: undefined,\n      signature: null,\n      raw: [Object]\n    },\n...\n```\n\nInstead of 0, 1, etc. we expected to see named events.\n\n## Conclusion\n\nUsing the Neon EVM platform, a scenario was successfully tested whereby a liability contract between a Promisee and a Promisor is concluded with subsequent validation of the result of the work done by a third party. Additionally, a Provider participated, who checked the coincidence of supply and demand between the parties, and received a commission for this work.\n\nThe demonstration used a simulation of a robotic arm that was hired to perform a sequence of actions. As a result of the work, the robot sent a file with telemetry received during the task.\n\nDespite some peculiarities in the operation of the network, in the end, all participating contracts showed their operability in the Neon environment.\n\n\n\n","cover_image":{"type":"image","mimeType":"image/jpeg","src":"/assets/static/blog_cover_neon_multi-agent.62c183a.6231caf624da0ea84dd55d0582533702.jpg","size":{"width":1500,"height":675},"sizes":"(max-width: 1500px) 100vw, 1500px","srcset":["/assets/static/blog_cover_neon_multi-agent.9ea8d39.6231caf624da0ea84dd55d0582533702.jpg 480w","/assets/static/blog_cover_neon_multi-agent.6b2ed88.6231caf624da0ea84dd55d0582533702.jpg 1024w","/assets/static/blog_cover_neon_multi-agent.62c183a.6231caf624da0ea84dd55d0582533702.jpg 1500w"],"dataUri":"data:image/svg+xml,%3csvg fill='none' viewBox='0 0 1500 675' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'%3e%3cdefs%3e%3cfilter id='__svg-blur-6809607028734338a4644390df615667'%3e%3cfeGaussianBlur in='SourceGraphic' stdDeviation='40'/%3e%3c/filter%3e%3c/defs%3e%3cimage x='0' y='0' filter='url(%23__svg-blur-6809607028734338a4644390df615667)' width='1500' height='675' xlink:href='data:image/jpeg%3bbase64%2c/9j/2wBDAAYEBQYFBAYGBQYHBwYIChAKCgkJChQODwwQFxQYGBcUFhYaHSUfGhsjHBYWICwgIyYnKSopGR8tMC0oMCUoKSj/2wBDAQcHBwoIChMKChMoGhYaKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCj/wAARCAAdAEADASIAAhEBAxEB/8QAGwAAAgMAAwAAAAAAAAAAAAAAAgUDBAYBBwj/xAAuEAACAQMDAgQFBAMAAAAAAAABAgMABBEFEiEGMRRBQlETUnGBkQciMkNyobH/xAAYAQADAQEAAAAAAAAAAAAAAAAAAQMCBP/EACARAAIDAAICAwEAAAAAAAAAAAECAAMREjEhQTJxofD/2gAMAwEAAhEDEQA/APL0UXxFc7gNoz2qOiSRkBCnAPettddCi36et9V8aJI7jTxepGAAysFyykHuO2CPI11VUvccQdStNFlpPAbkw9HAqvIFclVPcgZP4rZWv6fz3Ns08Ws6WVXYGUu27ceSoGMk8gD5jwOaVa/09JoAhdr20u3ZtrJCTlDjIzke34PB5qIMkevESXMaxTMiljtJB3DBB9iKAxuApKNhslTjv5cVahWG4uH8ZN8A/wCJbLfXyrfab0zjRJjbiSSWJC8Mwm%2bGWZkDEKApwBkDk4J9qZgNzzOtSCO4I%2boqSSLZEj7gd3lg021/T721LvqM8ksgYBCxLZX3z%2bP90naRmUKT%2b0dqBA76g1ea8vp7SNZL2ZobcFI42kOEBGCFHkCOKo0ayMsbIP4t3pgkR6w%2bJkf2FP8AobSU1jqW1t5wfCJumuGHpjUZJ/4PvSGtV0W6JpfUG6PcwtgyMGKlSA3PHfv2NStV2QqnZlaWRbA1nQ/v2UtZk0G6txcaet3b3juVeB8MgA/sBA9Xy44Oe4q/o3VEqW62MkT7ZI1hYpOyBsKEHHpO0YJGM45rJDtXNCJwGbv3MO3M8iIx1i%2buNUl8ZdOmTwqKMbR7UuozKxiEfpBzQVSYG%2b5//9k=' /%3e%3c/svg%3e"},"locale":"ko"}},{"node":{"title":"Testing Neon EVM with Robonomics Smart Contracts","path":"/blog/pt/testing-neon-with-robonomics/","date":"October 3, 2022","description":"The purpose of these tests were to validate the readiness of the Neon platform to move to the production stage using Robonomics smart contracts, which allow cyber-physical systems (robots) to make technical-economic transactions.","content":"\n## TL;DR\n\nThe purpose of these tests were to validate the readiness of the [Neon](https://neon-labs.org/) platform to move to the production stage using Robonomics smart contracts, which allow cyber-physical systems (robots) to make technical-economic transactions.\n\nIn the Robonomics network, interaction is established between two parties: Promisee - the one who orders the service, sends a description of technical task and transfers funds for its execution; Promisor - one who performs a service. A typical scenario was tested, whereby a liability contract is concluded between a Promisee and a Promisor - this was followed by validation of the resulting work by a third party, and a commission payment to the node that accompanied the contract between the parties.\n\nFor this example, a simulation of a robotic arm was used, which was asked to perform a sequence of actions. The tests were successful.\n\n## Scope and Goals of Testing\n\nEngineers of [Multi-Agent Systems](https://multi-agent.io/) have been working with [Robonomics Network](https://robonomics.network/) for several years. The first implementation of the Robonomics Network was created for the Ethereum network. It is a set of smart contracts for machine-to-machine communication.\n\nThe core of the Robonomics Network is the [Liability](https://github.com/airalab/robonomics_contracts/blob/master/contracts/robonomics/Liability.sol) contract, a smart contract that reproduces the typical relationship between the customer of a service (Promisee) and the service provider (Promisor), and includes the technical and economic parameters of the transaction between them. The parties can be either an autonomous agent and a person (human-to-machine interaction), or purely two autonomous agents (machine-to-machine interaction). The Promisee and Promisor broadcast messages with the parameters of their technical-economic transaction, and then the conclusion of the transaction is provided by a special node - the Provider - which looks for matches of these parameters. Providers are controlled by [Lighthouse](https://github.com/airalab/robonomics_contracts/blob/master/contracts/robonomics/Lighthouse.sol), which is a special smart contract that executes a transaction when the provider establishes a market match between the parties.\n\nThere are three scenarios in which the fulfillment of an obligation can take place:\n\n1. A simple commitment (with no verification of the final result, and no commission paid to Provider nodes)\n2. Obligation with a commission paid to the Provider\n3. Commitment with a commission to the Provider and validation of the results with the help of a third party - observing network.\n\nThe purpose of this test is to test the most complex, third Robonomics scenario on the Neon EVM platform.\n\n## Testing Scenarios Description\n\nAs we develop the industrial zones and the infrastructure of modern cities, the emergence of fully automated enterprises and services that are controlled by cyber-physical systems (CPS) and which provide their services as autonomous agents is highly likely. In this regard, we can also expect the formation of networks of autonomous CPS in order to increase the speed and quality of communication in the process of production and provision of services.\n\nIn order to take full advantage of the possibilities of smart contracts, a scenario of interaction between two autonomous economic agents was chosen. Consider the liability life cycle in the Robonomics network:\n\n![Liability Life Cycle](./images/testing-neon-with-robonomics/step-by-step-3.jpg)\n\nThe figure above shows that the Robonomics network provider calls the Lighthouse contract, which in turn calls the [contract factory](https://github.com/airalab/robonomics_contracts/blob/master/contracts/robonomics/Factory.sol) to create the Liability contract. The Liability contract contains data about the transaction, such as the terms of reference, payment for the service, validator address and the deadline.\n\nTo learn more about the possible use cases for Robonomics, check out the Robonomics [R&D](https://wiki.robonomics.network/docs/en/r-and-d-based-on-robonomics-network/#launching-a-drone-under-the-control-of-a-decentralized-computer) page!\n\nTo replicate the entire Robonomics infrastructure on the Neon network, we will implement a robot launch scenario through a Liability contract similar to this [example](https://wiki.robonomics.network/docs/en/kuka/). If the script can be repeated, then all functions will work.\n\n## Deliverables\n\nThe source code for the Robonomics contracts is available [here](https://github.com/airalab/robonomics_contracts).\nThe contracts use many features of the Ethereum VM which includes:\n\n- ERC20 [XRT](https://github.com/airalab/robonomics_contracts/blob/master/contracts/robonomics/XRT.sol) Token\n- [Factory](https://github.com/airalab/robonomics_contracts/blob/master/contracts/robonomics/Factory.sol)\n- Own contract for [ENS](https://github.com/airalab/robonomics_contracts/blob/master/contracts/ens/ENS.sol)\n- [Proxy](https://github.com/airalab/robonomics_contracts/blob/master/contracts/misc/SharedCode.sol) for contracts\n- Various modifiers and roles in contracts\n\nAddresses of contracts in the Neon devnet network https://devnet.neonevm.org\n\n| Contract Name  | Address                                    |\n|----------------|--------------------------------------------|\n| Migrations     | 0x1DC538bE2C8572509a571B150f11aB55E52EF12E |\n| ENS            | 0xa7AEa12F60D0278F01e14DBC7cc459d04d051406 |\n| DutchAuction   | 0xF44F8803548D72Dbc3E28340EFD7b5328aa4F058 |\n| Liability      | 0xA694196351dc1488e3884eCc6b650F0d8D55346a |\n| Lighthouse     | 0x80FB5CC4c396E272b56700E6ffF5DBf4661013A8 |\n| XRT            | 0x3322d7D99cF65Cab5A92073c928b5E9674af3c29 |\n| PublicAmbix    | 0x85c03bE5ccFf11E79a0A776D183eF067590549d1 |\n| Factory        | 0xCFa833bF0D46369D9024f95c9C8dFa1E4a07806C |\n| PublicResolver | 0xAC9E9AA8A4cB524FE87f2b14489F1D6bE68dc46e |\n\n[Source code](https://github.com/Multi-Agent-io/neon-kuka-demo) for the scenario\n\n## Changes Made to Original Contracts\n\nThe contracts are written for Solidity 0.5.0. As such, no changes were required when deploying and using the contracts.\n\n## Testing Workflow\n\nIn general, the test consists of sending corresponding messages from one agent to another.\n\nNext, the Promisor finds a new liability contract in the network and begins to execute it. Upon completion of the work, a message is sent with the result, which is then recorded in the contract.\n\nStep-by-step instructions for launching are in [README.md](https://github.com/Multi-Agent-io/neon-kuka-demo/blob/main/README.md)\n\n## Testing Results in Detail\n\nScreencast of the process\n\nhttps://youtu.be/fYJVF7KrNnI\n\n![Liability](./images/testing-neon-with-robonomics/liability.jpg)\n\nWhen the simulation starts, an offer message is created, and a demand message comes from the Promisee, after which a Liability contract is created using the createLiability function of the Lighthouse contract. With the help of the XRT contract, tokens are transferred from the Promisee’s address to the address of the Liability contract.\n\nAfter a new Liability contract has been discovered on the Neon devnet, the agent starts working. The result of the work (telemetry) is written to a file and sent to IPFS, the hash from the file is saved as a result.\n\nAfter the work is completed, the Liability contract is finalized using the finalizeLiability() function of the Lighthouse contract and the tokens are transferred from the Liability address to the addresses of the Promisor and Validator.\n\nThe successful execution of the simulation showed that all contracts worked correctly and the Neon platform works.\n\n## Neon Platform Drawbacks\n\n### Truffle fails if it doesn't get a response from the network\n\nDuring the process of deploying contracts, it turned out that the proxy does not always return a response on time, which is why Truffle ends with an error:\n\n```\nTypeError: Cannot read properties of null (reading 'from')                                    \n    at Web3InterfaceAdapter.<anonymous> (/usr/lib/node_modules/truffle/build/webpack:/packages\n/interface-adapter/dist/adapter/web3/index.js:71:1)                                           \n    at Generator.next (<anonymous>)                                                           \n    at fulfilled (/usr/lib/node_modules/truffle/build/webpack:/packages/interface-adapter/dist\n/adapter/web3/index.js:5:43)                                                                  \n    at runMicrotasks (<anonymous>)\n    at processTicksAndRejections (node:internal/process/task_queues:96:5)\nTruffle v5.5.23 (core: 5.5.23)\nNode v16.14.0\n```\n\nIt was not possible to find a relationship between the test conditions and the occurrence of an error, but most likely Neon EVM cannot send a transaction receipt, and Truffle cannot process a Null response.\n\nIf we add timeout and retry here [index.ts#L75](https://github.com/trufflesuite/truffle/blob/develop/packages/interface-adapter/lib/adapter/web3/index.ts#L75), then the deployment should proceed without errors.\n\n### No WS/WSS Endpoint\n\nNeon EVM does not have a WS/WSS endpoint unlike Ethereum, which makes it impossible to subscribe to events from the network. Therefore, during testing, we monitored the events manually.\n\n### No Event Names\n\nNeon EVM returns rather poor descriptions of events after a transaction, for example:\n\n```\n events: {\n    '0': {\n      address: '0xCFa833bF0D46369D9024f95c9C8dFa1E4a07806C',\n      transactionHash: '0x9894a984e6b3f6ce469c8837e11739f6e50d00216cf7c5bc3d32da106a58d50a',\n      transactionLogIndex: '0x1',\n      blockHash: '0x72040f317d3a469d30327d4e1def903790b70dbede46b4f0ea4f28f30a679a80',\n      blockNumber: 156073183,\n      transactionIndex: 0,\n      logIndex: 1,\n      id: 'log_e51e2f9f',\n      returnValues: Result {},\n      event: undefined,\n      signature: null,\n      raw: [Object]\n    },\n...\n```\n\nInstead of 0, 1, etc. we expected to see named events.\n\n## Conclusion\n\nUsing the Neon EVM platform, a scenario was successfully tested whereby a liability contract between a Promisee and a Promisor is concluded with subsequent validation of the result of the work done by a third party. Additionally, a Provider participated, who checked the coincidence of supply and demand between the parties, and received a commission for this work.\n\nThe demonstration used a simulation of a robotic arm that was hired to perform a sequence of actions. As a result of the work, the robot sent a file with telemetry received during the task.\n\nDespite some peculiarities in the operation of the network, in the end, all participating contracts showed their operability in the Neon environment.\n\n\n\n","cover_image":{"type":"image","mimeType":"image/jpeg","src":"/assets/static/blog_cover_neon_multi-agent.62c183a.6231caf624da0ea84dd55d0582533702.jpg","size":{"width":1500,"height":675},"sizes":"(max-width: 1500px) 100vw, 1500px","srcset":["/assets/static/blog_cover_neon_multi-agent.9ea8d39.6231caf624da0ea84dd55d0582533702.jpg 480w","/assets/static/blog_cover_neon_multi-agent.6b2ed88.6231caf624da0ea84dd55d0582533702.jpg 1024w","/assets/static/blog_cover_neon_multi-agent.62c183a.6231caf624da0ea84dd55d0582533702.jpg 1500w"],"dataUri":"data:image/svg+xml,%3csvg fill='none' viewBox='0 0 1500 675' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'%3e%3cdefs%3e%3cfilter id='__svg-blur-6809607028734338a4644390df615667'%3e%3cfeGaussianBlur in='SourceGraphic' stdDeviation='40'/%3e%3c/filter%3e%3c/defs%3e%3cimage x='0' y='0' filter='url(%23__svg-blur-6809607028734338a4644390df615667)' width='1500' height='675' xlink:href='data:image/jpeg%3bbase64%2c/9j/2wBDAAYEBQYFBAYGBQYHBwYIChAKCgkJChQODwwQFxQYGBcUFhYaHSUfGhsjHBYWICwgIyYnKSopGR8tMC0oMCUoKSj/2wBDAQcHBwoIChMKChMoGhYaKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCj/wAARCAAdAEADASIAAhEBAxEB/8QAGwAAAgMAAwAAAAAAAAAAAAAAAgUDBAYBBwj/xAAuEAACAQMDAgQFBAMAAAAAAAABAgMABBEFEiEGMRRBQlETUnGBkQciMkNyobH/xAAYAQADAQEAAAAAAAAAAAAAAAAAAQMCBP/EACARAAIDAAICAwEAAAAAAAAAAAECAAMREjEhQTJxofD/2gAMAwEAAhEDEQA/APL0UXxFc7gNoz2qOiSRkBCnAPettddCi36et9V8aJI7jTxepGAAysFyykHuO2CPI11VUvccQdStNFlpPAbkw9HAqvIFclVPcgZP4rZWv6fz3Ns08Ws6WVXYGUu27ceSoGMk8gD5jwOaVa/09JoAhdr20u3ZtrJCTlDjIzke34PB5qIMkevESXMaxTMiljtJB3DBB9iKAxuApKNhslTjv5cVahWG4uH8ZN8A/wCJbLfXyrfab0zjRJjbiSSWJC8Mwm%2bGWZkDEKApwBkDk4J9qZgNzzOtSCO4I%2boqSSLZEj7gd3lg021/T721LvqM8ksgYBCxLZX3z%2bP90naRmUKT%2b0dqBA76g1ea8vp7SNZL2ZobcFI42kOEBGCFHkCOKo0ayMsbIP4t3pgkR6w%2bJkf2FP8AobSU1jqW1t5wfCJumuGHpjUZJ/4PvSGtV0W6JpfUG6PcwtgyMGKlSA3PHfv2NStV2QqnZlaWRbA1nQ/v2UtZk0G6txcaet3b3juVeB8MgA/sBA9Xy44Oe4q/o3VEqW62MkT7ZI1hYpOyBsKEHHpO0YJGM45rJDtXNCJwGbv3MO3M8iIx1i%2buNUl8ZdOmTwqKMbR7UuozKxiEfpBzQVSYG%2b5//9k=' /%3e%3c/svg%3e"},"locale":"pt"}},{"node":{"title":"Testing Neon EVM with Robonomics Smart Contracts","path":"/blog/ru/testing-neon-with-robonomics/","date":"October 3, 2022","description":"Целью настоящего тестирования была проверка платформы Neon на предмет её готовности к production stage с помощью умных контрактов Robonomics, которые позволяют кибер-физическим системам (роботам) заключать сделки на выполнение заложенного в них алгоритма","content":"\n## TL;DR\n\nЦелью настоящего тестирования была проверка платформы [Neon](https://neon-labs.org/) на предмет её готовности к production stage с помощью умных контрактов Robonomics, которые позволяют кибер-физическим системам (роботам) заключать сделки на выполнение заложенного в них алгоритма.  \n\nВ сети Robonomics взаимодействие устанавливается между двумя сторонами: promisee - тот, кто заказывает услугу и передает техническое задание и средства на его исполнение; promisor - тот, кто исполняет услугу. Был проверен сценарий, когда контракт обязательства заключается между promisee и promisor с последующей валидацией результата работы третьей стороной и оплатой комиссии узлу, который сопроводил контракт между сторонами. \n\nВ качестве примера использовалась симуляция робота-манипулятора, которому предложили выполнить последовательность действий. Тестирование прошло успешно. \n\n## Цели тестирования\n\nИнженеры [Multi-Agent Systems](https://multi-agent.io/) работают с [Robonomics Network](https://robonomics.network/) уже несколько лет. Первая реализация реализация Robonomics Network была создана для сети Ethereum. Она представляет собой набор smart contracts для межмашинного взаимодействия. \n\nЯдром Robonomics Network является контракт [Liability](https://github.com/airalab/robonomics_contracts/blob/master/contracts/robonomics/Liability.sol) — умный контракт, который воспроизводит типичные отношения между заказчиком какой-либо услуги (Promisee) и исполнителем услуги (Promisor), и включает в себя технические и экономические параметры сделки между ними. Сторонами могут выступать как автономный агент и человек (human-to-machine interaction), так и чисто два автономных агента (machine-to-machine interaction). Promisee и Promisor транслируют сообщения с параметрами их спроса и предложения, а затем заключение сделки обеспечивается специальным узлом — провайдером — который ищет совпадения этих параметров. Провайдеры управляются [Lighthouse](https://github.com/airalab/robonomics_contracts/blob/master/contracts/robonomics/Lighthouse.sol) — специальным смарт-контрактом, который выполняет транзакцию, когда провайдер устанавливает рыночное соответствие между сторонами.\n\nСуществуют три сценария, по которым может проходить исполнение обязательства:\n\n1. Простое обязательство (без проверки конечного результата и без комиссии провайдера за его работу)\n2. Обязательство с комиссией провайдеру\n3. Обязательство с комиссией провайдеру и с валидацией результатов с помощью третьей стороны — observing network.\n\nЦель настоящего тестирования заключается в проверке самого сложного, третьего сценария Robonomics на платформе Neon EVM. \n\n## Описание тестового сценария\n\nВ работе промышленных зон и инфраструктуре современных городов весьма вероятно появление полностью автоматизированных предприятий и служб, которые контролируются кибер-физическими системами (КФС), и которые предоставляют свои услуги, как автономные агенты. В связи с этим можно ожидать также и формирование сетей из автономных КФС с целью повышения скорости и качества коммуникации в процессе производства и оказания услуг. \n\nЧтобы в полной мере воспользоваться возможностями умных контрактов был выбран сценарий взаимодействия двух автономных экономических агентов. Рассмотрим жизненный цикл обязательства в сети Robonomics: \n\n![Liability Life Cycle](./images/testing-neon-with-robonomics/step-by-step-3.jpg)\n\nНа рисунке выше показано, что провайдер сети Robonomics обращается к контракту Lighthouse, который в свою очередь вызывает [фабрику контрактов](https://github.com/airalab/robonomics_contracts/blob/master/contracts/robonomics/Factory.sol) для создания контракта Liability. Последний содержит в себе данные о сделки, такие как техническое задание, оплату за услугу, адрес валидатора и deadline. \n\nЧтобы узнать больше о возможных сценариях применения Robonomics ознакомтесь с нашими [R&D](https://wiki.robonomics.network/docs/en/r-and-d-based-on-robonomics-network/#launching-a-drone-under-the-control-of-a-decentralized-computer)\n\nПовторяя всю инфраструктуру Robonomics в сети Neon, мы реализуем сценарий запуска робота через Liability контракт, аналогичный этому [примеру](https://wiki.robonomics.network/docs/en/kuka/). Если получится повторить сценарий, значит все функции работают.\n\n## Практические результаты\n\nИсходный код контрактов Robonomics доступен [здесь](https://github.com/airalab/robonomics_contracts).\n\nКонтракты используют множество функций Ethereum VM и включают в себя \n\n- Токен ERC20 [XRT](https://github.com/airalab/robonomics_contracts/blob/master/contracts/robonomics/XRT.sol) \n- [Фабрику контрактов](https://github.com/airalab/robonomics_contracts/blob/master/contracts/robonomics/Factory.sol) \n- Собственный контракт для [ENS](https://github.com/airalab/robonomics_contracts/blob/master/contracts/ens/ENS.sol) \n- [Proxy](https://github.com/airalab/robonomics_contracts/blob/master/contracts/misc/SharedCode.sol) для контрактов \n- Различные модификаторы и роли в контрактах\n\nАдреса контрактов в devnet сети Neon https://devnet.neonevm.org\n\n| Contract Name  | Address                                    |\n|----------------|--------------------------------------------|\n| Migrations     | 0x1DC538bE2C8572509a571B150f11aB55E52EF12E |\n| ENS            | 0xa7AEa12F60D0278F01e14DBC7cc459d04d051406 |\n| DutchAuction   | 0xF44F8803548D72Dbc3E28340EFD7b5328aa4F058 |\n| Liability      | 0xA694196351dc1488e3884eCc6b650F0d8D55346a |\n| Lighthouse     | 0x80FB5CC4c396E272b56700E6ffF5DBf4661013A8 |\n| XRT            | 0x3322d7D99cF65Cab5A92073c928b5E9674af3c29 |\n| PublicAmbix    | 0x85c03bE5ccFf11E79a0A776D183eF067590549d1 |\n| Factory        | 0xCFa833bF0D46369D9024f95c9C8dFa1E4a07806C |\n| PublicResolver | 0xAC9E9AA8A4cB524FE87f2b14489F1D6bE68dc46e |\n\n[Исходный код](https://github.com/Multi-Agent-io/neon-kuka-demo) подготовленного сценария \n\n## Изменения, внесенные в исходные контракты\n\nКонтракты написаны для Solidity 0.5.0. Таким образом, никаких изменений при развертывании и использовании контрактов не требовалось.\n\n## Процесс тестирования\n\nВ общем случае тест заключается в отправке соответствующих сообщений от одного и другого агента. \n\nДальше, исполнитель находит новый контракт обязательства в сети и начинает его исполнение. По завершению работы отправляется сообщение с результатом, которое записывается в контракт.\n\nПошаговая инструкция по запуску находится в [README.md](https://github.com/Multi-Agent-io/neon-kuka-demo/blob/main/README.md)\n\n## Результаты тестирования\n\nВидео работы\n\nhttps://youtu.be/fYJVF7KrNnI\n\n![Liability](./images/testing-neon-with-robonomics/liability.jpg)\n\nПри запуске симуляции создаются сообщения оффера, а от клиента приходит сообщение деманда, после чего создается контракт Liability с помощью функции `createLiability` контракта Lighthouse. С помощью контракта XRT происходит перевод токенов с адреса заказчика на адрес контракта Liability. \n\nПосле того, как в тестовой сети Neon был обнаружен новый контракт Liability, агент начинает работу. Результат работы (телеметрия) записывается в файл и отправляется в IPFS, хэш от файла сохраняется в качестве результата.\n\nПосле выполнения работы происходит финализация контракта Liability с помощью функции `finalizeLiability()` контракта Lighthouse и перевод токенов с адреса Liability на адреса исполнителя и валидатора.\n\nУспешное выполнение симуляции показали, что все контракты отработали правильно и решение на Neon EVM работает.\n\n## Недостатки платформы Neon\n\n### Truffle завершается с ошибкой, если не получает ответ от сети\n\nВ процессе загрузки контрактов выяснилось, что proxy не всегда возвращает ответ вовремя, отчего Truffle завершается с ошибкой:\n\n```\nTypeError: Cannot read properties of null (reading 'from')                                    \n    at Web3InterfaceAdapter.<anonymous> (/usr/lib/node_modules/truffle/build/webpack:/packages\n/interface-adapter/dist/adapter/web3/index.js:71:1)                                           \n    at Generator.next (<anonymous>)                                                           \n    at fulfilled (/usr/lib/node_modules/truffle/build/webpack:/packages/interface-adapter/dist\n/adapter/web3/index.js:5:43)                                                                  \n    at runMicrotasks (<anonymous>)\n    at processTicksAndRejections (node:internal/process/task_queues:96:5)\nTruffle v5.5.23 (core: 5.5.23)\nNode v16.14.0\n```\n\nНе удалось найти зависимость между условиями тестирования и возникновением ошибки, но вероятнее всего Neon EVM не может отправить receipt транзакции, а Truffle не может обработать ответ Null. \n\nЕсли здесь [index.ts#L75](https://github.com/trufflesuite/truffle/blob/develop/packages/interface-adapter/lib/adapter/web3/index.ts#L75) добавить timeout и retry, то развертывание должно проходить без ошибок.\n\n### Отсутствует WS/WSS Endpoint\n\nУ Neon EVM нет WS/WSS endpoint в отличие от Ethereum, что делает невозможным подписку на события из сети. Поэтому в ходе тестирования мы следили за событиями вручную.\n\n### Нет поименованных событий\n\nNeon EVM возвращает довольно скудные описания событий после транзакции, например:\n\n```\n events: {\n    '0': {\n      address: '0xCFa833bF0D46369D9024f95c9C8dFa1E4a07806C',\n      transactionHash: '0x9894a984e6b3f6ce469c8837e11739f6e50d00216cf7c5bc3d32da106a58d50a',\n      transactionLogIndex: '0x1',\n      blockHash: '0x72040f317d3a469d30327d4e1def903790b70dbede46b4f0ea4f28f30a679a80',\n      blockNumber: 156073183,\n      transactionIndex: 0,\n      logIndex: 1,\n      id: 'log_e51e2f9f',\n      returnValues: Result {},\n      event: undefined,\n      signature: null,\n      raw: [Object]\n    },\n...\n```\n\nВместо 0, 1 и т.д. мы ожидали увидеть поименованные события.\n\n## Заключение\n\nНа платформе Neon EVM был успешно проверен сценарий, когда контракт обязательства между promisee и promisor заключается с последующей валидацией результата работы третьей стороной. Дополнительно участвовал провайдер, который проверил совпадение спроса и предложения между сторонами, и получил за эту работу комиссию.\n\nДля демонстрации использовалась симуляция робота-манипулятора, которого наняли на выполнение последовательности действий. В качестве результата работы робот отправил файл с телеметрией, полученной во время выполнения задачи. \n\nНесмотря на некоторые особенности в работе сети, в итоге все участвующие контракты показали свою работоспособность в среде Neon.\n","cover_image":{"type":"image","mimeType":"image/jpeg","src":"/assets/static/blog_cover_neon_multi-agent.62c183a.6231caf624da0ea84dd55d0582533702.jpg","size":{"width":1500,"height":675},"sizes":"(max-width: 1500px) 100vw, 1500px","srcset":["/assets/static/blog_cover_neon_multi-agent.9ea8d39.6231caf624da0ea84dd55d0582533702.jpg 480w","/assets/static/blog_cover_neon_multi-agent.6b2ed88.6231caf624da0ea84dd55d0582533702.jpg 1024w","/assets/static/blog_cover_neon_multi-agent.62c183a.6231caf624da0ea84dd55d0582533702.jpg 1500w"],"dataUri":"data:image/svg+xml,%3csvg fill='none' viewBox='0 0 1500 675' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'%3e%3cdefs%3e%3cfilter id='__svg-blur-6809607028734338a4644390df615667'%3e%3cfeGaussianBlur in='SourceGraphic' stdDeviation='40'/%3e%3c/filter%3e%3c/defs%3e%3cimage x='0' y='0' filter='url(%23__svg-blur-6809607028734338a4644390df615667)' width='1500' height='675' xlink:href='data:image/jpeg%3bbase64%2c/9j/2wBDAAYEBQYFBAYGBQYHBwYIChAKCgkJChQODwwQFxQYGBcUFhYaHSUfGhsjHBYWICwgIyYnKSopGR8tMC0oMCUoKSj/2wBDAQcHBwoIChMKChMoGhYaKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCj/wAARCAAdAEADASIAAhEBAxEB/8QAGwAAAgMAAwAAAAAAAAAAAAAAAgUDBAYBBwj/xAAuEAACAQMDAgQFBAMAAAAAAAABAgMABBEFEiEGMRRBQlETUnGBkQciMkNyobH/xAAYAQADAQEAAAAAAAAAAAAAAAAAAQMCBP/EACARAAIDAAICAwEAAAAAAAAAAAECAAMREjEhQTJxofD/2gAMAwEAAhEDEQA/APL0UXxFc7gNoz2qOiSRkBCnAPettddCi36et9V8aJI7jTxepGAAysFyykHuO2CPI11VUvccQdStNFlpPAbkw9HAqvIFclVPcgZP4rZWv6fz3Ns08Ws6WVXYGUu27ceSoGMk8gD5jwOaVa/09JoAhdr20u3ZtrJCTlDjIzke34PB5qIMkevESXMaxTMiljtJB3DBB9iKAxuApKNhslTjv5cVahWG4uH8ZN8A/wCJbLfXyrfab0zjRJjbiSSWJC8Mwm%2bGWZkDEKApwBkDk4J9qZgNzzOtSCO4I%2boqSSLZEj7gd3lg021/T721LvqM8ksgYBCxLZX3z%2bP90naRmUKT%2b0dqBA76g1ea8vp7SNZL2ZobcFI42kOEBGCFHkCOKo0ayMsbIP4t3pgkR6w%2bJkf2FP8AobSU1jqW1t5wfCJumuGHpjUZJ/4PvSGtV0W6JpfUG6PcwtgyMGKlSA3PHfv2NStV2QqnZlaWRbA1nQ/v2UtZk0G6txcaet3b3juVeB8MgA/sBA9Xy44Oe4q/o3VEqW62MkT7ZI1hYpOyBsKEHHpO0YJGM45rJDtXNCJwGbv3MO3M8iIx1i%2buNUl8ZdOmTwqKMbR7UuozKxiEfpBzQVSYG%2b5//9k=' /%3e%3c/svg%3e"},"locale":"ru"}},{"node":{"title":"Testing Neon EVM with Robonomics Smart Contracts","path":"/blog/zh/testing-neon-with-robonomics/","date":"October 3, 2022","description":"The purpose of these tests were to validate the readiness of the Neon platform to move to the production stage using Robonomics smart contracts, which allow cyber-physical systems (robots) to make technical-economic transactions.","content":"\n## TL;DR\n\nThe purpose of these tests were to validate the readiness of the [Neon](https://neon-labs.org/) platform to move to the production stage using Robonomics smart contracts, which allow cyber-physical systems (robots) to make technical-economic transactions.\n\nIn the Robonomics network, interaction is established between two parties: Promisee - the one who orders the service, sends a description of technical task and transfers funds for its execution; Promisor - one who performs a service. A typical scenario was tested, whereby a liability contract is concluded between a Promisee and a Promisor - this was followed by validation of the resulting work by a third party, and a commission payment to the node that accompanied the contract between the parties.\n\nFor this example, a simulation of a robotic arm was used, which was asked to perform a sequence of actions. The tests were successful.\n\n## Scope and Goals of Testing\n\nEngineers of [Multi-Agent Systems](https://multi-agent.io/) have been working with [Robonomics Network](https://robonomics.network/) for several years. The first implementation of the Robonomics Network was created for the Ethereum network. It is a set of smart contracts for machine-to-machine communication.\n\nThe core of the Robonomics Network is the [Liability](https://github.com/airalab/robonomics_contracts/blob/master/contracts/robonomics/Liability.sol) contract, a smart contract that reproduces the typical relationship between the customer of a service (Promisee) and the service provider (Promisor), and includes the technical and economic parameters of the transaction between them. The parties can be either an autonomous agent and a person (human-to-machine interaction), or purely two autonomous agents (machine-to-machine interaction). The Promisee and Promisor broadcast messages with the parameters of their technical-economic transaction, and then the conclusion of the transaction is provided by a special node - the Provider - which looks for matches of these parameters. Providers are controlled by [Lighthouse](https://github.com/airalab/robonomics_contracts/blob/master/contracts/robonomics/Lighthouse.sol), which is a special smart contract that executes a transaction when the provider establishes a market match between the parties.\n\nThere are three scenarios in which the fulfillment of an obligation can take place:\n\n1. A simple commitment (with no verification of the final result, and no commission paid to Provider nodes)\n2. Obligation with a commission paid to the Provider\n3. Commitment with a commission to the Provider and validation of the results with the help of a third party - observing network.\n\nThe purpose of this test is to test the most complex, third Robonomics scenario on the Neon EVM platform.\n\n## Testing Scenarios Description\n\nAs we develop the industrial zones and the infrastructure of modern cities, the emergence of fully automated enterprises and services that are controlled by cyber-physical systems (CPS) and which provide their services as autonomous agents is highly likely. In this regard, we can also expect the formation of networks of autonomous CPS in order to increase the speed and quality of communication in the process of production and provision of services.\n\nIn order to take full advantage of the possibilities of smart contracts, a scenario of interaction between two autonomous economic agents was chosen. Consider the liability life cycle in the Robonomics network:\n\n![Liability Life Cycle](./images/testing-neon-with-robonomics/step-by-step-3.jpg)\n\nThe figure above shows that the Robonomics network provider calls the Lighthouse contract, which in turn calls the [contract factory](https://github.com/airalab/robonomics_contracts/blob/master/contracts/robonomics/Factory.sol) to create the Liability contract. The Liability contract contains data about the transaction, such as the terms of reference, payment for the service, validator address and the deadline.\n\nTo learn more about the possible use cases for Robonomics, check out the Robonomics [R&D](https://wiki.robonomics.network/docs/en/r-and-d-based-on-robonomics-network/#launching-a-drone-under-the-control-of-a-decentralized-computer) page!\n\nTo replicate the entire Robonomics infrastructure on the Neon network, we will implement a robot launch scenario through a Liability contract similar to this [example](https://wiki.robonomics.network/docs/en/kuka/). If the script can be repeated, then all functions will work.\n\n## Deliverables\n\nThe source code for the Robonomics contracts is available [here](https://github.com/airalab/robonomics_contracts).\nThe contracts use many features of the Ethereum VM which includes:\n\n- ERC20 [XRT](https://github.com/airalab/robonomics_contracts/blob/master/contracts/robonomics/XRT.sol) Token\n- [Factory](https://github.com/airalab/robonomics_contracts/blob/master/contracts/robonomics/Factory.sol)\n- Own contract for [ENS](https://github.com/airalab/robonomics_contracts/blob/master/contracts/ens/ENS.sol)\n- [Proxy](https://github.com/airalab/robonomics_contracts/blob/master/contracts/misc/SharedCode.sol) for contracts\n- Various modifiers and roles in contracts\n\nAddresses of contracts in the Neon devnet network https://devnet.neonevm.org\n\n| Contract Name  | Address                                    |\n|----------------|--------------------------------------------|\n| Migrations     | 0x1DC538bE2C8572509a571B150f11aB55E52EF12E |\n| ENS            | 0xa7AEa12F60D0278F01e14DBC7cc459d04d051406 |\n| DutchAuction   | 0xF44F8803548D72Dbc3E28340EFD7b5328aa4F058 |\n| Liability      | 0xA694196351dc1488e3884eCc6b650F0d8D55346a |\n| Lighthouse     | 0x80FB5CC4c396E272b56700E6ffF5DBf4661013A8 |\n| XRT            | 0x3322d7D99cF65Cab5A92073c928b5E9674af3c29 |\n| PublicAmbix    | 0x85c03bE5ccFf11E79a0A776D183eF067590549d1 |\n| Factory        | 0xCFa833bF0D46369D9024f95c9C8dFa1E4a07806C |\n| PublicResolver | 0xAC9E9AA8A4cB524FE87f2b14489F1D6bE68dc46e |\n\n[Source code](https://github.com/Multi-Agent-io/neon-kuka-demo) for the scenario\n\n## Changes Made to Original Contracts\n\nThe contracts are written for Solidity 0.5.0. As such, no changes were required when deploying and using the contracts.\n\n## Testing Workflow\n\nIn general, the test consists of sending corresponding messages from one agent to another.\n\nNext, the Promisor finds a new liability contract in the network and begins to execute it. Upon completion of the work, a message is sent with the result, which is then recorded in the contract.\n\nStep-by-step instructions for launching are in [README.md](https://github.com/Multi-Agent-io/neon-kuka-demo/blob/main/README.md)\n\n## Testing Results in Detail\n\nScreencast of the process\n\nhttps://youtu.be/fYJVF7KrNnI\n\n![Liability](./images/testing-neon-with-robonomics/liability.jpg)\n\nWhen the simulation starts, an offer message is created, and a demand message comes from the Promisee, after which a Liability contract is created using the createLiability function of the Lighthouse contract. With the help of the XRT contract, tokens are transferred from the Promisee’s address to the address of the Liability contract.\n\nAfter a new Liability contract has been discovered on the Neon devnet, the agent starts working. The result of the work (telemetry) is written to a file and sent to IPFS, the hash from the file is saved as a result.\n\nAfter the work is completed, the Liability contract is finalized using the finalizeLiability() function of the Lighthouse contract and the tokens are transferred from the Liability address to the addresses of the Promisor and Validator.\n\nThe successful execution of the simulation showed that all contracts worked correctly and the Neon platform works.\n\n## Neon Platform Drawbacks\n\n### Truffle fails if it doesn't get a response from the network\n\nDuring the process of deploying contracts, it turned out that the proxy does not always return a response on time, which is why Truffle ends with an error:\n\n```\nTypeError: Cannot read properties of null (reading 'from')                                    \n    at Web3InterfaceAdapter.<anonymous> (/usr/lib/node_modules/truffle/build/webpack:/packages\n/interface-adapter/dist/adapter/web3/index.js:71:1)                                           \n    at Generator.next (<anonymous>)                                                           \n    at fulfilled (/usr/lib/node_modules/truffle/build/webpack:/packages/interface-adapter/dist\n/adapter/web3/index.js:5:43)                                                                  \n    at runMicrotasks (<anonymous>)\n    at processTicksAndRejections (node:internal/process/task_queues:96:5)\nTruffle v5.5.23 (core: 5.5.23)\nNode v16.14.0\n```\n\nIt was not possible to find a relationship between the test conditions and the occurrence of an error, but most likely Neon EVM cannot send a transaction receipt, and Truffle cannot process a Null response.\n\nIf we add timeout and retry here [index.ts#L75](https://github.com/trufflesuite/truffle/blob/develop/packages/interface-adapter/lib/adapter/web3/index.ts#L75), then the deployment should proceed without errors.\n\n### No WS/WSS Endpoint\n\nNeon EVM does not have a WS/WSS endpoint unlike Ethereum, which makes it impossible to subscribe to events from the network. Therefore, during testing, we monitored the events manually.\n\n### No Event Names\n\nNeon EVM returns rather poor descriptions of events after a transaction, for example:\n\n```\n events: {\n    '0': {\n      address: '0xCFa833bF0D46369D9024f95c9C8dFa1E4a07806C',\n      transactionHash: '0x9894a984e6b3f6ce469c8837e11739f6e50d00216cf7c5bc3d32da106a58d50a',\n      transactionLogIndex: '0x1',\n      blockHash: '0x72040f317d3a469d30327d4e1def903790b70dbede46b4f0ea4f28f30a679a80',\n      blockNumber: 156073183,\n      transactionIndex: 0,\n      logIndex: 1,\n      id: 'log_e51e2f9f',\n      returnValues: Result {},\n      event: undefined,\n      signature: null,\n      raw: [Object]\n    },\n...\n```\n\nInstead of 0, 1, etc. we expected to see named events.\n\n## Conclusion\n\nUsing the Neon EVM platform, a scenario was successfully tested whereby a liability contract between a Promisee and a Promisor is concluded with subsequent validation of the result of the work done by a third party. Additionally, a Provider participated, who checked the coincidence of supply and demand between the parties, and received a commission for this work.\n\nThe demonstration used a simulation of a robotic arm that was hired to perform a sequence of actions. As a result of the work, the robot sent a file with telemetry received during the task.\n\nDespite some peculiarities in the operation of the network, in the end, all participating contracts showed their operability in the Neon environment.\n\n\n\n","cover_image":{"type":"image","mimeType":"image/jpeg","src":"/assets/static/blog_cover_neon_multi-agent.62c183a.6231caf624da0ea84dd55d0582533702.jpg","size":{"width":1500,"height":675},"sizes":"(max-width: 1500px) 100vw, 1500px","srcset":["/assets/static/blog_cover_neon_multi-agent.9ea8d39.6231caf624da0ea84dd55d0582533702.jpg 480w","/assets/static/blog_cover_neon_multi-agent.6b2ed88.6231caf624da0ea84dd55d0582533702.jpg 1024w","/assets/static/blog_cover_neon_multi-agent.62c183a.6231caf624da0ea84dd55d0582533702.jpg 1500w"],"dataUri":"data:image/svg+xml,%3csvg fill='none' viewBox='0 0 1500 675' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'%3e%3cdefs%3e%3cfilter id='__svg-blur-6809607028734338a4644390df615667'%3e%3cfeGaussianBlur in='SourceGraphic' stdDeviation='40'/%3e%3c/filter%3e%3c/defs%3e%3cimage x='0' y='0' filter='url(%23__svg-blur-6809607028734338a4644390df615667)' width='1500' height='675' xlink:href='data:image/jpeg%3bbase64%2c/9j/2wBDAAYEBQYFBAYGBQYHBwYIChAKCgkJChQODwwQFxQYGBcUFhYaHSUfGhsjHBYWICwgIyYnKSopGR8tMC0oMCUoKSj/2wBDAQcHBwoIChMKChMoGhYaKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCj/wAARCAAdAEADASIAAhEBAxEB/8QAGwAAAgMAAwAAAAAAAAAAAAAAAgUDBAYBBwj/xAAuEAACAQMDAgQFBAMAAAAAAAABAgMABBEFEiEGMRRBQlETUnGBkQciMkNyobH/xAAYAQADAQEAAAAAAAAAAAAAAAAAAQMCBP/EACARAAIDAAICAwEAAAAAAAAAAAECAAMREjEhQTJxofD/2gAMAwEAAhEDEQA/APL0UXxFc7gNoz2qOiSRkBCnAPettddCi36et9V8aJI7jTxepGAAysFyykHuO2CPI11VUvccQdStNFlpPAbkw9HAqvIFclVPcgZP4rZWv6fz3Ns08Ws6WVXYGUu27ceSoGMk8gD5jwOaVa/09JoAhdr20u3ZtrJCTlDjIzke34PB5qIMkevESXMaxTMiljtJB3DBB9iKAxuApKNhslTjv5cVahWG4uH8ZN8A/wCJbLfXyrfab0zjRJjbiSSWJC8Mwm%2bGWZkDEKApwBkDk4J9qZgNzzOtSCO4I%2boqSSLZEj7gd3lg021/T721LvqM8ksgYBCxLZX3z%2bP90naRmUKT%2b0dqBA76g1ea8vp7SNZL2ZobcFI42kOEBGCFHkCOKo0ayMsbIP4t3pgkR6w%2bJkf2FP8AobSU1jqW1t5wfCJumuGHpjUZJ/4PvSGtV0W6JpfUG6PcwtgyMGKlSA3PHfv2NStV2QqnZlaWRbA1nQ/v2UtZk0G6txcaet3b3juVeB8MgA/sBA9Xy44Oe4q/o3VEqW62MkT7ZI1hYpOyBsKEHHpO0YJGM45rJDtXNCJwGbv3MO3M8iIx1i%2buNUl8ZdOmTwqKMbR7UuozKxiEfpBzQVSYG%2b5//9k=' /%3e%3c/svg%3e"},"locale":"zh"}}]}},"allPostsTags":{"edges":[{"node":{"locale":"ru","tags":[{"id":"NFT","title":"NFT","path":"/blog/tag/NFT/"},{"id":"Мерч","title":"Мерч","path":"/blog/tag/%D0%9C%D0%B5%D1%80%D1%87/"},{"id":"Сообщество","title":"Сообщество","path":"/blog/tag/%D0%A1%D0%BE%D0%BE%D0%B1%D1%89%D0%B5%D1%81%D1%82%D0%B2%D0%BE/"}]}},{"node":{"locale":"en","tags":[{"id":"NFT","title":"NFT","path":"/blog/tag/NFT/"},{"id":"Merch","title":"Merch","path":"/blog/tag/Merch/"},{"id":"Community","title":"Community","path":"/blog/tag/Community/"}]}},{"node":{"locale":"en","tags":[{"id":"ROS 2","title":"ROS 2","path":"/blog/tag/ROS%202/"},{"id":"Use Cases","title":"Use Cases","path":"/blog/tag/Use%20Cases/"},{"id":"Collaborations","title":"Collaborations","path":"/blog/tag/Collaborations/"}]}},{"node":{"locale":"en","tags":[{"id":"Robonomics parachain","title":"Robonomics parachain","path":"/blog/tag/Robonomics%20parachain/"},{"id":"Polkadot","title":"Polkadot","path":"/blog/tag/Polkadot/"},{"id":"Announcements","title":"Announcements","path":"/blog/tag/Announcements/"}]}},{"node":{"locale":"ru","tags":[{"id":"Парачейн Робономика","title":"Парачейн Робономика","path":"/blog/tag/%D0%9F%D0%B0%D1%80%D0%B0%D1%87%D0%B5%D0%B9%D0%BD%20%D0%A0%D0%BE%D0%B1%D0%BE%D0%BD%D0%BE%D0%BC%D0%B8%D0%BA%D0%B0/"},{"id":"Сотрудничество","title":"Сотрудничество","path":"/blog/tag/%D0%A1%D0%BE%D1%82%D1%80%D1%83%D0%B4%D0%BD%D0%B8%D1%87%D0%B5%D1%81%D1%82%D0%B2%D0%BE/"}]}},{"node":{"locale":"en","tags":[{"id":"Robonomics parachain","title":"Robonomics parachain","path":"/blog/tag/Robonomics%20parachain/"},{"id":"Collaborations","title":"Collaborations","path":"/blog/tag/Collaborations/"}]}},{"node":{"locale":"ru","tags":[{"id":"Парачейн Робономика","title":"Парачейн Робономика","path":"/blog/tag/%D0%9F%D0%B0%D1%80%D0%B0%D1%87%D0%B5%D0%B9%D0%BD%20%D0%A0%D0%BE%D0%B1%D0%BE%D0%BD%D0%BE%D0%BC%D0%B8%D0%BA%D0%B0/"},{"id":"Полкадот","title":"Полкадот","path":"/blog/tag/%D0%9F%D0%BE%D0%BB%D0%BA%D0%B0%D0%B4%D0%BE%D1%82/"}]}},{"node":{"locale":"en","tags":[{"id":"Robonomics parachain","title":"Robonomics parachain","path":"/blog/tag/Robonomics%20parachain/"},{"id":"Polkadot","title":"Polkadot","path":"/blog/tag/Polkadot/"}]}},{"node":{"locale":"ru","tags":[{"id":"Парачейн Робономика","title":"Парачейн Робономика","path":"/blog/tag/%D0%9F%D0%B0%D1%80%D0%B0%D1%87%D0%B5%D0%B9%D0%BD%20%D0%A0%D0%BE%D0%B1%D0%BE%D0%BD%D0%BE%D0%BC%D0%B8%D0%BA%D0%B0/"},{"id":"Сообщество","title":"Сообщество","path":"/blog/tag/%D0%A1%D0%BE%D0%BE%D0%B1%D1%89%D0%B5%D1%81%D1%82%D0%B2%D0%BE/"}]}},{"node":{"locale":"it","tags":[{"id":"Robonomics parachain","title":"Robonomics parachain","path":"/blog/tag/Robonomics%20parachain/"},{"id":"Community","title":"Community","path":"/blog/tag/Community/"}]}},{"node":{"locale":"en","tags":[{"id":"Robonomics parachain","title":"Robonomics parachain","path":"/blog/tag/Robonomics%20parachain/"},{"id":"Community","title":"Community","path":"/blog/tag/Community/"}]}},{"node":{"locale":"zh","tags":[{"id":"Robonomics in Ethereum","title":"Robonomics in Ethereum","path":"/blog/tag/Robonomics%20in%20Ethereum/"},{"id":"Collaborations","title":"Collaborations","path":"/blog/tag/Collaborations/"},{"id":"Smart Contracts","title":"Smart Contracts","path":"/blog/tag/Smart%20Contracts/"},{"id":"Neon","title":"Neon","path":"/blog/tag/Neon/"}]}},{"node":{"locale":"ru","tags":[{"id":"Robonomics в Ethereum","title":"Robonomics в Ethereum","path":"/blog/tag/Robonomics%20%D0%B2%20Ethereum/"},{"id":"Сотрудничество","title":"Сотрудничество","path":"/blog/tag/%D0%A1%D0%BE%D1%82%D1%80%D1%83%D0%B4%D0%BD%D0%B8%D1%87%D0%B5%D1%81%D1%82%D0%B2%D0%BE/"},{"id":"Умные контракты","title":"Умные контракты","path":"/blog/tag/%D0%A3%D0%BC%D0%BD%D1%8B%D0%B5%20%D0%BA%D0%BE%D0%BD%D1%82%D1%80%D0%B0%D0%BA%D1%82%D1%8B/"},{"id":"Neon","title":"Neon","path":"/blog/tag/Neon/"}]}},{"node":{"locale":"pt","tags":[{"id":"Robonomics in Ethereum","title":"Robonomics in Ethereum","path":"/blog/tag/Robonomics%20in%20Ethereum/"},{"id":"Collaborations","title":"Collaborations","path":"/blog/tag/Collaborations/"},{"id":"Smart Contracts","title":"Smart Contracts","path":"/blog/tag/Smart%20Contracts/"},{"id":"Neon","title":"Neon","path":"/blog/tag/Neon/"}]}},{"node":{"locale":"ko","tags":[{"id":"Robonomics in Ethereum","title":"Robonomics in Ethereum","path":"/blog/tag/Robonomics%20in%20Ethereum/"},{"id":"Collaborations","title":"Collaborations","path":"/blog/tag/Collaborations/"},{"id":"Smart Contracts","title":"Smart Contracts","path":"/blog/tag/Smart%20Contracts/"},{"id":"Neon","title":"Neon","path":"/blog/tag/Neon/"}]}},{"node":{"locale":"ja","tags":[{"id":"Robonomics in Ethereum","title":"Robonomics in Ethereum","path":"/blog/tag/Robonomics%20in%20Ethereum/"},{"id":"Collaborations","title":"Collaborations","path":"/blog/tag/Collaborations/"},{"id":"Smart Contracts","title":"Smart Contracts","path":"/blog/tag/Smart%20Contracts/"},{"id":"Neon","title":"Neon","path":"/blog/tag/Neon/"}]}},{"node":{"locale":"it","tags":[{"id":"Robonomics in Ethereum","title":"Robonomics in Ethereum","path":"/blog/tag/Robonomics%20in%20Ethereum/"},{"id":"Collaborations","title":"Collaborations","path":"/blog/tag/Collaborations/"},{"id":"Smart Contracts","title":"Smart Contracts","path":"/blog/tag/Smart%20Contracts/"},{"id":"Neon","title":"Neon","path":"/blog/tag/Neon/"}]}},{"node":{"locale":"fr","tags":[{"id":"Robonomics in Ethereum","title":"Robonomics in Ethereum","path":"/blog/tag/Robonomics%20in%20Ethereum/"},{"id":"Collaborations","title":"Collaborations","path":"/blog/tag/Collaborations/"},{"id":"Smart Contracts","title":"Smart Contracts","path":"/blog/tag/Smart%20Contracts/"},{"id":"Neon","title":"Neon","path":"/blog/tag/Neon/"}]}},{"node":{"locale":"es","tags":[{"id":"Robonomics in Ethereum","title":"Robonomics in Ethereum","path":"/blog/tag/Robonomics%20in%20Ethereum/"},{"id":"Collaborations","title":"Collaborations","path":"/blog/tag/Collaborations/"},{"id":"Smart Contracts","title":"Smart Contracts","path":"/blog/tag/Smart%20Contracts/"},{"id":"Neon","title":"Neon","path":"/blog/tag/Neon/"}]}},{"node":{"locale":"de","tags":[{"id":"Robonomics in Ethereum","title":"Robonomics in Ethereum","path":"/blog/tag/Robonomics%20in%20Ethereum/"},{"id":"Collaborations","title":"Collaborations","path":"/blog/tag/Collaborations/"},{"id":"Smart Contracts","title":"Smart Contracts","path":"/blog/tag/Smart%20Contracts/"},{"id":"Neon","title":"Neon","path":"/blog/tag/Neon/"}]}},{"node":{"locale":"az","tags":[{"id":"Robonomics in Ethereum","title":"Robonomics in Ethereum","path":"/blog/tag/Robonomics%20in%20Ethereum/"},{"id":"Collaborations","title":"Collaborations","path":"/blog/tag/Collaborations/"},{"id":"Smart Contracts","title":"Smart Contracts","path":"/blog/tag/Smart%20Contracts/"},{"id":"Neon","title":"Neon","path":"/blog/tag/Neon/"}]}},{"node":{"locale":"en","tags":[{"id":"Robonomics in Ethereum","title":"Robonomics in Ethereum","path":"/blog/tag/Robonomics%20in%20Ethereum/"},{"id":"Collaborations","title":"Collaborations","path":"/blog/tag/Collaborations/"},{"id":"Smart Contracts","title":"Smart Contracts","path":"/blog/tag/Smart%20Contracts/"},{"id":"Neon","title":"Neon","path":"/blog/tag/Neon/"}]}},{"node":{"locale":"ru","tags":[{"id":"События","title":"События","path":"/blog/tag/%D0%A1%D0%BE%D0%B1%D1%8B%D1%82%D0%B8%D1%8F/"},{"id":"Полкадот","title":"Полкадот","path":"/blog/tag/%D0%9F%D0%BE%D0%BB%D0%BA%D0%B0%D0%B4%D0%BE%D1%82/"},{"id":"Умный дом","title":"Умный дом","path":"/blog/tag/%D0%A3%D0%BC%D0%BD%D1%8B%D0%B9%20%D0%B4%D0%BE%D0%BC/"},{"id":"Интернет вещей","title":"Интернет вещей","path":"/blog/tag/%D0%98%D0%BD%D1%82%D0%B5%D1%80%D0%BD%D0%B5%D1%82%20%D0%B2%D0%B5%D1%89%D0%B5%D0%B9/"}]}},{"node":{"locale":"en","tags":[{"id":"Events","title":"Events","path":"/blog/tag/Events/"},{"id":"Polkadot","title":"Polkadot","path":"/blog/tag/Polkadot/"},{"id":"Smart Home","title":"Smart Home","path":"/blog/tag/Smart%20Home/"},{"id":"Internet of Things","title":"Internet of Things","path":"/blog/tag/Internet%20of%20Things/"}]}},{"node":{"locale":"ru","tags":[{"id":"Философия Робономики","title":"Философия Робономики","path":"/blog/tag/%D0%A4%D0%B8%D0%BB%D0%BE%D1%81%D0%BE%D1%84%D0%B8%D1%8F%20%D0%A0%D0%BE%D0%B1%D0%BE%D0%BD%D0%BE%D0%BC%D0%B8%D0%BA%D0%B8/"}]}},{"node":{"locale":"pt","tags":[{"id":"Filosofia da Robonomia","title":"Filosofia da Robonomia","path":"/blog/tag/Filosofia%20da%20Robonomia/"}]}},{"node":{"locale":"it","tags":[{"id":"Filosofia della Robonomics","title":"Filosofia della Robonomics","path":"/blog/tag/Filosofia%20della%20Robonomics/"}]}},{"node":{"locale":"es","tags":[{"id":"Filosofía de la Robonomía","title":"Filosofía de la Robonomía","path":"/blog/tag/Filosof%C3%ADa%20de%20la%20Robonom%C3%ADa/"}]}},{"node":{"locale":"en","tags":[{"id":"Philosophy of Robonomics","title":"Philosophy of Robonomics","path":"/blog/tag/Philosophy%20of%20Robonomics/"}]}},{"node":{"locale":"ru","tags":[{"id":"Парачейн Робономика","title":"Парачейн Робономика","path":"/blog/tag/%D0%9F%D0%B0%D1%80%D0%B0%D1%87%D0%B5%D0%B9%D0%BD%20%D0%A0%D0%BE%D0%B1%D0%BE%D0%BD%D0%BE%D0%BC%D0%B8%D0%BA%D0%B0/"},{"id":"Сообщество","title":"Сообщество","path":"/blog/tag/%D0%A1%D0%BE%D0%BE%D0%B1%D1%89%D0%B5%D1%81%D1%82%D0%B2%D0%BE/"}]}},{"node":{"locale":"en","tags":[{"id":"Robonomics parachain","title":"Robonomics parachain","path":"/blog/tag/Robonomics%20parachain/"},{"id":"Community","title":"Community","path":"/blog/tag/Community/"}]}},{"node":{"locale":"ru","tags":[{"id":"Парачейн Робономика","title":"Парачейн Робономика","path":"/blog/tag/%D0%9F%D0%B0%D1%80%D0%B0%D1%87%D0%B5%D0%B9%D0%BD%20%D0%A0%D0%BE%D0%B1%D0%BE%D0%BD%D0%BE%D0%BC%D0%B8%D0%BA%D0%B0/"},{"id":"XRT токен","title":"XRT токен","path":"/blog/tag/XRT%20%D1%82%D0%BE%D0%BA%D0%B5%D0%BD/"}]}},{"node":{"locale":"pt","tags":[{"id":"Paracadeia de Robonomics","title":"Paracadeia de Robonomics","path":"/blog/tag/Paracadeia%20de%20Robonomics/"},{"id":"Token XRT","title":"Token XRT","path":"/blog/tag/Token%20XRT/"}]}},{"node":{"locale":"it","tags":[{"id":"Robonomics paracatena","title":"Robonomics paracatena","path":"/blog/tag/Robonomics%20paracatena/"},{"id":"Gettone XRT","title":"Gettone XRT","path":"/blog/tag/Gettone%20XRT/"}]}},{"node":{"locale":"fr","tags":[{"id":"Parachaîne Robonomics","title":"Parachaîne Robonomics","path":"/blog/tag/Paracha%C3%AEne%20Robonomics/"},{"id":"Jeton XRT","title":"Jeton XRT","path":"/blog/tag/Jeton%20XRT/"}]}},{"node":{"locale":"es","tags":[{"id":"Paracaídas Robonomics","title":"Paracaídas Robonomics","path":"/blog/tag/Paraca%C3%ADdas%20Robonomics/"},{"id":"Token XRT","title":"Token XRT","path":"/blog/tag/Token%20XRT/"}]}},{"node":{"locale":"az","tags":[{"id":"Robonimika parachain","title":"Robonimika parachain","path":"/blog/tag/Robonimika%20parachain/"},{"id":"XRT tokeni","title":"XRT tokeni","path":"/blog/tag/XRT%20tokeni/"}]}},{"node":{"locale":"en","tags":[{"id":"Robonomics parachain","title":"Robonomics parachain","path":"/blog/tag/Robonomics%20parachain/"},{"id":"XRT token","title":"XRT token","path":"/blog/tag/XRT%20token/"}]}},{"node":{"locale":"pt","tags":[{"id":"Colaborações","title":"Colaborações","path":"/blog/tag/Colabora%C3%A7%C3%B5es/"},{"id":"Paracadeia de Robonomics","title":"Paracadeia de Robonomics","path":"/blog/tag/Paracadeia%20de%20Robonomics/"}]}},{"node":{"locale":"it","tags":[{"id":"Collaborazioni","title":"Collaborazioni","path":"/blog/tag/Collaborazioni/"},{"id":"Robonomics paracatena","title":"Robonomics paracatena","path":"/blog/tag/Robonomics%20paracatena/"}]}},{"node":{"locale":"az","tags":[{"id":"Əməkdaşlıq","title":"Əməkdaşlıq","path":"/blog/tag/%C6%8Fm%C9%99kda%C5%9Fl%C4%B1q/"},{"id":"Robonimika parachain","title":"Robonimika parachain","path":"/blog/tag/Robonimika%20parachain/"}]}},{"node":{"locale":"en","tags":[{"id":"Collaborations","title":"Collaborations","path":"/blog/tag/Collaborations/"},{"id":"Robonomics parachain","title":"Robonomics parachain","path":"/blog/tag/Robonomics%20parachain/"}]}},{"node":{"locale":"ru","tags":[{"id":"События","title":"События","path":"/blog/tag/%D0%A1%D0%BE%D0%B1%D1%8B%D1%82%D0%B8%D1%8F/"},{"id":"Полкадот","title":"Полкадот","path":"/blog/tag/%D0%9F%D0%BE%D0%BB%D0%BA%D0%B0%D0%B4%D0%BE%D1%82/"}]}},{"node":{"locale":"es","tags":[{"id":"Eventos","title":"Eventos","path":"/blog/tag/Eventos/"},{"id":"Polkadot","title":"Polkadot","path":"/blog/tag/Polkadot/"}]}},{"node":{"locale":"de","tags":[{"id":"Veranstaltungen","title":"Veranstaltungen","path":"/blog/tag/Veranstaltungen/"},{"id":"Polkadot","title":"Polkadot","path":"/blog/tag/Polkadot/"}]}},{"node":{"locale":"en","tags":[{"id":"Events","title":"Events","path":"/blog/tag/Events/"},{"id":"Polkadot","title":"Polkadot","path":"/blog/tag/Polkadot/"}]}},{"node":{"locale":"ru","tags":[{"id":"Парачейн Робономика","title":"Парачейн Робономика","path":"/blog/tag/%D0%9F%D0%B0%D1%80%D0%B0%D1%87%D0%B5%D0%B9%D0%BD%20%D0%A0%D0%BE%D0%B1%D0%BE%D0%BD%D0%BE%D0%BC%D0%B8%D0%BA%D0%B0/"},{"id":"Дорожная карта","title":"Дорожная карта","path":"/blog/tag/%D0%94%D0%BE%D1%80%D0%BE%D0%B6%D0%BD%D0%B0%D1%8F%20%D0%BA%D0%B0%D1%80%D1%82%D0%B0/"},{"id":"Новый релиз","title":"Новый релиз","path":"/blog/tag/%D0%9D%D0%BE%D0%B2%D1%8B%D0%B9%20%D1%80%D0%B5%D0%BB%D0%B8%D0%B7/"}]}},{"node":{"locale":"es","tags":[{"id":"Paracaídas Robonomics","title":"Paracaídas Robonomics","path":"/blog/tag/Paraca%C3%ADdas%20Robonomics/"},{"id":"Mapa ruta","title":"Mapa ruta","path":"/blog/tag/Mapa%20ruta/"},{"id":"Nuevo lanzamiento","title":"Nuevo lanzamiento","path":"/blog/tag/Nuevo%20lanzamiento/"}]}},{"node":{"locale":"de","tags":[{"id":"Robonomics Parachain","title":"Robonomics Parachain","path":"/blog/tag/Robonomics%20Parachain/"},{"id":"Fahrplan","title":"Fahrplan","path":"/blog/tag/Fahrplan/"},{"id":"Neue Version","title":"Neue Version","path":"/blog/tag/Neue%20Version/"}]}},{"node":{"locale":"en","tags":[{"id":"Robonomics parachain","title":"Robonomics parachain","path":"/blog/tag/Robonomics%20parachain/"},{"id":"Roadmap","title":"Roadmap","path":"/blog/tag/Roadmap/"},{"id":"New release","title":"New release","path":"/blog/tag/New%20release/"}]}},{"node":{"locale":"zh","tags":[]}},{"node":{"locale":"ru","tags":[{"id":"Парачейн Робономика","title":"Парачейн Робономика","path":"/blog/tag/%D0%9F%D0%B0%D1%80%D0%B0%D1%87%D0%B5%D0%B9%D0%BD%20%D0%A0%D0%BE%D0%B1%D0%BE%D0%BD%D0%BE%D0%BC%D0%B8%D0%BA%D0%B0/"},{"id":"Сообщество","title":"Сообщество","path":"/blog/tag/%D0%A1%D0%BE%D0%BE%D0%B1%D1%89%D0%B5%D1%81%D1%82%D0%B2%D0%BE/"}]}},{"node":{"locale":"ko","tags":[]}},{"node":{"locale":"ja","tags":[]}},{"node":{"locale":"es","tags":[]}},{"node":{"locale":"de","tags":[{"id":"Robonomics Parachain","title":"Robonomics Parachain","path":"/blog/tag/Robonomics%20Parachain/"},{"id":"Gemeinschaft","title":"Gemeinschaft","path":"/blog/tag/Gemeinschaft/"}]}},{"node":{"locale":"en","tags":[{"id":"Robonomics parachain","title":"Robonomics parachain","path":"/blog/tag/Robonomics%20parachain/"},{"id":"Community","title":"Community","path":"/blog/tag/Community/"}]}},{"node":{"locale":"ru","tags":[{"id":"Парачейн Робономика","title":"Парачейн Робономика","path":"/blog/tag/%D0%9F%D0%B0%D1%80%D0%B0%D1%87%D0%B5%D0%B9%D0%BD%20%D0%A0%D0%BE%D0%B1%D0%BE%D0%BD%D0%BE%D0%BC%D0%B8%D0%BA%D0%B0/"},{"id":"Дорожная карта","title":"Дорожная карта","path":"/blog/tag/%D0%94%D0%BE%D1%80%D0%BE%D0%B6%D0%BD%D0%B0%D1%8F%20%D0%BA%D0%B0%D1%80%D1%82%D0%B0/"},{"id":"Новый релиз","title":"Новый релиз","path":"/blog/tag/%D0%9D%D0%BE%D0%B2%D1%8B%D0%B9%20%D1%80%D0%B5%D0%BB%D0%B8%D0%B7/"}]}},{"node":{"locale":"en","tags":[{"id":"Robonomics parachain","title":"Robonomics parachain","path":"/blog/tag/Robonomics%20parachain/"},{"id":"Roadmap","title":"Roadmap","path":"/blog/tag/Roadmap/"},{"id":"New release","title":"New release","path":"/blog/tag/New%20release/"}]}},{"node":{"locale":"zh","tags":[]}},{"node":{"locale":"ru","tags":[{"id":"Онлайн школа","title":"Онлайн школа","path":"/blog/tag/%D0%9E%D0%BD%D0%BB%D0%B0%D0%B9%D0%BD%20%D1%88%D0%BA%D0%BE%D0%BB%D0%B0/"},{"id":"Сценарии использования","title":"Сценарии использования","path":"/blog/tag/%D0%A1%D1%86%D0%B5%D0%BD%D0%B0%D1%80%D0%B8%D0%B8%20%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F/"}]}},{"node":{"locale":"ko","tags":[]}},{"node":{"locale":"es","tags":[]}},{"node":{"locale":"en","tags":[{"id":"Online school","title":"Online school","path":"/blog/tag/Online%20school/"},{"id":"Use Cases","title":"Use Cases","path":"/blog/tag/Use%20Cases/"}]}},{"node":{"locale":"en","tags":[{"id":"Online school","title":"Online school","path":"/blog/tag/Online%20school/"},{"id":"Philosophy of Robonomics","title":"Philosophy of Robonomics","path":"/blog/tag/Philosophy%20of%20Robonomics/"}]}},{"node":{"locale":"zh","tags":[]}},{"node":{"locale":"ru","tags":[{"id":"Онлайн школа","title":"Онлайн школа","path":"/blog/tag/%D0%9E%D0%BD%D0%BB%D0%B0%D0%B9%D0%BD%20%D1%88%D0%BA%D0%BE%D0%BB%D0%B0/"},{"id":"Философия Робономики","title":"Философия Робономики","path":"/blog/tag/%D0%A4%D0%B8%D0%BB%D0%BE%D1%81%D0%BE%D1%84%D0%B8%D1%8F%20%D0%A0%D0%BE%D0%B1%D0%BE%D0%BD%D0%BE%D0%BC%D0%B8%D0%BA%D0%B8/"}]}},{"node":{"locale":"ko","tags":[]}},{"node":{"locale":"es","tags":[]}},{"node":{"locale":"zh","tags":[]}},{"node":{"locale":"ru","tags":[]}},{"node":{"locale":"ko","tags":[]}},{"node":{"locale":"es","tags":[]}},{"node":{"locale":"en","tags":[{"id":"Online school","title":"Online school","path":"/blog/tag/Online%20school/"},{"id":"Demo","title":"Demo","path":"/blog/tag/Demo/"}]}},{"node":{"locale":"zh","tags":[]}},{"node":{"locale":"ru","tags":[{"id":"Онлайн школа","title":"Онлайн школа","path":"/blog/tag/%D0%9E%D0%BD%D0%BB%D0%B0%D0%B9%D0%BD%20%D1%88%D0%BA%D0%BE%D0%BB%D0%B0/"}]}},{"node":{"locale":"ko","tags":[]}},{"node":{"locale":"es","tags":[]}},{"node":{"locale":"en","tags":[{"id":"Online school","title":"Online school","path":"/blog/tag/Online%20school/"}]}},{"node":{"locale":"ru","tags":[{"id":"Парачейн Робономика","title":"Парачейн Робономика","path":"/blog/tag/%D0%9F%D0%B0%D1%80%D0%B0%D1%87%D0%B5%D0%B9%D0%BD%20%D0%A0%D0%BE%D0%B1%D0%BE%D0%BD%D0%BE%D0%BC%D0%B8%D0%BA%D0%B0/"}]}},{"node":{"locale":"en","tags":[{"id":"Robonomics parachain","title":"Robonomics parachain","path":"/blog/tag/Robonomics%20parachain/"}]}},{"node":{"locale":"ru","tags":[{"id":"Дорожная карта","title":"Дорожная карта","path":"/blog/tag/%D0%94%D0%BE%D1%80%D0%BE%D0%B6%D0%BD%D0%B0%D1%8F%20%D0%BA%D0%B0%D1%80%D1%82%D0%B0/"},{"id":"Сценарии использования","title":"Сценарии использования","path":"/blog/tag/%D0%A1%D1%86%D0%B5%D0%BD%D0%B0%D1%80%D0%B8%D0%B8%20%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F/"}]}},{"node":{"locale":"en","tags":[{"id":"Roadmap","title":"Roadmap","path":"/blog/tag/Roadmap/"},{"id":"Use Cases","title":"Use Cases","path":"/blog/tag/Use%20Cases/"}]}},{"node":{"locale":"en","tags":[{"id":"Robonomics parachain","title":"Robonomics parachain","path":"/blog/tag/Robonomics%20parachain/"},{"id":"Collaborations","title":"Collaborations","path":"/blog/tag/Collaborations/"}]}},{"node":{"locale":"zh","tags":[{"id":"Robonomics 平行链","title":"Robonomics 平行链","path":"/blog/tag/Robonomics%20%E5%B9%B3%E8%A1%8C%E9%93%BE/"}]}},{"node":{"locale":"ru","tags":[{"id":"Парачейн Робономика","title":"Парачейн Робономика","path":"/blog/tag/%D0%9F%D0%B0%D1%80%D0%B0%D1%87%D0%B5%D0%B9%D0%BD%20%D0%A0%D0%BE%D0%B1%D0%BE%D0%BD%D0%BE%D0%BC%D0%B8%D0%BA%D0%B0/"}]}},{"node":{"locale":"ko","tags":[{"id":"로봇공학 파라체인","title":"로봇공학 파라체인","path":"/blog/tag/%EB%A1%9C%EB%B4%87%EA%B3%B5%ED%95%99%20%ED%8C%8C%EB%9D%BC%EC%B2%B4%EC%9D%B8/"}]}},{"node":{"locale":"es","tags":[{"id":"Paracaídas Robonomics","title":"Paracaídas Robonomics","path":"/blog/tag/Paraca%C3%ADdas%20Robonomics/"}]}},{"node":{"locale":"en","tags":[{"id":"Robonomics parachain","title":"Robonomics parachain","path":"/blog/tag/Robonomics%20parachain/"}]}},{"node":{"locale":"zh","tags":[{"id":"Robonomics 平行链","title":"Robonomics 平行链","path":"/blog/tag/Robonomics%20%E5%B9%B3%E8%A1%8C%E9%93%BE/"}]}},{"node":{"locale":"ru","tags":[{"id":"Токен XRT","title":"Токен XRT","path":"/blog/tag/%D0%A2%D0%BE%D0%BA%D0%B5%D0%BD%20XRT/"},{"id":"Парачейн Робономика","title":"Парачейн Робономика","path":"/blog/tag/%D0%9F%D0%B0%D1%80%D0%B0%D1%87%D0%B5%D0%B9%D0%BD%20%D0%A0%D0%BE%D0%B1%D0%BE%D0%BD%D0%BE%D0%BC%D0%B8%D0%BA%D0%B0/"}]}},{"node":{"locale":"en","tags":[{"id":"Robonomics parachain","title":"Robonomics parachain","path":"/blog/tag/Robonomics%20parachain/"}]}},{"node":{"locale":"zh","tags":[{"id":"Robonomics 平行链","title":"Robonomics 平行链","path":"/blog/tag/Robonomics%20%E5%B9%B3%E8%A1%8C%E9%93%BE/"},{"id":"XRT 代币","title":"XRT 代币","path":"/blog/tag/XRT%20%E4%BB%A3%E5%B8%81/"},{"id":"RWS 令牌","title":"RWS 令牌","path":"/blog/tag/RWS%20%E4%BB%A4%E7%89%8C/"},{"id":"质押","title":"质押","path":"/blog/tag/%E8%B4%A8%E6%8A%BC/"},{"id":"新版本","title":"新版本","path":"/blog/tag/%E6%96%B0%E7%89%88%E6%9C%AC/"}]}},{"node":{"locale":"ru","tags":[{"id":"Токен XRT","title":"Токен XRT","path":"/blog/tag/%D0%A2%D0%BE%D0%BA%D0%B5%D0%BD%20XRT/"},{"id":"Токен RWS","title":"Токен RWS","path":"/blog/tag/%D0%A2%D0%BE%D0%BA%D0%B5%D0%BD%20RWS/"},{"id":"Парачейн Робономика","title":"Парачейн Робономика","path":"/blog/tag/%D0%9F%D0%B0%D1%80%D0%B0%D1%87%D0%B5%D0%B9%D0%BD%20%D0%A0%D0%BE%D0%B1%D0%BE%D0%BD%D0%BE%D0%BC%D0%B8%D0%BA%D0%B0/"},{"id":"Новый релиз","title":"Новый релиз","path":"/blog/tag/%D0%9D%D0%BE%D0%B2%D1%8B%D0%B9%20%D1%80%D0%B5%D0%BB%D0%B8%D0%B7/"},{"id":"Стейкинг","title":"Стейкинг","path":"/blog/tag/%D0%A1%D1%82%D0%B5%D0%B9%D0%BA%D0%B8%D0%BD%D0%B3/"}]}},{"node":{"locale":"en","tags":[{"id":"Robonomics parachain","title":"Robonomics parachain","path":"/blog/tag/Robonomics%20parachain/"},{"id":"XRT token","title":"XRT token","path":"/blog/tag/XRT%20token/"},{"id":"RWS token","title":"RWS token","path":"/blog/tag/RWS%20token/"},{"id":"Staking","title":"Staking","path":"/blog/tag/Staking/"},{"id":"New release","title":"New release","path":"/blog/tag/New%20release/"}]}},{"node":{"locale":"en","tags":[{"id":"Collaborations","title":"Collaborations","path":"/blog/tag/Collaborations/"},{"id":"Use Cases","title":"Use Cases","path":"/blog/tag/Use%20Cases/"}]}},{"node":{"locale":"zh","tags":[]}},{"node":{"locale":"ru","tags":[]}},{"node":{"locale":"en","tags":[{"id":"Robonomics parachain","title":"Robonomics parachain","path":"/blog/tag/Robonomics%20parachain/"},{"id":"Internet of Things","title":"Internet of Things","path":"/blog/tag/Internet%20of%20Things/"},{"id":"Collaborations","title":"Collaborations","path":"/blog/tag/Collaborations/"},{"id":"Use Cases","title":"Use Cases","path":"/blog/tag/Use%20Cases/"}]}},{"node":{"locale":"en","tags":[{"id":"Robonomics parachain","title":"Robonomics parachain","path":"/blog/tag/Robonomics%20parachain/"}]}},{"node":{"locale":"en","tags":[{"id":"Robonomics parachain","title":"Robonomics parachain","path":"/blog/tag/Robonomics%20parachain/"},{"id":"XRT token","title":"XRT token","path":"/blog/tag/XRT%20token/"},{"id":"Staking","title":"Staking","path":"/blog/tag/Staking/"},{"id":"Talk with team","title":"Talk with team","path":"/blog/tag/Talk%20with%20team/"}]}},{"node":{"locale":"en","tags":[{"id":"Robonomics parachain","title":"Robonomics parachain","path":"/blog/tag/Robonomics%20parachain/"},{"id":"XRT token","title":"XRT token","path":"/blog/tag/XRT%20token/"},{"id":"Staking","title":"Staking","path":"/blog/tag/Staking/"},{"id":"Roadmap","title":"Roadmap","path":"/blog/tag/Roadmap/"}]}},{"node":{"locale":"en","tags":[{"id":"Robonomics parachain","title":"Robonomics parachain","path":"/blog/tag/Robonomics%20parachain/"}]}},{"node":{"locale":"en","tags":[{"id":"Collaborations","title":"Collaborations","path":"/blog/tag/Collaborations/"}]}},{"node":{"locale":"en","tags":[{"id":"Robonomics parachain","title":"Robonomics parachain","path":"/blog/tag/Robonomics%20parachain/"}]}},{"node":{"locale":"en","tags":[{"id":"Robonomics parachain","title":"Robonomics parachain","path":"/blog/tag/Robonomics%20parachain/"},{"id":"Talk with team","title":"Talk with team","path":"/blog/tag/Talk%20with%20team/"}]}},{"node":{"locale":"en","tags":[{"id":"Robonomics parachain","title":"Robonomics parachain","path":"/blog/tag/Robonomics%20parachain/"}]}},{"node":{"locale":"en","tags":[{"id":"Robonomics parachain","title":"Robonomics parachain","path":"/blog/tag/Robonomics%20parachain/"}]}},{"node":{"locale":"en","tags":[{"id":"Events","title":"Events","path":"/blog/tag/Events/"}]}},{"node":{"locale":"en","tags":[{"id":"Robonomics parachain","title":"Robonomics parachain","path":"/blog/tag/Robonomics%20parachain/"},{"id":"XRT token","title":"XRT token","path":"/blog/tag/XRT%20token/"},{"id":"Use Cases","title":"Use Cases","path":"/blog/tag/Use%20Cases/"}]}},{"node":{"locale":"en","tags":[{"id":"Robonomics parachain","title":"Robonomics parachain","path":"/blog/tag/Robonomics%20parachain/"},{"id":"XRT token","title":"XRT token","path":"/blog/tag/XRT%20token/"},{"id":"Robonomics in Ethereum","title":"Robonomics in Ethereum","path":"/blog/tag/Robonomics%20in%20Ethereum/"}]}},{"node":{"locale":"en","tags":[{"id":"Robonomics parachain","title":"Robonomics parachain","path":"/blog/tag/Robonomics%20parachain/"},{"id":"RWS token","title":"RWS token","path":"/blog/tag/RWS%20token/"},{"id":"Subscription","title":"Subscription","path":"/blog/tag/Subscription/"}]}},{"node":{"locale":"en","tags":[{"id":"Robonomics parachain","title":"Robonomics parachain","path":"/blog/tag/Robonomics%20parachain/"},{"id":"RWS token","title":"RWS token","path":"/blog/tag/RWS%20token/"},{"id":"Subscription","title":"Subscription","path":"/blog/tag/Subscription/"}]}},{"node":{"locale":"en","tags":[{"id":"Roadmap","title":"Roadmap","path":"/blog/tag/Roadmap/"},{"id":"Robonomics parachain","title":"Robonomics parachain","path":"/blog/tag/Robonomics%20parachain/"}]}},{"node":{"locale":"en","tags":[{"id":"Online school","title":"Online school","path":"/blog/tag/Online%20school/"}]}},{"node":{"locale":"en","tags":[{"id":"Collaborations","title":"Collaborations","path":"/blog/tag/Collaborations/"}]}},{"node":{"locale":"en","tags":[{"id":"Use Cases","title":"Use Cases","path":"/blog/tag/Use%20Cases/"}]}},{"node":{"locale":"en","tags":[{"id":"Talk with team","title":"Talk with team","path":"/blog/tag/Talk%20with%20team/"}]}},{"node":{"locale":"en","tags":[]}},{"node":{"locale":"en","tags":[]}},{"node":{"locale":"en","tags":[]}},{"node":{"locale":"en","tags":[{"id":"Robonomics parachain","title":"Robonomics parachain","path":"/blog/tag/Robonomics%20parachain/"}]}}]}},"context":{}}